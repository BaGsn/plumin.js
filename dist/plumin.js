!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.plumin=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/louisremi/Workspace/plumin.js/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js":[function(require,module,exports){
// Run-time checking of preconditions.

'use strict';

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
exports.argument = function (predicate, message) {
    if (!predicate) {
        throw new Error(message);
    }
};

// Precondition function that checks if the given assertion is true.
// If not, it will throw an error.
exports.assert = exports.argument;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/draw.js":[function(require,module,exports){
// Drawing utility functions.

'use strict';

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

exports.line = line;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js":[function(require,module,exports){
// Glyph encoding

'use strict';

var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

// This is the encoding used for fonts created from scratch.
// It loops through all glyphs and finds the appropriate unicode value.
// Since it's linear time, other encodings will be faster.
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function (c) {
    var code, glyphs, i, glyph, j;
    code = c.charCodeAt(0);
    glyphs = this.font.glyphs;
    if (glyphs) {
        for (i = 0; i < glyphs.length; i += 1) {
            glyph = glyphs[i];
            for (j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    } else {
        return null;
    }
};

function CmapEncoding(cmap) {
    this.cmap = cmap;
}

CmapEncoding.prototype.charToGlyphIndex = function (c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

CffEncoding.prototype.charToGlyphIndex = function (s) {
    var code, charName;
    code = s.charCodeAt(0);
    charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

function GlyphNames(post) {
    var i;
    switch (post.version) {
    case 1:
        this.names = exports.standardNames.slice();
        break;
    case 2:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] < exports.standardNames.length) {
                this.names[i] = exports.standardNames[post.glyphNameIndex[i]];
            } else {
                this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];
            }
        }
        break;
    case 2.5:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];
        }
        break;
    case 3:
        this.names = [];
        break;
    }
}

GlyphNames.prototype.nameToGlyphIndex = function (name) {
    return this.names.indexOf(name);
};

GlyphNames.prototype.glyphIndexToName = function (gid) {
    return this.names[gid];
};

function addGlyphNames(font) {
    var glyphIndexMap, charCodes, i, c, glyphIndex, glyph;
    glyphIndexMap = font.tables.cmap.glyphIndexMap;
    charCodes = Object.keys(glyphIndexMap);
    for (i = 0; i < charCodes.length; i += 1) {
        c = charCodes[i];
        glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs[glyphIndex];
        glyph.addUnicode(parseInt(c));
    }
    for (i = 0; i < font.glyphs.length; i += 1) {
        glyph = font.glyphs[i];
        if (font.cffEncoding) {
            glyph.name = font.cffEncoding.charset[i];
        } else {
            glyph.name = font.glyphNames.glyphIndexToName(i);
        }
    }
}

exports.cffStandardStrings = cffStandardStrings;
exports.cffStandardEncoding = cffStandardEncoding;
exports.cffExpertEncoding = cffExpertEncoding;
exports.standardNames = standardNames;
exports.DefaultEncoding = DefaultEncoding;
exports.CmapEncoding = CmapEncoding;
exports.CffEncoding = CffEncoding;
exports.GlyphNames = GlyphNames;
exports.addGlyphNames = addGlyphNames;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/font.js":[function(require,module,exports){
// The Font object

'use strict';

var path = require('./path');
var sfnt = require('./tables/sfnt');
var encoding = require('./encoding');

// A Font represents a loaded OpenType font file.
// It contains a set of glyphs and methods to draw text on a drawing context,
// or to get a path representing the text.
function Font(options) {
    options = options || {};
    // OS X will complain if the names are empty, so we put a single space everywhere by default.
    this.familyName = options.familyName || ' ';
    this.styleName = options.styleName || ' ';
    this.designer = options.designer || ' ';
    this.designerURL = options.designerURL || ' ';
    this.manufacturer = options.manufacturer || ' ';
    this.manufacturerURL = options.manufacturerURL || ' ';
    this.license = options.license || ' ';
    this.licenseURL = options.licenseURL || ' ';
    this.version = options.version || 'Version 0.1';
    this.description = options.description || ' ';
    this.copyright = options.copyright || ' ';
    this.trademark = options.trademark || ' ';
    this.unitsPerEm = options.unitsPerEm || 1000;
    this.supported = true;
    this.glyphs = options.glyphs || [];
    this.encoding = new encoding.DefaultEncoding(this);
    this.tables = {};
}

// Check if the font has a glyph for the given character.
Font.prototype.hasChar = function (c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

// Convert the given character to a single glyph index.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyphIndex = function (s) {
    return this.encoding.charToGlyphIndex(s);
};

// Convert the given character to a single Glyph object.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyph = function (c) {
    var glyphIndex, glyph;
    glyphIndex = this.charToGlyphIndex(c);
    glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        glyph = this.glyphs[0]; // .notdef
    }
    return glyph;
};

// Convert the given text to a list of Glyph objects.
// Note that there is no strict one-to-one mapping between characters and
// glyphs, so the list of returned glyphs can be larger or smaller than the
// length of the given string.
Font.prototype.stringToGlyphs = function (s) {
    var i, c, glyphs;
    glyphs = [];
    for (i = 0; i < s.length; i += 1) {
        c = s[i];
        glyphs.push(this.charToGlyph(c));
    }
    return glyphs;
};

Font.prototype.nameToGlyphIndex = function (name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

Font.prototype.nameToGlyph = function (name) {
    var glyphIndex, glyph;
    glyphIndex = this.nametoGlyphIndex(name);
    glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        glyph = this.glyphs[0]; // .notdef
    }
    return glyph;
};

Font.prototype.glyphIndexToName = function (gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }
    return this.glyphNames.glyphIndexToName(gid);
};

// Retrieve the value of the kerning pair between the left glyph (or its index)
// and the right glyph (or its index). If no kerning pair is found, return 0.
// The kerning value gets added to the advance width when calculating the spacing
// between glyphs.
Font.prototype.getKerningValue = function (leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.getGposKerningValue;
    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :
        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);
};

// Helper function that invokes the given callback for each glyph in the given text.
// The callback gets `(glyph, x, y, fontSize, options)`.
Font.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {
    var kerning, fontScale, glyphs, i, glyph, kerningValue;
    if (!this.supported) {
        return;
    }
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || {};
    kerning = options.kerning === undefined ? true : options.kerning;
    fontScale = 1 / this.unitsPerEm * fontSize;
    glyphs = this.stringToGlyphs(text);
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        callback(glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }
        if (kerning && i < glyphs.length - 1) {
            kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }
    }
};

// Create a Path object that represents the given text.
//
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
//
// Returns a Path object.
Font.prototype.getPath = function (text, x, y, fontSize, options) {
    var fullPath = new path.Path();
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        var path = glyph.getPath(x, y, fontSize);
        fullPath.extend(path);
    });
    return fullPath;
};

// Draw the text on the given drawing context.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.draw = function (ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

// Draw the points of all glyphs in the text.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawPoints = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        glyph.drawPoints(ctx, x, y, fontSize);
    });
};

// Draw lines indicating important font measurements for all glyphs in the text.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawMetrics = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        glyph.drawMetrics(ctx, x, y, fontSize);
    });
};

// Validate
Font.prototype.validate = function () {
    var warnings = [];
    var font = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertStringAttribute(attrName) {
        assert(font[attrName] && font[attrName].trim().length > 0, 'No ' + attrName + ' specified.');
    }

    // Identification information
    assertStringAttribute('familyName');
    assertStringAttribute('weightName');
    assertStringAttribute('manufacturer');
    assertStringAttribute('copyright');
    assertStringAttribute('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
Font.prototype.toTables = function () {
    return sfnt.fontToTable(this);
};

Font.prototype.toBuffer = function () {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }
    return buffer;
};

// Initiate a download of the OpenType font.
Font.prototype.download = function () {
    var fileName = this.familyName.replace(/\s/g, '') + '-' + this.styleName + '.otf';
    var buffer = this.toBuffer();

    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    window.requestFileSystem(window.TEMPORARY, buffer.byteLength, function (fs) {
        fs.root.getFile(fileName, {create: true}, function (fileEntry) {
            fileEntry.createWriter(function (writer) {
                var dataView = new DataView(buffer);
                var blob = new Blob([dataView], {type: 'font/opentype'});
                writer.write(blob);

                 writer.addEventListener('writeend', function () {
                    // Navigating to the file will download it.
                    location.href = fileEntry.toURL();
                 }, false);
            });
        });
    }, function (err) {
        throw err;
    });
};

exports.Font = Font;

},{"./encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","./tables/sfnt":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/sfnt.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js":[function(require,module,exports){
// The Glyph object

'use strict';

var check = require('./check');
var draw = require('./draw');
var path = require('./path');

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
function Glyph(options) {
    this.font = options.font || null;
    this.index = options.index || 0;
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
    this.xMin = options.xMin || 0;
    this.yMin = options.yMin || 0;
    this.xMax = options.xMax || 0;
    this.yMax = options.yMax || 0;
    this.advanceWidth = options.advanceWidth || 0;
    this.path = options.path || null;
}

Glyph.prototype.addUnicode = function (unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }
    this.unicodes.push(unicode);
};

// Convert the glyph to a Path we can draw on a drawing context.
//
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.getPath = function (x, y, fontSize) {
    var scale, p, commands, cmd;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    scale = 1 / this.font.unitsPerEm * fontSize;
    p = new path.Path();
    commands = this.path.commands;
    for (var i = 0; i < commands.length; i += 1) {
        cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                               x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                      x + (cmd.x2 * scale), y + (-cmd.y2 * scale),
                      x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }
    return p;
};

// Split the glyph into contours.
// This function is here for backwards compatibility, and to
// provide raw access to the TrueType glyph outlines.
Glyph.prototype.getContours = function () {
    var contours, currentContour, i, pt;
    if (this.points === undefined) {
        return [];
    }
    contours = [];
    currentContour = [];
    for (i = 0; i < this.points.length; i += 1) {
        pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

// Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
Glyph.prototype.getMetrics = function () {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }
        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }
        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }
    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: 0
    };
    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

// Draw the glyph on the given context.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.draw = function (ctx, x, y, fontSize) {
    this.getPath(x, y, fontSize).draw(ctx);
};

// Draw the points of the glyph.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawPoints = function (ctx, x, y, fontSize) {

    function drawCircles(l, x, y, scale) {
        var j, PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }
        ctx.closePath();
        ctx.fill();
    }

    var scale, i, blueCircles, redCircles, path, cmd;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;

    blueCircles = [];
    redCircles = [];
    path = this.path;
    for (i = 0; i < path.commands.length; i += 1) {
        cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }
        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }
        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

// Draw lines indicating important font measurements.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawMetrics = function (ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;
    ctx.lineWidth = 1;
    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);
    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (this.xMin * scale), -10000, x + (this.xMin * scale), 10000);
    draw.line(ctx, x + (this.xMax * scale), -10000, x + (this.xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-this.yMin * scale), 10000, y + (-this.yMin * scale));
    draw.line(ctx, -10000, y + (-this.yMax * scale), 10000, y + (-this.yMax * scale));
    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (this.advanceWidth * scale), -10000, x + (this.advanceWidth * scale), 10000);
};

exports.Glyph = Glyph;

},{"./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","./draw":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/draw.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js":[function(require,module,exports){
// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2014 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global ArrayBuffer, DataView, Uint8Array, XMLHttpRequest  */

'use strict';

var encoding = require('./encoding');
var _font = require('./font');
var glyph = require('./glyph');
var parse = require('./parse');
var path = require('./path');

var cmap = require('./tables/cmap');
var cff = require('./tables/cff');
var glyf = require('./tables/glyf');
var gpos = require('./tables/gpos');
var head = require('./tables/head');
var hhea = require('./tables/hhea');
var hmtx = require('./tables/hmtx');
var kern = require('./tables/kern');
var loca = require('./tables/loca');
var maxp = require('./tables/maxp');
var _name = require('./tables/name');
var os2 = require('./tables/os2');
var post = require('./tables/post');

// File loaders /////////////////////////////////////////////////////////

// Convert a Node.js Buffer to an ArrayBuffer
function toArrayBuffer(buffer) {
    var i,
        arrayBuffer = new ArrayBuffer(buffer.length),
        data = new Uint8Array(arrayBuffer);

    for (i = 0; i < buffer.length; i += 1) {
        data[i] = buffer[i];
    }

    return arrayBuffer;
}

function loadFromFile(path, callback) {
    var fs = require('fs');
    fs.readFile(path, function (err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, toArrayBuffer(buffer));
    });
}

function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function () {
        if (request.status !== 200) {
            return callback('Font could not be loaded: ' + request.statusText);
        }
        return callback(null, request.response);
    };
    request.send();
}

// Public API ///////////////////////////////////////////////////////////

// Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
// If the file could not be parsed (most likely because it contains Postscript outlines)
// we return an empty Font object with the `supported` flag set to `false`.
function parseBuffer(buffer) {
    var font, data, version, numTables, i, p, tag, offset, hmtxOffset, glyfOffset, locaOffset,
        cffOffset, kernOffset, gposOffset, indexToLocFormat, numGlyphs, locaTable,
        shortVersion;
    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.

    font = new _font.Font();
    data = new DataView(buffer, 0);

    version = parse.getFixed(data, 0);
    if (version === 1.0) {
        font.outlinesFormat = 'truetype';
    } else {
        version = parse.getTag(data, 0);
        if (version === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType version ' + version);
        }
    }

    numTables = parse.getUShort(data, 4);

    // Offset into the table records.
    p = 12;
    for (i = 0; i < numTables; i += 1) {
        tag = parse.getTag(data, p);
        offset = parse.getULong(data, p + 8);
        switch (tag) {
        case 'cmap':
            font.tables.cmap = cmap.parse(data, offset);
            font.encoding = new encoding.CmapEncoding(font.tables.cmap);
            if (!font.encoding) {
                font.supported = false;
            }
            break;
        case 'head':
            font.tables.head = head.parse(data, offset);
            font.unitsPerEm = font.tables.head.unitsPerEm;
            indexToLocFormat = font.tables.head.indexToLocFormat;
            break;
        case 'hhea':
            font.tables.hhea = hhea.parse(data, offset);
            font.ascender = font.tables.hhea.ascender;
            font.descender = font.tables.hhea.descender;
            font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
            break;
        case 'hmtx':
            hmtxOffset = offset;
            break;
        case 'maxp':
            font.tables.maxp = maxp.parse(data, offset);
            font.numGlyphs = numGlyphs = font.tables.maxp.numGlyphs;
            break;
        case 'name':
            font.tables.name = _name.parse(data, offset);
            font.familyName = font.tables.name.fontFamily;
            font.styleName = font.tables.name.fontSubfamily;
            break;
        case 'OS/2':
            font.tables.os2 = os2.parse(data, offset);
            break;
        case 'post':
            font.tables.post = post.parse(data, offset);
            font.glyphNames = new encoding.GlyphNames(font.tables.post);
            break;
        case 'glyf':
            glyfOffset = offset;
            break;
        case 'loca':
            locaOffset = offset;
            break;
        case 'CFF ':
            cffOffset = offset;
            break;
        case 'kern':
            kernOffset = offset;
            break;
        case 'GPOS':
            gposOffset = offset;
            break;
        }
        p += 16;
    }

    if (glyfOffset && locaOffset) {
        shortVersion = indexToLocFormat === 0;
        locaTable = loca.parse(data, locaOffset, numGlyphs, shortVersion);
        font.glyphs = glyf.parse(data, glyfOffset, locaTable, font);
        hmtx.parse(data, hmtxOffset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
        encoding.addGlyphNames(font);
    } else if (cffOffset) {
        cff.parse(data, cffOffset, font);
        encoding.addGlyphNames(font);
    } else {
        font.supported = false;
    }

    if (font.supported) {
        if (kernOffset) {
            font.kerningPairs = kern.parse(data, kernOffset);
        } else {
            font.kerningPairs = {};
        }
        if (gposOffset) {
            gpos.parse(data, gposOffset, font);
        }
    }

    return font;
}

// Asynchronously load the font from a URL or a filesystem. When done, call the callback
// with two arguments `(err, font)`. The `err` will be null on success,
// the `font` is a Font object.
//
// We use the node.js callback convention so that
// opentype.js can integrate with frameworks like async.js.
function load(url, callback) {
    var isNode = typeof window === 'undefined';
    var loadFn = isNode ? loadFromFile : loadFromUrl;
    loadFn(url, function (err, arrayBuffer) {
        if (err) {
            return callback(err);
        }
        var font = parseBuffer(arrayBuffer);
        if (!font.supported) {
            return callback('Font is not supported (is this a Postscript font?)');
        }
        return callback(null, font);
    });
}

exports.Font = _font.Font;
exports.Glyph = glyph.Glyph;
exports.Path = path.Path;
exports.parse = parseBuffer;
exports.load = load;

},{"./encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","./font":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/font.js","./glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","./parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","./tables/cff":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js","./tables/cmap":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js","./tables/glyf":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/glyf.js","./tables/gpos":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/gpos.js","./tables/head":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js","./tables/hhea":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js","./tables/hmtx":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js","./tables/kern":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/kern.js","./tables/loca":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/loca.js","./tables/maxp":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js","./tables/name":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js","./tables/os2":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js","./tables/post":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js","fs":false}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js":[function(require,module,exports){
// Parsing utility functions

'use strict';

// Retrieve an unsigned byte from the DataView.
exports.getByte = function getByte(dataView, offset) {
    return dataView.getUint8(offset);
};

exports.getCard8 = exports.getByte;

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
exports.getUShort = function (dataView, offset) {
    return dataView.getUint16(offset, false);
};

exports.getCard16 = exports.getUShort;

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
exports.getShort = function (dataView, offset) {
    return dataView.getInt16(offset, false);
};

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
exports.getULong = function (dataView, offset) {
    return dataView.getUint32(offset, false);
};

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
exports.getFixed = function (dataView, offset) {
    var decimal, fraction;
    decimal = dataView.getInt16(offset, false);
    fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
};

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
exports.getTag = function (dataView, offset) {
    var tag = '', i;
    for (i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }
    return tag;
};

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
exports.getOffset = function (dataView, offset, offSize) {
    var i, v;
    v = 0;
    for (i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }
    return v;
};

// Retrieve a number of bytes from start offset to the end offset from the DataView.
exports.getBytes = function (dataView, startOffset, endOffset) {
    var bytes, i;
    bytes = [];
    for (i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }
    return bytes;
};

// Convert the list of bytes to a string.
exports.bytesToString = function (bytes) {
    var s, i;
    s = '';
    for (i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }
    return s;
};

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function () {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function () {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function () {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function () {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseFixed = function () {
    var v = exports.getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function (count) {
    var offsets = new Array(count),
        dataView = this.data,
        offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = exports.getUShort(dataView, offset);
        offset += 2;
    }
    this.relativeOffset += count * 2;
    return offsets;
};

Parser.prototype.parseString = function (length) {
    var dataView = this.data,
        offset = this.offset + this.relativeOffset,
        string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }
    return string;
};

Parser.prototype.parseTag = function () {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
Parser.prototype.parseLongDateTime = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseFixed = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v / 65536;
};

Parser.prototype.parseVersion = function() {
    var major = exports.getUShort(this.data, this.offset + this.relativeOffset);
    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // This returns the correct number if minor = 0xN000 where N is 0-9
    var minor = exports.getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    return major + minor / 0x1000 / 10;
};

Parser.prototype.skip = function (type, amount) {
    if (amount === undefined) {
        amount = 1;
    }
    this.relativeOffset += typeOffsets[type] * amount;
};

exports.Parser = Parser;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js":[function(require,module,exports){
// Geometric objects

'use strict';

// A bézier path containing a set of path commands similar to a SVG path.
// Paths can be drawn on a context using `draw`.
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

Path.prototype.moveTo = function (x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

Path.prototype.lineTo = function (x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

Path.prototype.close = Path.prototype.closePath = function () {
    this.commands.push({
        type: 'Z'
    });
};

// Add the given path or list of commands to the commands of this path.
Path.prototype.extend = function (pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    }
    Array.prototype.push.apply(this.commands, pathOrCommands);
};

// Draw the path to a 2D context.
Path.prototype.draw = function (ctx) {
    var i, cmd;
    ctx.beginPath();
    for (i = 0; i < this.commands.length; i += 1) {
        cmd = this.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }
    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }
    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

// Convert the Path to a string of path data instructions
// See http://www.w3.org/TR/SVG/paths.html#PathData
// Parameters:
// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
Path.prototype.toPathData = function (decimalPlaces) {
    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }
            s += floatToString(v);
        }
        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }
    return d;
};

// Convert the path to a SVG <path> element, as a string.
// Parameters:
// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
Path.prototype.toSVG = function (decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill & this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }
    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }
    svg += '/>';
    return svg;
};

exports.Path = Path;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js":[function(require,module,exports){
// Table metadata

'use strict';

var check = require('./check');
var encode = require('./types').encode;
var sizeOf = require('./types').sizeOf;

function Table(tableName, fields, options) {
    var i;
    for (i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this[field.name] = field.value;
    }
    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (i = 0; i < optionKeys.length; i += 1) {
            var k = optionKeys[i];
            var v = options[k];
            if (this[k] !== undefined) {
                this[k] = v;
            }
        }
    }
}

Table.prototype.sizeOf = function () {
    var v = 0;
    for (var i = 0; i < this.fields.length; i += 1) {
        var field = this.fields[i];
        var value = this[field.name];
        if (value === undefined) {
            value = field.value;
        }
        if (typeof value.sizeOf === 'function') {
            v += value.sizeOf();
        } else {
            var sizeOfFunction = sizeOf[field.type];
            check.assert(typeof sizeOfFunction === 'function', 'Could not find sizeOf function for field' + field.name);
            v += sizeOfFunction(value);
        }
    }
    return v;
};

Table.prototype.encode = function () {
    return encode.TABLE(this);
};

exports.Table = Table;

},{"./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","./types":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js":[function(require,module,exports){
// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

'use strict';

var encoding = require('../encoding');
var _glyph = require('../glyph');
var parse = require('../parse');
var path = require('../path');
var table = require('../table');

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    var offsets, objects, count, endOffset, offsetSize, objectOffset, pos, i, value;
    offsets = [];
    objects = [];
    count = parse.getCard16(data, start);
    if (count !== 0) {
        offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        pos = start + 3;
        for (i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }
        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }
    for (i = 0; i < offsets.length - 1; i += 1) {
        value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }
        objects.push(value);
    }
    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s, eof, lookup, b, n1, n2;
    s = '';
    eof = 15;
    lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        b = parser.parseByte();
        n1 = b >> 4;
        n2 = b & 15;

        if (n1 === eof) {
            break;
        }
        s += lookup[n1];

        if (n2 === eof) {
            break;
        }
        s += lookup[n2];
    }
    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1, b2, b3, b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }
    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }
    if (b0 === 30) {
        return parseFloatOperand(parser);
    }
    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }
    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }
    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }
    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o, key, values, i, value;
    o = {};
    for (i = 0; i < entries.length; i += 1) {
        key = entries[i][0];
        values = entries[i][1];
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }
        if (o.hasOwnProperty(key)) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }
        o[key] = value;
    }
    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    var parser, entries, operands, op;
    start = start !== undefined ? start : 0;
    parser = new parse.Parser(data, start);
    entries = [];
    operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        op = parser.parseByte();
        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }
            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }
    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = encoding.cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }
    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var i, m, value, newDict;
    newDict = {};
    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (i = 0; i < meta.length; i += 1) {
        m = meta[i];
        value = dict[m.op];
        if (value === undefined) {
            value = m.value !== undefined ? m.value : null;
        }
        if (m.type === 'SID') {
            value = getCFFString(strings, value);
        }
        newDict[m.name] = value;
    }
    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {name: 'fontMatrix', op: 1207, type: ['real', 'real', 'real', 'real', 'real', 'real'], value: [0.001, 0, 0, 0.001, 0, 0]},
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict;
    dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict;
    dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var parser, format, charset, i, sid, count;
    parser = new parse.Parser(data, start);
    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    charset = ['.notdef'];

    format = parser.parseCard8();
    if (format === 0) {
        for (i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var enc, parser, format, nCodes, i, code, nRanges, first, nLeft, j;
    enc = {};
    parser = new parse.Parser(data, start);
    format = parser.parseCard8();
    if (format === 0) {
        nCodes = parser.parseCard8();
        for (i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        nRanges = parser.parseCard8();
        code = 1;
        for (i = 0; i < nRanges; i += 1) {
            first = parser.parseCard8();
            nLeft = parser.parseCard8();
            for (j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }
    return new encoding.CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(code, font, index) {
    var p, glyph, stack, nStems, haveWidth, width, x, y, c1x, c1y, c2x, c2y, v;
    p = new path.Path();
    stack = [];
    nStems = 0;
    haveWidth = false;
    width = font.defaultWidthX;
    x = y = 0;

    function parseStems() {
        var hasWidthArg;
        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + font.nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse(code) {
        var i, b1, b2, b3, b4, codeIndex, subrCode;
        i = 0;
        while (i < code.length) {
            v = code[i];
            i += 1;
            switch (v) {
            case 1: // hstem
                parseStems();
                break;
            case 3: // vstem
                parseStems();
                break;
            case 4: // vmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                p.moveTo(x, y);
                break;
            case 5: // rlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 6: // hlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 7: // vlineto
                while (stack.length > 0) {
                    y += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    x += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 8: // rrcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 10: // callsubr
                codeIndex = stack.pop() + font.subrsBias;
                subrCode = font.subrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }
                break;
            case 11: // return
                return;
            case 12: // escape
                v = code[i];
                i += 1;
                break;
            case 14: // endchar
                if (stack.length > 0 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                p.closePath();
                break;
            case 18: // hstemhm
                parseStems();
                break;
            case 19: // hintmask
            case 20: // cntrmask
                parseStems();
                i += (nStems + 7) >> 3;
                break;
            case 21: // rmoveto
                if (stack.length > 2 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                x += stack.pop();
                p.moveTo(x, y);
                break;
            case 22: // hmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                x += stack.pop();
                p.moveTo(x, y);
                break;
            case 23: // vstemhm
                parseStems();
                break;
            case 24: // rcurveline
                while (stack.length > 2) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                x += stack.shift();
                y += stack.shift();
                p.lineTo(x, y);
                break;
            case 25: // rlinecurve
                while (stack.length > 6) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
                break;
            case 26: // vvcurveto
                if (stack.length % 2) {
                    x += stack.shift();
                }
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x;
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 27: // hhcurveto
                if (stack.length % 2) {
                    y += stack.shift();
                }
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y;
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 28: // shortint
                b1 = code[i];
                b2 = code[i + 1];
                stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                i += 2;
                break;
            case 29: // callgsubr
                codeIndex = stack.pop() + font.gsubrsBias;
                subrCode = font.gsubrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }
                break;
            case 30: // vhcurveto
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 31: // hvcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            default:
                if (v < 32) {
                    console.log('Glyph ' + index + ': unknown operator ' + v);
                } else if (v < 247) {
                    stack.push(v - 139);
                } else if (v < 251) {
                    b1 = code[i];
                    i += 1;
                    stack.push((v - 247) * 256 + b1 + 108);
                } else if (v < 255) {
                    b1 = code[i];
                    i += 1;
                    stack.push(-(v - 251) * 256 - b1 - 108);
                } else {
                    b1 = code[i];
                    b2 = code[i + 1];
                    b3 = code[i + 2];
                    b4 = code[i + 3];
                    i += 4;
                    stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                }
            }
        }
    }

    parse(code);
    glyph = new _glyph.Glyph({font: font, index: index});
    glyph.path = p;
    glyph.advanceWidth = width;
    return glyph;
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }
    return bias;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    var header, nameIndex, topDictIndex, stringIndex, globalSubrIndex, topDict, privateDictOffset, privateDict,
        subrOffset, subrIndex, charString, charStringsIndex, charset, i;
    font.tables.cff = {};
    header = parseCFFHeader(data, start);
    nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);
    topDict = parseCFFTopDict(topDictData, stringIndex.objects);
    font.tables.cff.topDict = topDict;

    privateDictOffset = start + topDict['private'][1];
    privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict['private'][0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        subrOffset = privateDictOffset + privateDict.subrs;
        subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) { // Standard encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) { // Expert encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }
    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = [];
    for (i = 0; i < font.nGlyphs; i += 1) {
        charString = charStringsIndex.objects[i];
        font.glyphs.push(parseCFFCharstring(charString, font, i));
    }
}


// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var i, sid;
    // Is the string in the CFF standard strings?
    i = encoding.cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }
    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + encoding.cffStandardStrings.length;
    } else {
        sid = encoding.cffStandardStrings.length + strings.length;
        strings.push(s);
    }
    return sid;
}

function makeHeader() {
    return new table.Table('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Table('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }
    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {}, i, entry, value;
    for (i = 0; i < meta.length; i += 1) {
        entry = meta[i];
        value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }
            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }
    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Table('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Table('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Table('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }
    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Table('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Table('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }
    return t;
}

function glyphToOps(glyph) {
    var ops = [], path = glyph.path, x, y, i, cmd, dx, dy, dx1, dy1, dx2, dy2;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    x = 0;
    y = 0;
    for (i = 0; i < path.commands.length; i += 1) {
        cmd = path.commands[i];
        if (cmd.type === 'M') {
            dx = cmd.x - x;
            dy = cmd.y - y;
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'L') {
            dx = cmd.x - x;
            dy = cmd.y - y;
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'Q') {
            // FIXME: Add support for quad curves
            throw new Error('Writing quad curves is currently not supported.');
        } else if (cmd.type === 'C') {
            dx1 = cmd.x1 - x;
            dy1 = cmd.y1 - y;
            dx2 = cmd.x2 - cmd.x1;
            dy2 = cmd.y2 - cmd.y1;
            dx = cmd.x - cmd.x2;
            dy = cmd.y - cmd.y2;
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'Z') {
            // Contours are closed automatically.
        }
    }
    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Table('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }
    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Table('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makePrivateDictIndex(privateDict) {
    var t = new table.Table('Private DICT INDEX', [
        {name: 'privateDicts', type: 'INDEX', value: []}
    ]);
    t.privateDicts = [{name: 'privateDict_0', type: 'TABLE', value: privateDict}];
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'TABLE'},
        {name: 'nameIndex', type: 'TABLE'},
        {name: 'topDictIndex', type: 'TABLE'},
        {name: 'stringIndex', type: 'TABLE'},
        {name: 'globalSubrIndex', type: 'TABLE'},
        {name: 'charsets', type: 'TABLE'},
        {name: 'charStringsIndex', type: 'TABLE'},
        {name: 'privateDictIndex', type: 'TABLE'}
    ]);

    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyphNames.push(glyphs[i].name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    var privateDict = makePrivateDict(privateAttrs, strings);
    t.privateDictIndex = makePrivateDictIndex(privateDict);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;
    attrs.encoding = 0; // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

exports.parse = parseCFFTable;
exports.make = makeCFFTable;

},{"../encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","../glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js":[function(require,module,exports){
// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

'use strict';

var check = require('../check');
var parse = require('../parse');
var table = require('../table');

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var version, numTables, offset, platformId, encodingId, format, segCount,
        endCountParser, startCountParser, idDeltaParser, idRangeOffsetParser, glyphIndexOffset,
        endCount, startCount, i, c, idDelta, idRangeOffset, p, glyphIndex;
    var cmap = {};
    cmap.version = version = parse.getUShort(data, start);
    check.argument(version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numtables = numTables = parse.getUShort(data, start + 2);
    offset = -1;
    for (i = 0; i < numTables; i += 1) {
        platformId = parse.getUShort(data, start + 4 + (i * 8));
        encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 1 || encodingId === 0)) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }
    if (offset === -1) {
        // There is no cmap table in the font that we support, so return null.
        // This font will be marked as unsupported.
        return null;
    }

    p = new parse.Parser(data, start + offset);
    cmap.format = format = p.parseUShort();
    check.argument(format === 4, 'Only format 4 cmap tables are supported.');
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();
    // segCount is stored x 2.
    cmap.segCount = segCount = p.parseUShort() >> 1;
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};

    endCountParser = new parse.Parser(data, start + offset + 14);
    startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (i = 0; i < segCount - 1; i += 1) {
        endCount = endCountParser.parseUShort();
        startCount = startCountParser.parseUShort();
        idDelta = idDeltaParser.parseShort();
        idRangeOffset = idRangeOffsetParser.parseUShort();
        for (c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);
                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;
                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }
            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

function makeCmapTable(glyphs) {
    var i, j, glyph;
    var t = new table.Table('cmap', [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: 1},
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: 12},
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        for (j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }
    }
    addTerminatorSegment(t);

    var segCount;
    segCount = t.segments.length;
    t.segCountX2 = segCount * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

     // Set up parallel segment arrays.
    var endCounts = [],
        startCounts = [],
        idDeltas = [],
        idRangeOffsets = [],
        glyphIds = [];

    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];
        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
        if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
        }
    }
    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;
    return t;
}

exports.parse = parseCmapTable;
exports.make = makeCmapTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/glyf.js":[function(require,module,exports){
// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

'use strict';

var check = require('../check');
var _glyph = require('../glyph');
var parse = require('../parse');
var path = require('../path');

// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }
        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }
    return v;
}

// Parse a TrueType glyph.
function parseGlyph(data, start, index, font) {
    var p, glyph, flag, i, j, flags,
        endPointIndices, numberOfCoordinates, repeatCount, points, point, px, py,
        component, moreComponents;
    p = new parse.Parser(data, start);
    glyph = new _glyph.Glyph({font: font, index: index});
    glyph.numberOfContours = p.parseShort();
    glyph.xMin = p.parseShort();
    glyph.yMin = p.parseShort();
    glyph.xMax = p.parseShort();
    glyph.yMax = p.parseShort();
    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        endPointIndices = glyph.endPointIndices = [];
        for (i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (i = 0; i < glyph.instructionLength; i += 1) {
            glyph.instructions.push(p.parseByte());
        }

        numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (i = 0; i < numberOfCoordinates; i += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                repeatCount = p.parseByte();
                for (j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i += 1;
                }
            }
        }
        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            points = [];
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;
                    points.push(point);
                }
                px = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                py = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }
            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            component = {
                glyphIndex: p.parseUShort(),
                 xScale: 1,
                 scale01: 0,
                 scale10: 0,
                 yScale: 1,
                 dx: 0,
                 dy: 0
             };
            if ((flags & 1) > 0) {
                // The arguments are words
                component.dx = p.parseShort();
                component.dy = p.parseShort();
            } else {
                // The arguments are bytes
                component.dx = p.parseChar();
                component.dy = p.parseChar();
            }
            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
    }
    return glyph;
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints, i, pt, newPt;
    newPoints = [];
    for (i = 0; i < points.length; i += 1) {
        pt = points[i];
        newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }
    return newPoints;
}


function getContours(points) {
    var contours, currentContour, i, pt;
    contours = [];
    currentContour = [];
    for (i = 0; i < points.length; i += 1) {
        pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p, contours, i, realFirstPoint, j, contour, pt, firstPt,
        prevPt, midPt, curvePt, lastPt;
    p = new path.Path();
    if (!points) {
        return p;
    }
    contours = getContours(points);
    for (i = 0; i < contours.length; i += 1) {
        contour = contours[i];
        firstPt = contour[0];
        lastPt = contour[contour.length - 1];
        if (firstPt.onCurve) {
            curvePt = null;
            // The first point will be consumed by the moveTo command,
            // so skip it in the loop.
            realFirstPoint = true;
        } else {
            if (lastPt.onCurve) {
                // If the first point is off-curve and the last point is on-curve,
                // start at the last point.
                firstPt = lastPt;
            } else {
                // If both first and last points are off-curve, start at their middle.
                firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };
            }
            curvePt = firstPt;
            // The first point is synthesized, so don't skip the real first point.
            realFirstPoint = false;
        }
        p.moveTo(firstPt.x, firstPt.y);

        for (j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {
            pt = contour[j];
            prevPt = j === 0 ? firstPt : contour[j - 1];
            if (prevPt.onCurve && pt.onCurve) {
                // This is a straight line.
                p.lineTo(pt.x, pt.y);
            } else if (prevPt.onCurve && !pt.onCurve) {
                curvePt = pt;
            } else if (!prevPt.onCurve && !pt.onCurve) {
                midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };
                p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);
                curvePt = pt;
            } else if (!prevPt.onCurve && pt.onCurve) {
                // Previous point off-curve, this point on-curve.
                p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                curvePt = null;
            } else {
                throw new Error('Invalid state.');
            }
        }
        if (firstPt !== lastPt) {
            // Connect the last and first points
            if (curvePt) {
                p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
            } else {
                p.lineTo(firstPt.x, firstPt.y);
            }
        }
    }
    p.closePath();
    return p;
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs, i, j, offset, nextOffset, glyph,
        component, componentGlyph, transformedPoints;
    glyphs = [];
    // The last element of the loca table is invalid.
    for (i = 0; i < loca.length - 1; i += 1) {
        offset = loca[i];
        nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(parseGlyph(data, start + offset, i, font));
        } else {
            glyphs.push(new _glyph.Glyph({font: font, index: i}));
        }
    }
    // Go over the glyphs again, resolving the composite glyphs.
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        if (glyph.isComposite) {
            for (j = 0; j < glyph.components.length; j += 1) {
                component = glyph.components[j];
                componentGlyph = glyphs[component.glyphIndex];
                if (componentGlyph.points) {
                    transformedPoints = transformPoints(componentGlyph.points, component);
                    glyph.points = glyph.points.concat(transformedPoints);
                }
            }
        }
        glyph.path = getPath(glyph.points);
    }
    return glyphs;
}

exports.parse = parseGlyfTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/gpos.js":[function(require,module,exports){
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

'use strict';

var check = require('../check');
var parse = require('../parse');

// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.
// These lists are unused by now, this function is just the basis for a real parsing.
function parseTaggedListTable(data, start) {
    var p = new parse.Parser(data, start),
        n = p.parseUShort(),
        list = [];
    for (var i = 0; i < n; i++) {
        list[p.parseTag()] = { offset: p.parseUShort() };
    }
    return list;
}

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// Format 1 is a simple list of glyph ids,
// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
function parseCoverageTable(data, start) {
    var p = new parse.Parser(data, start),
        format = p.parseUShort(),
        count =  p.parseUShort();
    if (format === 1) {
        return p.parseUShortList(count);
    }
    else if (format === 2) {
        var i, begin, end, index, coverage = [];
        for (; count--;) {
            begin = p.parseUShort();
            end = p.parseUShort();
            index = p.parseUShort();
            for (i = begin; i <= end; i++) {
                coverage[index++] = i;
            }
        }
        return coverage;
    }
}

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// Returns a function that gets a class value from a glyph ID.
function parseClassDefTable(data, start) {
    var p = new parse.Parser(data, start),
        format = p.parseUShort();
    if (format === 1) {
        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
        var startGlyph = p.parseUShort(),
            glyphCount = p.parseUShort(),
            classes = p.parseUShortList(glyphCount);
        return function(glyphID) {
            return classes[glyphID - startGlyph] || 0;
        };
    }
    else if (format === 2) {
        // Format 2 defines multiple groups of glyph indices that belong to the same class.
        var rangeCount = p.parseUShort(),
            startGlyphs = [],
            endGlyphs = [],
            classValues = [];
        for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
        }
        return function(glyphID) {
            var l, c, r;
            l = 0;
            r = startGlyphs.length - 1;
            while (l < r) {
                c = (l + r + 1) >> 1;
                if (glyphID < startGlyphs[c]) {
                    r = c - 1;
                } else {
                    l = c;
                }
            }
            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
                return classValues[l] || 0;
            }
            return 0;
        };
    }
}

// Parse a pair adjustment positioning subtable, format 1 or format 2
// The subtable is returned in the form of a lookup function.
function parsePairPosSubTable(data, start) {
    var p = new parse.Parser(data, start);
    var format, coverageOffset, coverage, valueFormat1, valueFormat2,
        sharedPairSets, firstGlyph, secondGlyph, value1, value2;
    // This part is common to format 1 and format 2 subtables
    format = p.parseUShort();
    coverageOffset = p.parseUShort();
    coverage = parseCoverageTable(data, start+coverageOffset);
    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
    // Only valueFormat1=4 and valueFormat2=0 is supported.
    valueFormat1 = p.parseUShort();
    valueFormat2 = p.parseUShort();
    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;
    sharedPairSets = {};
    if (format === 1) {
        // Pair Positioning Adjustment: Format 1
        var pairSetCount, pairSetOffsets, pairSetOffset, sharedPairSet, pairValueCount, pairSet;
        pairSetCount = p.parseUShort();
        pairSet = [];
        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
        pairSetOffsets = p.parseOffset16List(pairSetCount);
        for (firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            pairSetOffset = pairSetOffsets[firstGlyph];
            sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
                // Parse a pairset table in a pair adjustment subtable format 1
                sharedPairSet = {};
                p.relativeOffset = pairSetOffset;
                pairValueCount = p.parseUShort();
                for (; pairValueCount--;) {
                    secondGlyph = p.parseUShort();
                    if (valueFormat1) value1 = p.parseShort();
                    if (valueFormat2) value2 = p.parseShort();
                    // We only support valueFormat1 = 4 and valueFormat2 = 0,
                    // so value1 is the XAdvance and value2 is empty.
                    sharedPairSet[secondGlyph] = value1;
                }
            }
            pairSet[coverage[firstGlyph]] = sharedPairSet;
        }
        return function(leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs) return pairs[rightGlyph];
        };
    }
    else if (format === 2) {
        // Pair Positioning Adjustment: Format 2
        var classDef1Offset, classDef2Offset, class1Count, class2Count, i, j,
            getClass1, getClass2, kerningMatrix, kerningRow, covered;
        classDef1Offset = p.parseUShort();
        classDef2Offset = p.parseUShort();
        class1Count = p.parseUShort();
        class2Count = p.parseUShort();
        getClass1 = parseClassDefTable(data, start+classDef1Offset);
        getClass2 = parseClassDefTable(data, start+classDef2Offset);

        // Parse kerning values by class pair.
        kerningMatrix = [];
        for (i = 0; i < class1Count; i++) {
            kerningRow = kerningMatrix[i] = [];
            for (j = 0; j < class2Count; j++) {
                if (valueFormat1) value1 = p.parseShort();
                if (valueFormat2) value2 = p.parseShort();
                // We only support valueFormat1 = 4 and valueFormat2 = 0,
                // so value1 is the XAdvance and value2 is empty.
                kerningRow[j] = value1;
            }
        }

        // Convert coverage list to a hash
        covered = {};
        for(i = 0; i < coverage.length; i++) covered[coverage[i]] = 1;

        // Get the kerning value for a specific glyph pair.
        return function(leftGlyph, rightGlyph) {
            if (!covered[leftGlyph]) return null;
            var class1 = getClass1(leftGlyph),
                class2 = getClass2(rightGlyph),
                kerningRow = kerningMatrix[class1];
            return kerningRow ? kerningRow[class2] : null;
        };
    }
}

// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
function parseLookupTable(data, start) {
    var p = new parse.Parser(data, start);
    var table, lookupType, lookupFlag, useMarkFilteringSet, subTableCount, subTableOffsets, subtables, i;
    lookupType = p.parseUShort();
    lookupFlag = p.parseUShort();
    useMarkFilteringSet = lookupFlag & 0x10;
    subTableCount = p.parseUShort();
    subTableOffsets = p.parseOffset16List(subTableCount);
    table = {
        lookupType: lookupType,
        lookupFlag: lookupFlag,
        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
    };
    // LookupType 2, Pair adjustment
    if (lookupType === 2) {
        subtables = [];
        for (i = 0; i < subTableCount; i++) {
            subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));
        }
        // Return a function which finds the kerning values in the subtables.
        table.getKerningValue = function(leftGlyph, rightGlyph) {
            for (var i = subtables.length; i--;) {
                var value = subtables[i](leftGlyph, rightGlyph);
                if (value !== undefined) return value;
            }
            return 0;
        };
    }
    return table;
}

// Parse the `GPOS` table which contains, among other things, kerning pairs.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
function parseGposTable(data, start, font) {
    var p, tableVersion, lookupListOffset, scriptList, i, featureList, lookupCount,
        lookupTableOffsets, lookupListAbsoluteOffset, table;

    p = new parse.Parser(data, start);
    tableVersion = p.parseFixed();
    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');

    // ScriptList and FeatureList - ignored for now
    scriptList = parseTaggedListTable(data, start+p.parseUShort());
    // 'kern' is the feature we are looking for.
    featureList = parseTaggedListTable(data, start+p.parseUShort());

    // LookupList
    lookupListOffset = p.parseUShort();
    p.relativeOffset = lookupListOffset;
    lookupCount = p.parseUShort();
    lookupTableOffsets = p.parseOffset16List(lookupCount);
    lookupListAbsoluteOffset = start + lookupListOffset;
    for (i = 0; i < lookupCount; i++) {
        table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;
    }
}

exports.parse = parseGposTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js":[function(require,module,exports){
// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

'use strict';

var check = require('../check');
var parse = require('../parse');
var table = require('../table');

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {},
        p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();     // 50
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: 0},
        {name: 'modified', type: 'LONGDATETIME', value: 0},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

exports.parse = parseHeadTable;
exports.make = makeHeadTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js":[function(require,module,exports){
// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    var hhea = {},
        p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseHheaTable;
exports.make = makeHheaTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js":[function(require,module,exports){
// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var p, i, glyph, advanceWidth, leftSideBearing;
    p = new parse.Parser(data, start);
    for (i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }
        glyph = glyphs[i];
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }
    return t;
}

exports.parse = parseHmtxTable;
exports.make = makeHmtxTable;




},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/kern.js":[function(require,module,exports){
// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

'use strict';

var check = require('../check');
var parse = require('../parse');

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var pairs, p, tableVersion, subTableVersion, nPairs,
        i, leftIndex, rightIndex, value;
    pairs = {};
    p = new parse.Parser(data, start);
    tableVersion = p.parseUShort();
    check.argument(tableVersion === 0, 'Unsupported kern table version.');
    // Skip nTables.
    p.skip('uShort', 1);
    subTableVersion = p.parseUShort();
    check.argument(subTableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subTableLength, subTableCoverage
    p.skip('uShort', 2);
    nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (i = 0; i < nPairs; i += 1) {
        leftIndex = p.parseUShort();
        rightIndex = p.parseUShort();
        value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

exports.parse = parseKernTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/loca.js":[function(require,module,exports){
// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

'use strict';

var parse = require('../parse');

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p, parseFn, glyphOffsets, glyphOffset, i;
    p = new parse.Parser(data, start);
    parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    glyphOffsets = [];
    for (i = 0; i < numGlyphs + 1; i += 1) {
        glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }
        glyphOffsets.push(glyphOffset);
    }
    return glyphOffsets;
}

exports.parse = parseLocaTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js":[function(require,module,exports){
// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    var maxp = {},
        p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }
    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

exports.parse = parseMaxpTable;
exports.make = makeMaxpTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js":[function(require,module,exports){
// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

'use strict';

var encode = require('../types').encode;
var parse = require('../parse');
var table = require('../table');

// NameIDs for the name table.
var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'licence',                // 13
    'licenceURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

// Parse the naming `name` table
// Only Windows Unicode English names are supported.
// Format 1 additional fields are not supported
function parseNameTable(data, start) {
    var name = {},
        p = new parse.Parser(data, start);
    name.format = p.parseUShort();
    var count = p.parseUShort(),
        stringOffset = p.offset + p.parseUShort();
    var platformID, encodingID, languageID, nameID, property, byteLength,
        offset, str, i, j, codePoints;
    var unknownCount = 0;
    for(i = 0; i < count; i++) {
        platformID = p.parseUShort();
        encodingID = p.parseUShort();
        languageID = p.parseUShort();
        nameID = p.parseUShort();
        property = nameTableNames[nameID];
        byteLength = p.parseUShort();
        offset = p.parseUShort();
        // platformID - encodingID - languageID standard combinations :
        // 1 - 0 - 0 : Macintosh, Roman, English
        // 3 - 1 - 0x409 : Windows, Unicode BMP (UCS-2), en-US
        if (platformID === 3 && encodingID === 1 && languageID === 0x409) {
            codePoints = [];
            var length = byteLength/2;
            for(j = 0; j < length; j++, offset += 2) {
                codePoints[j] = parse.getShort(data, stringOffset+offset);
            }
            str = String.fromCharCode.apply(null, codePoints);
            if (property) {
                name[property] = str;
            }
            else {
                unknownCount++;
                name['unknown'+unknownCount] = str;
            }
        }

    }
    if (name.format === 1) {
        name.langTagCount = p.parseUShort();
    }
    return name;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Table('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

function addMacintoshNameRecord(t, recordID, s, offset) {
    // Macintosh, Roman, English
    var stringBytes = encode.STRING(s);
    t.records.push(makeNameRecord(1, 0, 0, recordID, stringBytes.length, offset));
    t.strings.push(stringBytes);
    offset += stringBytes.length;
    return offset;
}

function addWindowsNameRecord(t, recordID, s, offset) {
    // Windows, Unicode BMP (UCS-2), US English
    var utf16Bytes = encode.UTF16(s);
    t.records.push(makeNameRecord(3, 1, 0x0409, recordID, utf16Bytes.length, offset));
    t.strings.push(utf16Bytes);
    offset += utf16Bytes.length;
    return offset;
}

function makeNameTable(options) {
    var i, s;
    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: 0},
        {name: 'stringOffset', type: 'USHORT', value: 0}
    ]);
    t.records = [];
    t.strings = [];
    var offset = 0;
    // Add Macintosh records first
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addMacintoshNameRecord(t, i, s, offset);
        }
    }
    // Then add Windows records
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addWindowsNameRecord(t, i, s, offset);
        }
    }

    t.count = t.records.length;
    t.stringOffset = 6 + t.count * 12;
    for (i = 0; i < t.records.length; i += 1) {
        t.fields.push({name: 'record_' + i, type: 'TABLE', value: t.records[i]});
    }
    for (i = 0; i < t.strings.length; i += 1) {
        t.fields.push({name: 'string_' + i, type: 'LITERAL', value: t.strings[i]});
    }
    return t;
}

exports.parse = parseNameTable;
exports.make = makeNameTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js","../types":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js":[function(require,module,exports){
// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {},
        p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }
    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }
    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }
    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 0},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 0},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 0},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 0},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 0},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 0},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseOS2Table;
exports.make = makeOS2Table;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js":[function(require,module,exports){
// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

'use strict';

var encoding = require('../encoding');
var parse = require('../parse');
var table = require('../table');

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {},
        p = new parse.Parser(data, start),
        i, nameLength;
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
    case 1:
        post.names = encoding.standardNames.slice();
        break;
    case 2:
        post.numberOfGlyphs = p.parseUShort();
        post.glyphNameIndex = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.glyphNameIndex[i] = p.parseUShort();
        }
        post.names = [];
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] >= encoding.standardNames.length) {
                nameLength = p.parseChar();
                post.names.push(p.parseString(nameLength));
            }
        }
        break;
    case 2.5:
        post.numberOfGlyphs = p.parseUShort();
        post.offset = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.offset[i] = p.parseChar();
        }
        break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

exports.parse = parsePostTable;
exports.make = makePostTable;

},{"../encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/sfnt.js":[function(require,module,exports){
// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

'use strict';

var check = require('../check');
var table = require('../table');

var cmap = require('./cmap');
var cff = require('./cff');
var head = require('./head');
var hhea = require('./hhea');
var hmtx = require('./hmtx');
var maxp = require('./maxp');
var _name = require('./name');
var os2 = require('./os2');
var post = require('./post');

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }
    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }
    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Table('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'TABLE', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'TABLE', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function (r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs[glyphIndex];
            return glyph.getMetrics();
        }
    }
    return notFoundMetrics;
}

// Return the smallest and largest unicode values of the characters in this font.
// For most fonts the smallest value would be 20 (space).
function charCodeBounds(glyphs) {
    var minCode, maxCode;
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        if (glyph.unicode >= 20) {
            if (minCode === undefined) {
                minCode = glyph.unicode;
            } else if (glyph.unicode < minCode) {
                minCode = glyph.unicode;
            }
            if (maxCode === undefined) {
                maxCode = glyph.unicode;
            } else if (glyph.unicode > maxCode) {
                maxCode = glyph.unicode;
            }
        }
    }
    return [minCode, maxCode];
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }
    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs[i];
        // Skip non-important characters.
        if (glyph.name === '.notdef') continue;
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }
    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = globals.yMax;
    globals.descender = globals.yMin;

    var headTable = head.make({
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax
    });

    var hheaTable = hhea.make({
        // Adding a little here makes OS X Quick Look happy
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var codeBounds = charCodeBounds(font.glyphs);
    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: 500, // Medium FIXME Make this configurable
        usWidthClass: 5, // Medium (normal) FIXME Make this configurable
        usFirstCharIndex: codeBounds[0],
        usLastCharIndex: codeBounds[1],
        ulUnicodeRange1: 0x00000001, // Basic Latin
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.ascender,
        usWinDescent: -globals.descender,
        ulCodePageRange1: 0x00000001, // Basic Latin
        sxHeight: metricsForChar(font, 'xyvw', {yMax: 0}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });


    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var fullName = font.familyName + ' ' + font.styleName;
    var postScriptName = font.familyName.replace(/\s/g, '') + '-' + font.styleName;
    var nameTable = _name.make({
        copyright: font.copyright,
        fontFamily: font.familyName,
        fontSubfamily: font.styleName,
        uniqueID: font.manufacturer + ':' + fullName,
        fullName: fullName,
        version: font.version,
        postScriptName: postScriptName,
        trademark: font.trademark,
        manufacturer: font.manufacturer,
        designer: font.designer,
        description: font.description,
        manufacturerURL: font.manufacturerURL,
        designerURL: font.designerURL,
        license: font.license,
        licenseURL: font.licenseURL,
        preferredFamily: font.familyName,
        preferredSubfamily: font.styleName
    });
    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.version,
        fullName: fullName,
        familyName: font.familyName,
        weightName: font.styleName,
        postScriptName: postScriptName
    });
    // Order the tables according to the the OpenType specification 1.4.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];

    var sfntTable = makeSfntTable(tables);

    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    headTable.checkSumAdjustment = 0xB1B0AFBA - checkSum;

    // Build the font again, now with the proper checkSum.
    sfntTable = makeSfntTable(tables);

    return sfntTable;
}

exports.computeCheckSum = computeCheckSum;
exports.make = makeSfntTable;
exports.fontToTable = fontToSfntTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js","./cff":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js","./cmap":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js","./head":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js","./hhea":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js","./hmtx":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js","./maxp":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js","./name":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js","./os2":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js","./post":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js":[function(require,module,exports){
// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

/* global WeakMap */

'use strict';

var check = require('./check');

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

var decode = {};
var encode = {};
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function () {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

// Convert an 8-bit unsigned integer to a list of 1 byte.
encode.BYTE = function (v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};

sizeOf.BYTE = constant(1);

// Convert a 8-bit signed integer to a list of 1 byte.
encode.CHAR = function (v) {
    return [v.charCodeAt(0)];
};

sizeOf.BYTE = constant(1);

// Convert an ASCII string to a list of bytes.
encode.CHARARRAY = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(v.charCodeAt(i));
    }
    return b;
};

sizeOf.CHARARRAY = function (v) {
    return v.length;
};

// Convert a 16-bit unsigned integer to a list of 2 bytes.
encode.USHORT = function (v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.USHORT = constant(2);

// Convert a 16-bit signed integer to a list of 2 bytes.
encode.SHORT = function (v) {
    // Two's complement
    if (v >= LIMIT16){
        v = - ( 2 * LIMIT16 - v);
    }
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.SHORT = constant(2);

// Convert a 24-bit unsigned integer to a list of 3 bytes.
encode.UINT24 = function (v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.UINT24 = constant(3);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.ULONG = function (v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.ULONG = constant(4);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.LONG = function (v) {
     // Two's complement
    if (v >= LIMIT32){
        v = - ( 2 * LIMIT32 - v);
    }
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;


// FIXME Implement LONGDATETIME
encode.LONGDATETIME = function () {
    return [0, 0, 0, 0, 0, 0, 0, 0];
};

sizeOf.LONGDATETIME = constant(8);

// Convert a 4-char tag to a list of 4 bytes.
encode.TAG = function (v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
encode.NUMBER = function (v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131 ) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

sizeOf.NUMBER = function (v) {
    return encode.NUMBER(v).length;
};

// Convert a signed number between -32768 and +32767 to a three-byte value.
// This ensures we always use three bytes, but is not the most compact format.
encode.NUMBER16 = function (v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER16 = constant(2);

// Convert a signed number between -(2^31) and +(2^31-1) to a four-byte value.
// This is useful if you want to be sure you always use four bytes,
// at the expense of wasting a few bytes for smaller numbers.
encode.NUMBER32 = function (v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER32 = constant(4);

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

// Convert a ASCII string to a list of UTF16 bytes.
encode.UTF16 = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(0);
        b.push(v.charCodeAt(i));
    }
    return b;
};

sizeOf.UTF16 = function (v) {
    return v.length * 2;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
encode.INDEX = function (l) {
    var offSize, offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
        dataSize, i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offets, then again to encode the offsets using the fitting data type.
    offset = 1; // First offset is always 1.
    offsets = [offset];
    data = [];
    dataSize = 0;
    for (i = 0; i < l.length; i += 1) {
        v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        dataSize += v.length;
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    encodedOffsets = [];
    offSize = (1 + Math.floor(Math.log(dataSize)/Math.log(2)) / 8) | 0;
    offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (i = 0; i < offsets.length; i += 1) {
        encodedOffset = offsetEncoder(offsets[i]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }
    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

sizeOf.INDEX = function (v) {
    return encode.INDEX(v).length;
};

// Convert an object to a CFF DICT structure.
// The keys should be numeric.
// The values should be objects containing name / type / value.
encode.DICT = function (m) {
    var d = [],
        keys = Object.keys(m),
        length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

sizeOf.DICT = function (m) {
    return encode.DICT(m).length;
};

encode.OPERATOR = function (v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

encode.OPERAND = function (v, type) {
    var d, i;
    d = [];
    if (Array.isArray(type)) {
        for (i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else {
            // FIXME Add support for booleans
            d = d.concat(encode.NUMBER(v));
        }
    }
    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof WeakMap === 'function' && new WeakMap();
// Convert a list of CharString operations to bytes.
encode.CHARSTRING = function (ops) {
    if ( wmm && wmm.has( ops ) ) {
        return wmm.get( ops );
    }

    var d = [],
        length = ops.length,
        op,
        i;

    for (i = 0; i < length; i += 1) {
        op = ops[i];
        d = d.concat( encode[op.type](op.value) );
    }

    if ( wmm ) {
        wmm.set( ops, d );
    }

    return d;
};

sizeOf.CHARSTRING = function (ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

// Convert an object containing name / type / value to bytes.
encode.OBJECT = function (v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

// Convert a table object to bytes.
// A table contains a list of fields containing the metadata (name, type and default value).
// The table itself has the field values set as attributes.
encode.TABLE = function (table) {
    var d = [],
        length = table.fields.length,
        i;

    for (i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type);
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }
        var bytes = encodingFunction(value);
        d = d.concat(bytes);
    }
    return d;
};

// Merge in a list of bytes.
encode.LITERAL = function (v) {
    return v;
};

sizeOf.LITERAL = function (v) {
    return v.length;
};


exports.decode = decode;
exports.encode = encode;
exports.sizeOf = sizeOf;

},{"./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js":[function(require,module,exports){
(function (process){
/*!
 * Paper.js v0.9.21 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Wed Dec 3 14:47:05 2014 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

		  var noCanvas =
			  typeof process === 'object' ||
			  ( typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope );

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props, exclude) {
		for (var key in props)
			if (props.hasOwnProperty(key) && (!exclude || !exclude[key]))
				obj[key] = props[key];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			ctor.prototype = create(this.prototype);
			ctor.base = base;
			define(ctor.prototype, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			return arguments.length ? this.inject.apply(ctor, arguments) : ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		set: function(props) {
			return set(this, props);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function() {
				for (var i = 0, l = arguments.length; i < l; i++)
					if (arguments[i] !== undefined)
						return arguments[i];
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

if (!Array.isArray) {
	Array.isArray = function(obj) {
		return Object.prototype.toString.call(obj) === '[object Array]';
	};
}

if (!noCanvas && !document.head) {
	document.head = document.getElementsByTagName('head')[0];
}

Base.inject({
	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	_set: function(props, exclude, dontCheck) {
		if (props && (dontCheck || Base.isPlainObject(props))) {
			var orig = props._filtering || props;
			for (var key in orig) {
				if (orig.hasOwnProperty(key) && !(exclude && exclude[key])) {
					var value = props[key];
					if (value !== undefined)
						this[key] = value;
				}
			}
			return true;
		}
	},

	statics: {

		exports: {
			enumerable: true
		},

		extend: function extend() {
			var res = extend.base.apply(this, arguments),
				name = res.prototype._class;
			if (name && !Base.exports[name])
				Base.exports[name] = res;
			return res;
		},

		equals: function(obj1, obj2) {
			function checkKeys(o1, o2) {
				for (var i in o1)
					if (o1.hasOwnProperty(i) && !o2.hasOwnProperty(i))
						return false;
				return true;
			}
			if (obj1 === obj2)
				return true;
			if (obj1 && obj1.equals)
				return obj1.equals(obj2);
			if (obj2 && obj2.equals)
				return obj2.equals(obj1);
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				if (obj1.length !== obj2.length)
					return false;
				for (var i = 0, l = obj1.length; i < l; i++) {
					if (!Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			if (obj1 && typeof obj1 === 'object'
					&& obj2 && typeof obj2 === 'object') {
				if (!checkKeys(obj1, obj2) || !checkKeys(obj2, obj1))
					return false;
				for (var i in obj1) {
					if (obj1.hasOwnProperty(i)
							&& !Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			return false;
		},

		read: function(list, start, options, length) {
			if (this === Base) {
				var value = this.peek(list, start);
				list.__index++;
				return value;
			}
			var proto = this.prototype,
				readIndex = proto._readIndex,
				index = start || readIndex && list.__index || 0;
			if (!length)
				length = list.length - index;
			var obj = list[index];
			if (obj instanceof this
				|| options && options.readNull && obj == null && length <= 1) {
				if (readIndex)
					list.__index = index + 1;
				return obj && options && options.clone ? obj.clone() : obj;
			}
			obj = Base.create(this.prototype);
			if (readIndex)
				obj.__read = true;
			obj = obj.initialize.apply(obj, index > 0 || length < list.length
				? Array.prototype.slice.call(list, index, index + length)
				: list) || obj;
			if (readIndex) {
				list.__index = index + obj.__read;
				obj.__read = undefined;
			}
			return obj;
		},

		peek: function(list, start) {
			return list[list.__index = start || list.__index || 0];
		},

		remain: function(list) {
			return list.length - (list.__index || 0);
		},

		readAll: function(list, start, options) {
			var res = [],
				entry;
			for (var i = start || 0, l = list.length; i < l; i++) {
				res.push(Array.isArray(entry = list[i])
						? this.read(entry, 0, options)
						: this.read(list, i, options, 1));
			}
			return res;
		},

		readNamed: function(list, name, start, options, length) {
			var value = this.getNamed(list, name),
				hasObject = value !== undefined;
			if (hasObject) {
				var filtered = list._filtered;
				if (!filtered) {
					filtered = list._filtered = Base.create(list[0]);
					filtered._filtering = list[0];
				}
				filtered[name] = undefined;
			}
			return this.read(hasObject ? [value] : list, start, options, length);
		},

		getNamed: function(list, name) {
			var arg = list[0];
			if (list._hasObject === undefined)
				list._hasObject = list.length === 1 && Base.isPlainObject(arg);
			if (list._hasObject)
				return name ? arg[name] : list._filtered || arg;
		},

		hasNamed: function(list, name) {
			return !!this.getNamed(list, name);
		},

		isPlainValue: function(obj, asString) {
			return this.isPlainObject(obj) || Array.isArray(obj)
					|| asString && typeof obj === 'string';
		},

		serialize: function(obj, options, compact, dictionary) {
			options = options || {};

			var root = !dictionary,
				res;
			if (root) {
				options.formatter = new Formatter(options.precision);
				dictionary = {
					length: 0,
					definitions: {},
					references: {},
					add: function(item, create) {
						var id = '#' + item._id,
							ref = this.references[id];
						if (!ref) {
							this.length++;
							var res = create.call(item),
								name = item._class;
							if (name && res[0] !== name)
								res.unshift(name);
							this.definitions[id] = res;
							ref = this.references[id] = [id];
						}
						return ref;
					}
				};
			}
			if (obj && obj._serialize) {
				res = obj._serialize(options, dictionary);
				var name = obj._class;
				if (name && !compact && !res._compact && res[0] !== name)
					res.unshift(name);
			} else if (Array.isArray(obj)) {
				res = [];
				for (var i = 0, l = obj.length; i < l; i++)
					res[i] = Base.serialize(obj[i], options, compact,
							dictionary);
				if (compact)
					res._compact = true;
			} else if (Base.isPlainObject(obj)) {
				res = {};
				for (var i in obj)
					if (obj.hasOwnProperty(i))
						res[i] = Base.serialize(obj[i], options, compact,
								dictionary);
			} else if (typeof obj === 'number') {
				res = options.formatter.number(obj, options.precision);
			} else {
				res = obj;
			}
			return root && dictionary.length > 0
					? [['dictionary', dictionary.definitions], res]
					: res;
		},

		deserialize: function(json, create, _data) {
			var res = json;
			_data = _data || {};
			if (Array.isArray(json)) {
				var type = json[0],
					isDictionary = type === 'dictionary';
				if (!isDictionary) {
					if (_data.dictionary && json.length == 1 && /^#/.test(type))
						return _data.dictionary[type];
					type = Base.exports[type];
				}
				res = [];
				for (var i = type ? 1 : 0, l = json.length; i < l; i++)
					res.push(Base.deserialize(json[i], create, _data));
				if (isDictionary) {
					_data.dictionary = res[0];
				} else if (type) {
					var args = res;
					if (create) {
						res = create(type, args);
					} else {
						res = Base.create(type.prototype);
						type.apply(res, args);
					}
				}
			} else if (Base.isPlainObject(json)) {
				res = {};
				for (var key in json)
					res[key] = Base.deserialize(json[key], create, _data);
			}
			return res;
		},

		exportJSON: function(obj, options) {
			var json = Base.serialize(obj, options);
			return options && options.asString === false
					? json
					: JSON.stringify(json);
		},

		importJSON: function(json, target) {
			return Base.deserialize(
					typeof json === 'string' ? JSON.parse(json) : json,
					function(type, args) {
						var obj = target && target.constructor === type
								? target
								: Base.create(type.prototype),
							isTarget = obj === target;
						if (args.length === 1 && obj instanceof Item
								&& (isTarget || !(obj instanceof Layer))) {
							var arg = args[0];
							if (Base.isPlainObject(arg))
								arg.insert = false;
						}
						type.apply(obj, args);
						if (isTarget)
							target = null;
						return obj;
					});
		},

		splice: function(list, items, index, remove) {
			var amount = items && items.length,
				append = index === undefined;
			index = append ? list.length : index;
			if (index > list.length)
				index = list.length;
			for (var i = 0; i < amount; i++)
				items[i]._index = index + i;
			if (append) {
				list.push.apply(list, items);
				return [];
			} else {
				var args = [index, remove];
				if (items)
					args.push.apply(args, items);
				var removed = list.splice.apply(list, args);
				for (var i = 0, l = removed.length; i < l; i++)
					removed[i]._index = undefined;
				for (var i = index + amount, l = list.length; i < l; i++)
					list[i]._index = i;
				return removed;
			}
		},

		capitalize: function(str) {
			return str.replace(/\b[a-z]/g, function(match) {
				return match.toUpperCase();
			});
		},

		camelize: function(str) {
			return str.replace(/-(.)/g, function(all, chr) {
				return chr.toUpperCase();
			});
		},

		hyphenate: function(str) {
			return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}
	}
});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var entry = this._eventTypes[type];
			if (entry) {
				var handlers = this._callbacks = this._callbacks || {};
				handlers = handlers[type] = handlers[type] || [];
				if (handlers.indexOf(func) === -1) {
					handlers.push(func);
					if (entry.install && handlers.length == 1)
						entry.install.call(this, type);
				}
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var entry = this._eventTypes[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (entry && handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function() {
			func.apply(this, arguments);
			this.off(type, func);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = [].slice.call(arguments, 1);
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) === false
					&& event && event.stop) {
				event.stop();
				break;
			}
		}
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		for (var type in handlers) {
			if (handlers[type].length > 0) {
				var entry = this._eventTypes[type],
					func = entry[key];
				if (func)
					func.call(this, type);
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this.palettes = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if ( noCanvas ) {
			return;
		}
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1);
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}

		if (!this.browser) {
			var browser = proto.browser = {};
			navigator.userAgent.toLowerCase().replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g,
				function(all, n, v1, v2, rv) {
					if (!browser.chrome) {
						var v = n === 'opera' ? v2 : v1;
						if (n === 'trident') {
							v = rv;
							n = 'msie';
						} 
						browser.version = v;
						browser.versionNumber = parseFloat(v);
						browser.name = n;
						browser[n] = true;
					}
				}
			);
			if (browser.chrome)
				delete browser.webkit;
		}
	},

	version: '0.9.21',

	getView: function() {
		return this.project && this.project.getView();
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, url, options) {
		paper.PaperScript.execute(code, this, url, options);
		View.updateFocus();
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		for (var i = this.projects.length - 1; i >= 0; i--)
			this.projects[i].remove();
		for (var i = this.tools.length - 1; i >= 0; i--)
			this.tools[i].remove();
		for (var i = this.palettes.length - 1; i >= 0; i--)
			this.palettes[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = precision || 5;
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return Math.round(val * this.multiplier) / this.multiplier;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		cos = Math.cos,
		PI = Math.PI,
		TOLERANCE = 10e-6,
		EPSILON = 10e-12;

	function setupRoots(roots, min, max) {
		var unbound = min === undefined,
			minE = min - EPSILON,
			maxE = max + EPSILON,
			count = 0;
		return function(root) {
			if (unbound || root > minE && root < maxE)
				roots[count++] = root < min ? min : root > max ? max : root;
			return count;
		};
	}

	return {
		TOLERANCE: TOLERANCE,
		EPSILON: EPSILON,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return abs(val) <= EPSILON;
		},

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance)
					return nx;
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return x;
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var add = setupRoots(roots, min, max);

			if (abs(a) < EPSILON) {
				if (abs(b) >= EPSILON)
					return add(-c / b);
				return abs(c) < EPSILON ? -1 : 0;
			}
			var p = b / (2 * a);
			var q = c / a;
			var p2 = p * p;
			if (p2 < q - EPSILON)
				return 0;
			var s = p2 > q ? sqrt(p2 - q) : 0,
				count = add(s - p);
			if (s > 0)
				count = add(-s - p);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			if (abs(a) < EPSILON)
				return Numerical.solveQuadratic(b, c, d, roots, min, max);

			b /= a;
			c /= a;
			d /= a;
			var add = setupRoots(roots, min, max),
				bb = b * b,
				p = (bb - 3 * c) / 9,
				q = (2 * bb * b - 9 * b * c + 27 * d) / 54,
				ppp = p * p * p,
				D = q * q - ppp;
			b /= 3;
			if (abs(D) < EPSILON) {
				if (abs(q) < EPSILON)
					return add(-b);
				var sqp = sqrt(p),
					snq = q > 0 ? 1 : -1;
				add(-snq * 2 * sqp - b);
				return add(snq * sqp - b);
			}
			if (D < 0) {
				var sqp = sqrt(p),
					phi = Math.acos(q / (sqp * sqp * sqp)) / 3,
					t = -2 * sqp,
					o = 2 * PI / 3;
				add(t * cos(phi) - b);
				add(t * cos(phi + o) - b);
				return add(t * cos(phi - o) - b);
			}
			var A = (q > 0 ? -1 : 1) * pow(abs(q) + sqrt(D), 1 / 3);
			return add(A + p / A - b);
		}
	};
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this.x = arg0;
			this.y = hasY ? arg1 : arg0;
			if (this.__read)
				this.__read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.x != null) {
				this.x = arg0.x;
				this.y = arg0.y;
			} else if (arg0.width != null) {
				this.x = arg0.width;
				this.y = arg0.height;
			} else if (arg0.angle != null) {
				this.x = arg0.length;
				this.y = 0;
				this.setAngle(arg0.angle);
			} else {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this.set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			s = Math.sin(angle),
			c = Math.cos(angle);
		point = new Point(
			point.x * c - point.y * s,
			point.x * s + point.y * c
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function(point, tolerance) {
		return this.getDistance(point) < tolerance;
	},

	isColinear: function(point) {
		return Math.abs(this.cross(point)) < 0.00001;
	},

	isOrthogonal: function(point) {
		return Math.abs(this.dot(point)) < 0.00001;
	},

	isZero: function() {
		return Numerical.isZero(this.x) && Numerical.isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments);
		if (point.isZero()) {
			return new Point(0, 0);
		} else {
			var scale = this.dot(point) / point.dot(point);
			return new Point(
				point.x * scale,
				point.y * scale
			);
		}
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this.width = arg0;
			this.height = hasHeight ? arg1 : arg0;
			if (this.__read)
				this.__read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.width = this.height = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.width = arg0[0];
				this.height = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.width != null) {
				this.width = arg0.width;
				this.height = arg0.height;
			} else if (arg0.x != null) {
				this.width = arg0.x;
				this.height = arg0.y;
			} else {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		return Numerical.isZero(this.width) && Numerical.isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read = 0;
		if (type === 'number') {
			this.x = arg0;
			this.y = arg1;
			this.width = arg2;
			this.height = arg3;
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = this.width = this.height = 0;
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0[1];
				this.width = arg0[2];
				this.height = arg0[3];
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this.x = arg0.x || 0;
				this.y = arg0.y || 0;
				this.width = arg0.width || 0;
				this.height = arg0.height || 0;
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this.x = this.y = this.width = this.height = 0;
				this._set(arg0);
				read = 1;
			}
		}
		if (!read) {
			var point = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments);
			this.x = point.x;
			this.y = point.y;
			if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				this.width = to.x - point.x;
				this.height = to.y - point.y;
				if (this.width < 0) {
					this.x = to.x;
					this.width = -this.width;
				}
				if (this.height < 0) {
					this.y = to.y;
					this.height = -this.height;
				}
			} else {
				var size = Size.read(arguments);
				this.width = size.width;
				this.height = size.height;
			}
			read = arguments.__index;
		}
		if (this.__read)
			this.__read = read;
	},

	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (this._fixX)
			this.x += (this.width - size.width) * this._fixX;
		if (this._fixY)
			this.y += (this.height - size.height) * this._fixY;
		this.width = size.width;
		this.height = size.height;
		this._fixW = 1;
		this._fixH = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fixW)
			this.width -= left - this.x;
		this.x = left;
		this._fixX = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fixH)
			this.height -= top - this.y;
		this.y = top;
		this._fixY = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (this._fixX !== undefined && this._fixX !== 1)
			this._fixW = 0;
		if (this._fixW)
			this.x = right - this.width;
		else
			this.width = right - this.x;
		this._fixX = 1;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (this._fixY !== undefined && this._fixY !== 1)
			this._fixH = 0;
		if (this._fixH)
			this.y = bottom - this.height;
		else
			this.height = bottom - this.y;
		this._fixY = 1;
	},

	getCenterX: function() {
		return this.x + this.width * 0.5;
	},

	setCenterX: function(x) {
		this.x = x - this.width * 0.5;
		this._fixX = 0.5;
	},

	getCenterY: function() {
		return this.y + this.height * 0.5;
	},

	setCenterY: function(y) {
		this.y = y - this.height * 0.5;
		this._fixY = 0.5;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length == 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width > this.x
				&& rect.y + rect.height > this.y
				&& rect.x < this.x + this.width
				&& rect.y < this.y + this.height;
	},

	touches: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width >= this.x
				&& rect.y + rect.height >= this.y
				&& rect.x <= this.x + this.width
				&& rect.y <= this.y + this.height;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join('');
		var xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this.set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
}, new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key);
		var internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return this._owner._boundsSelected;
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner.setSelected) {
					owner._boundsSelected = selected;
					owner.setSelected(selected || owner._selectedSegmentState > 0);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg) {
		var count = arguments.length,
			ok = true;
		if (count === 6) {
			this.set.apply(this, arguments);
		} else if (count === 1) {
			if (arg instanceof Matrix) {
				this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
			} else if (Array.isArray(arg)) {
				this.set.apply(this, arg);
			} else {
				ok = false;
			}
		} else if (count === 0) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok)
			throw new Error('Unsupported matrix parameters');
	},

	set: function(a, c, b, d, tx, ty, _dontNotify) {
		this._a = a;
		this._c = c;
		this._b = b;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options) {
		return Base.serialize(this.getValues(), options);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(9);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._c, this._b, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._b),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._c), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._c = this._b = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function() {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._b;
		this._ty += x * this._c + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._c *= scale.x;
		this._b *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * b;
		this._b = -sin * a + cos * b;
		this._c = cos * c + sin * d;
		this._d = -sin * c + cos * d;
		this._tx += tx * a + ty * b;
		this._ty += tx * c + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			c = this._c;
		this._a += shear.y * this._b;
		this._c += shear.y * this._d;
		this._b += shear.x * a;
		this._d += shear.x * c;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	concatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + c2 * b1;
		this._b = b2 * a1 + d2 * b1;
		this._c = a2 * c1 + c2 * d1;
		this._d = b2 * c1 + d2 * d1;
		this._tx += tx2 * a1 + ty2 * b1;
		this._ty += tx2 * c1 + ty2 * d1;
		this._changed();
		return this;
	},

	preConcatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + b2 * c1;
		this._b = a2 * b1 + b2 * d1;
		this._c = c2 * a1 + d2 * c1;
		this._d = c2 * b1 + d2 * d1;
		this._tx = a2 * tx1 + b2 * ty1 + tx2;
		this._ty = c2 * tx1 + d2 * ty1 + ty2;
		this._changed();
		return this;
	},

	chain: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		return new Matrix(
				a2 * a1 + c2 * b1,
				a2 * c1 + c2 * d1,
				b2 * a1 + d2 * b1,
				b2 * c1 + d2 * d1,
				tx1 + tx2 * a1 + ty2 * b1,
				ty1 + tx2 * c1 + ty2 * d1);
	},

	isIdentity: function() {
		return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isInvertible: function() {
		return !!this._getDeterminant();
	},

	isSingular: function() {
		return !this._getDeterminant();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest.set(
			x * this._a + y * this._b + this._tx,
			x * this._c + y * this._d + this._ty,
			_dontNotify
		);
	},

	_transformCoordinates: function(src, dst, count) {
		var i = 0,
			j = 0,
			max = 2 * count;
		while (i < max) {
			var x = src[i++],
				y = src[i++];
			dst[j++] = x * this._a + y * this._b + this._tx;
			dst[j++] = x * this._c + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = coords.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j])
				min[j] = val;
			else if (val > max[j])
				max[j] = val;
		}
		if (!dest)
			dest = new Rectangle();
		return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_getDeterminant: function() {
		var det = this._a * this._d - this._b * this._c;
		return isFinite(det) && !Numerical.isZero(det)
				&& isFinite(this._tx) && isFinite(this._ty)
				? det : null;
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var det = this._getDeterminant();
		if (!det)
			return null;
		var x = point.x - this._tx,
			y = point.y - this._ty;
		if (!dest)
			dest = new Point();
		return dest.set(
			(x * this._d - y * this._b) / det,
			(y * this._a - x * this._c) / det,
			_dontNotify
		);
	},

	decompose: function() {
		var a = this._a, b = this._b, c = this._c, d = this._d;
		if (Numerical.isZero(a * d - b * c))
			return null;

		var scaleX = Math.sqrt(a * a + b * b);
		a /= scaleX;
		b /= scaleX;

		var shear = a * c + b * d;
		c -= a * shear;
		d -= b * shear;

		var scaleY = Math.sqrt(c * c + d * d);
		c /= scaleY;
		d /= scaleY;
		shear /= scaleY;

		if (a * d < b * c) {
			a = -a;
			b = -b;
			shear = -shear;
			scaleX = -scaleX;
		}

		return {
			scaling: new Point(scaleX, scaleY),
			rotation: -Math.atan2(b, a) * 180 / Math.PI,
			shearing: shear
		};
	},

	getValues: function() {
		return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return (this.decompose() || {}).scaling;
	},

	getRotation: function() {
		return (this.decompose() || {}).rotation;
	},

	inverted: function() {
		var det = this._getDeterminant();
		return det && new Matrix(
				this._d / det,
				-this._c / det,
				-this._b / det,
				this._a / det,
				(this._b * this._ty - this._d * this._tx) / det,
				(this._c * this._tx - this._a * this._ty) / det);
	},

	shiftless: function() {
		return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
	},

	applyToContext: function(ctx) {
		ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
	}
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
	var part = Base.capitalize(name),
		prop = '_' + name;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	getDistance: function(point) {
		return Math.abs(Line.getSignedDistance(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true));
	},

	statics: {
		intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector,
				isInfinite) {
			if (!asVector) {
				avx -= apx;
				avy -= apy;
				bvx -= bpx;
				bvy -= bpy;
			}
			var cross = avx * bvy - avy * bvx;
			if (!Numerical.isZero(cross)) {
				var dx = apx - bpx,
					dy = apy - bpy,
					ta = (bvx * dy - bvy * dx) / cross,
					tb = (avx * dy - avy * dx) / cross;
				if (isInfinite || 0 <= ta && ta <= 1 && 0 <= tb && tb <= 1)
					return new Point(
								apx + ta * avx,
								apy + ta * avy);
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (ccw === 0) {
				ccw = v2x * vx + v2y * vy;
				if (ccw > 0) {
					v2x -= vx;
					v2y -= vy;
					ccw = v2x * vx + v2y * vy;
					if (ccw < 0)
						ccw = 0;
				}
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			if (Numerical.isZero(vx))
				return x - px;
			var m = vy / vx,
				b = py - m * px;
			return (y - (m * x) - b) / Math.sqrt(m * m + 1);
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this.layers = [];
		this._activeLayer = null;
		this.symbols = [];
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectedItems = {};
		this._selectedItemCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.layers, options, true, dictionary);
	},

	clear: function() {
		for (var i = this.layers.length - 1; i >= 0; i--)
			this.layers[i].remove();
		this.symbols = [];
	},

	isEmpty: function() {
		return this.layers.length === 0;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.initialize(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this });
	},

	getSelectedItems: function() {
		var items = [];
		for (var id in this._selectedItems) {
			var item = this._selectedItems[id];
			if (item.isInserted())
				items.push(item);
		}
		return items;
	},

	addChild: function(child) {
		if (child instanceof Layer) {
			Base.splice(this.layers, [child]);
			if (!this._activeLayer)
				this._activeLayer = child;
		} else if (child instanceof Item) {
			(this._activeLayer
				|| this.addChild(new Layer(Item.NO_INSERT))).addChild(child);
		} else {
			child = null;
		}
		return child;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectedItems = this._selectedItems;
		if (item._selected) {
			if (selectedItems[id] !== item) {
				this._selectedItemCount++;
				selectedItems[id] = item;
			}
		} else if (selectedItems[id] === item) {
			this._selectedItemCount--;
			delete selectedItems[id];
		}
	},

	selectAll: function() {
		var layers = this.layers;
		for (var i = 0, l = layers.length; i < l; i++)
			layers[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectedItems = this._selectedItems;
		for (var i in selectedItems)
			selectedItems[i].setFullySelected(false);
	},

	hitTest: function() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(Base.read(arguments));
		for (var i = this.layers.length - 1; i >= 0; i--) {
			var res = this.layers[i]._hitTest(point, options);
			if (res) return res;
		}
		return null;
	},

	getItems: function(match) {
		return Item._getItems(this.layers, match);
	},

	getItem: function(match) {
		return Item._getItems(this.layers, match, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var param = new Base({
			offset: new Point(0, 0),
			pixelRatio: pixelRatio,
			viewMatrix: matrix.isIdentity() ? null : matrix,
			matrices: [new Matrix()],
			updateMatrix: true
		});
		for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
			layers[i].draw(ctx, param);
		ctx.restore();

		if (this._selectedItemCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectedItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items)
				items[id]._drawSelection(ctx, matrix, size, items, version);
			ctx.restore();
		}
	}
});

var Symbol = Base.extend({
	_class: 'Symbol',

	initialize: function Symbol(item, dontCenter) {
		this._id = Symbol._id = (Symbol._id || 0) + 1;
		this.project = paper.project;
		this.project.symbols.push(this);
		if (item)
			this.setDefinition(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._definition],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8) {
			Item._clearBoundsCache(this);
		}
		if (flags & 1) {
			this.project._needsUpdate = true;
		}
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(item, _dontCenter) {
		if (item._parentSymbol)
			item = item.clone();
		if (this._definition)
			this._definition._parentSymbol = null;
		this._definition = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._parentSymbol = this;
		this._changed(9);
	},

	place: function(position) {
		return new PlacedSymbol(this, position);
	},

	clone: function() {
		return new Symbol(this._definition.clone(false));
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = new Base(
						this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_applyMatrix: true,
	_canApplyMatrix: true,
	_boundsSelected: false,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		locked: false,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		guide: false,
		selected: false,
		clipMask: false,
		data: {}
	},

	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project;
		if (!internal)
			this._id = Item._id = (Item._id || 0) + 1;
		this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (!this._project) {
			if (internal || hasProps && props.insert === false) {
				this._setProject(project);
			} else if (hasProps && props.parent) {
				this.setParent(props.parent);
			} else {
				(project._activeLayer || new Layer()).addChild(this);
			}
		}
		if (hasProps && props !== Item.NO_INSERT)
			this._set(props, { insert: true, parent: true }, true);
		return hasProps;
	},

	_events: new function() {

		var mouseFlags = {
			mousedown: {
				mousedown: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mouseup: {
				mouseup: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mousemove: {
				mousedrag: 1,
				mousemove: 1,
				mouseenter: 1,
				mouseleave: 1
			}
		};

		var mouseEvent = {
			install: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags) {
						counters[key] = (counters[key] || 0)
								+ (mouseFlags[key][type] || 0);
					}
				}
			},
			uninstall: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags)
						counters[key] -= mouseFlags[key][type] || 0;
				}
			}
		};

		return Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
			function(name) {
				this[name] = mouseEvent;
			}, {
				onFrame: {
					install: function() {
						this._animateItem(true);
					},
					uninstall: function() {
						this._animateItem(false);
					}
				},

				onLoad: {}
			}
		);
	},

	_animateItem: function(animate) {
		this.getView()._animateItem(this, animate);
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._parentSymbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed =
					this._globalMatrix = this._currentPath = undefined;
		}
		if (cacheParent
				&& (flags & 40)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project) {
			if (flags & 1) {
				project._needsUpdate = true;
			}
			if (project._changes) {
				var entry = project._changesById[this._id];
				if (entry) {
					entry.flags |= flags;
				} else {
					entry = { item: this, flags: flags };
					project._changesById[this._id] = entry;
					project._changes.push(entry);
				}
			}
		}
		if (symbol)
			symbol._changed(flags);
	},

	set: function(props) {
		if (props)
			this._set(props);
		return this;
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name, unique) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				orig = name,
				i = 1;
			while (unique && children[name])
				name = orig + ' ' + (i++);
			(namedChildren[name] = namedChildren[name] || []).push(this);
			children[name] = this;
		}
		this._name = name || undefined;
		this._changed(128);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			name = '_' + name;
		this['get' + part] = function() {
			return this[name];
		};
		this['set' + part] = function(value) {
			if (value != this[name]) {
				this[name] = value;
				this._changed(name === '_locked'
						? 128 : 129);
			}
		};
	},
{}), {
	beans: true,

	_locked: false,

	_visible: true,

	_blendMode: 'normal',

	_opacity: 1,

	_guide: false,

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return this._selected;
	},

	setSelected: function(selected, noChildren) {
		if (!noChildren && this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		if ((selected = !!selected) ^ this._selected) {
			this._selected = selected;
			this._project._updateSelection(this);
			this._changed(129);
		}
	},

	_selected: false,

	isFullySelected: function() {
		var children = this._children;
		if (children && this._selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return this._selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this.setSelected(selected, true);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(129);
			if (this._parent)
				this._parent._changed(1024);
		}
	},

	_clipMask: false,

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var position = this._position,
			ctor = _dontLink ? Point : LinkedPoint;
		if (!position) {
			var pivot = this._pivot;
			position = this._position = pivot
					? this._matrix._transformPoint(pivot)
					: this.getBounds().getCenter(true);
		}
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	getPivot: function(_dontLink) {
		var pivot = this._pivot;
		if (pivot) {
			var ctor = _dontLink ? Point : LinkedPoint;
			pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
		}
		return pivot;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments);
		this._position = undefined;
	},

	_pivot: null,

	getRegistration: '#getPivot',
	setRegistration: '#setPivot'
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
		'internalBounds', 'internalRoughBounds'],
	function(key) {
		var getter = 'get' + Base.capitalize(key),
			match = key.match(/^internal(.*)$/),
			internalGetter = match ? 'get' + match[1] : null;
		this[getter] = function(_matrix) {
			var boundsGetter = this._boundsGetter,
				name = !internalGetter && (typeof boundsGetter === 'string'
						? boundsGetter : boundsGetter && boundsGetter[getter])
						|| getter,
				bounds = this._getCachedBounds(name, _matrix, this,
						internalGetter);
			return key === 'bounds'
					? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
							bounds.height, this, 'setBounds')
					: bounds;
		};
	},
{
	beans: true,

	_getBounds: function(getter, matrix, cacheItem) {
		var children = this._children;
		if (!children || children.length == 0)
			return new Rectangle();
		var x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			if (child._visible && !child.isEmpty()) {
				var rect = child._getCachedBounds(getter,
						matrix && matrix.chain(child._matrix), cacheItem);
				x1 = Math.min(rect.x, x1);
				y1 = Math.min(rect.y, y1);
				x2 = Math.max(rect.x + rect.width, x2);
				y2 = Math.max(rect.y + rect.height, y2);
			}
		}
		return isFinite(x1)
				? new Rectangle(x1, y1, x2 - x1, y2 - y1)
				: new Rectangle();
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			matrix.scale(
					bounds.width != 0 ? rect.width / bounds.width : 1,
					bounds.height != 0 ? rect.height / bounds.height : 1);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
		matrix = matrix && matrix.orNullIfIdentity();
		var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
			cache = (!matrix || matrix.equals(_matrix)) && getter;
		var cacheParent = this._parent || this._parentSymbol;
		if (cacheParent) {
			var id = cacheItem._id,
				ref = cacheParent._boundsCache = cacheParent._boundsCache || {
					ids: {},
					list: []
				};
			if (!ref.ids[id]) {
				ref.list.push(cacheItem);
				ref.ids[id] = cacheItem;
			}
		}
		if (cache && this._bounds && this._bounds[cache])
			return this._bounds[cache].clone();
		var bounds = this._getBounds(internalGetter || getter,
				matrix || _matrix, cacheItem);
		if (cache) {
			if (!this._bounds)
				this._bounds = {};
			var cached = this._bounds[cache] = bounds.clone();
			cached._internal = !!internalGetter;
		}
		return bounds;
	},

	statics: {
		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._decomposed = this._matrix.decompose();
	},

	getRotation: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			decomposed.rotation = rotation;
			this._decomposed = decomposed;
		}
	},

	getScaling: function(_dontLink) {
		var decomposed = this._decomposed || this._decompose(),
			scaling = decomposed && decomposed.scaling,
			ctor = _dontLink ? Point : LinkedPoint;
		return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling();
		if (current) {
			var scaling = Point.read(arguments, 0, { clone: true }),
				decomposed = this._decomposed;
			this.scale(scaling.x / current.x, scaling.y / current.y);
			decomposed.scaling = scaling;
			this._decomposed = decomposed;
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function(matrix) {
		this._matrix.initialize(matrix);
		if (this._applyMatrix) {
			this.transform(null, true);
		} else {
			this._changed(9);
		}
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix,
			updateVersion = this._project._updateVersion;
		if (matrix && matrix._updateVersion !== updateVersion)
			matrix = null;
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.preConcatenate(parent.getGlobalMatrix(true));
			matrix._updateVersion = updateVersion;
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(transform) {
		if (this._applyMatrix = this._canApplyMatrix && !!transform)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project.getView();
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		return this._parent && this._parent._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		return this._parent && this._parent._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(insert) {
		return this._clone(new this.constructor(Item.NO_INSERT), insert);
	},

	_clone: function(copy, insert) {
		copy.setStyle(this._style);
		if (this._children) {
			for (var i = 0, l = this._children.length; i < l; i++)
				copy.addChild(this._children[i].clone(false), true);
		}
		if (insert || insert === undefined)
			copy.insertAbove(this);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide', '_applyMatrix'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (this.hasOwnProperty(key))
				copy[key] = this[key];
		}
		copy._matrix.initialize(this._matrix);
		copy._data = this._data ? Base.clone(this._data) : null;
		copy.setSelected(this._selected);
		if (this._name)
			copy.setName(this._name, true);
		return copy;
	},

	copyTo: function(itemOrProject) {
		return itemOrProject.addChild(this.clone(false));
	},

	rasterize: function(resolution) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			canvas = CanvasProvider.getCanvas(size.multiply(scale)),
			ctx = canvas.getContext('2d'),
			matrix = new Matrix().scale(scale).translate(topLeft.negate());
		ctx.save();
		matrix.applyToContext(ctx);
		this.draw(ctx, new Base({ matrices: [matrix] }));
		ctx.restore();
		var raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(canvas);
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		return !!this._contains(
				this._matrix._inverseTransform(Point.read(arguments)));
	},

	_contains: function(point) {
		if (this._children) {
			for (var i = this._children.length - 1; i >= 0; i--) {
				if (this._children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(),
				_matrix || item._matrix).length > 0;
	},

	hitTest: function() {
		return this._hitTest(
				Point.read(arguments),
				HitResult.getOptions(Base.read(arguments)));
	},

	_hitTest: function(point, options) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty())
			return null;

		var matrix = this._matrix,
			parentTotalMatrix = options._totalMatrix,
			view = this.getView(),
			totalMatrix = options._totalMatrix = parentTotalMatrix
					? parentTotalMatrix.chain(matrix)
					: this.getGlobalMatrix().preConcatenate(view._matrix),
			tolerancePadding = options._tolerancePadding = new Size(
						Path._getPenPadding(1, totalMatrix.inverted())
					).multiply(
						Math.max(options.tolerance, 0.00001)
					);
		point = matrix._inverseTransform(point);

		if (!this._children && !this.getInternalRoughBounds()
				.expand(tolerancePadding.multiply(2))._containsPoint(point))
			return null;
		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this._selected
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			that = this,
			res;

		function checkBounds(type, part) {
			var pt = bounds['get' + part]();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1)
				return new HitResult(type, that,
						{ name: Base.hyphenate(part), point: pt });
		}

		if (checkSelf && (options.center || options.bounds) && this._parent) {
			var bounds = this.getInternalBounds();
			if (options.center)
				res = checkBounds('center', 'Center');
			if (!res && options.bounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++)
					res = checkBounds('bounds', points[i]);
			}
		}

		var children = !res && this._children;
		if (children) {
			var opts = this._getChildHitTestOptions(options);
			for (var i = children.length - 1; i >= 0 && !res; i--)
				res = children[i]._hitTest(point, opts);
		}
		if (!res && checkSelf)
			res = this._hitTestSelf(point, options);
		if (res && res.point)
			res.point = matrix.transform(res.point);
		options._totalMatrix = parentTotalMatrix;
		return res;
	},

	_getChildHitTestOptions: function(options) {
		return options;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		if (typeof name === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (/^(constructor|class)$/.test(name)) {
				if (!(this instanceof compare))
					return false;
			} else if (compare instanceof RegExp) {
				if (!compare.test(value))
					return false;
			} else if (typeof compare === 'function') {
				if (!compare(value))
					return false;
			} else if (Base.isPlainObject(compare)) {
				if (!matchObject(compare, value))
					return false;
			} else if (!Base.equals(value, compare)) {
				return false;
			}
		}
		return true;
	},

	getItems: function(match) {
		return Item._getItems(this._children, match, this._matrix);
	},

	getItem: function(match) {
		return Item._getItems(this._children, match, this._matrix, null, true)
				[0] || null;
	},

	statics: {
		_getItems: function _getItems(children, match, matrix, param,
				firstOnly) {
			if (!param) {
				var overlapping = match.overlapping,
					inside = match.inside,
					bounds = overlapping || inside,
					rect =	bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					inside: rect,
					overlapping: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (bounds)
					match = Base.set({}, match,
							{ inside: true, overlapping: true });
			}
			var items = param.items,
				inside = param.inside,
				overlapping = param.overlapping;
			matrix = inside && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.chain(child._matrix),
					add = true;
				if (inside) {
					var bounds = child.getBounds(childMatrix);
					if (!inside.intersects(bounds))
						continue;
					if (!(inside && inside.contains(bounds)) && !(overlapping
							&& overlapping.intersects(child, childMatrix)))
						add = false;
				}
				if (add && child.matches(match)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				_getItems(child._children, match,
						childMatrix, param,
						firstOnly);
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this
				? this.addChild(res)
				: res;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	insertChild: function(index, item, _preserve) {
		var res = this.insertChildren(index, [item], _preserve);
		return res && res[0];
	},

	addChildren: function(items, _preserve) {
		return this.insertChildren(this._children.length, items, _preserve);
	},

	insertChildren: function(index, items, _preserve, _proto) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Array.prototype.slice.apply(items);
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (_proto && !(item instanceof _proto)) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project && project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				item._parent = this;
				item._setProject(this._project, true);
				if (item._name)
					item.setName(item._name);
				if (notifySelf)
					this._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insert: function(above, item, _preserve) {
		if (!item._parent)
			return null;
		var index = item._index + (above ? 1 : 0);
		if (item._parent === this._parent && index > this._index)
			index--;
		return item._parent.insertChild(index, this, _preserve);
	},

	insertAbove: function(item, _preserve) {
		return this._insert(true, item, _preserve);
	},

	insertBelow: function(item, _preserve) {
		return this._insert(false, item, _preserve);
	},

	sendToBack: function() {
		return this._parent.insertChild(0, this);
	},

	bringToFront: function() {
		return this._parent.addChild(this);
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	reduce: function() {
		if (this._children && this._children.length === 1) {
			var child = this._children[0].reduce();
			child.insertAbove(this);
			child.setStyle(this._style);
			this.remove();
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var parent = this._parent;
		if (parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[namedArray.length - 1];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var parent = this._parent;
		if (parent) {
			if (this._name)
				this._removeNamed();
			if (this._index != null)
				Base.splice(parent._children, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf) {
				var project = this._project;
				if (project && project._changes)
					this._changed(5);
			}
			if (notifyParent)
				parent._changed(11);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(from, to) {
		if (!this._children)
			return null;
		from = from || 0;
		to = Base.pick(to, this._children.length);
		var removed = Base.splice(this._children, null, from, to - from);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function() {
		return !this._children || this._children.length === 0;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent == item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	rotate: function(angle ) {
		return this.transform(new Matrix().rotate(angle,
				Point.read(arguments, 1, { readNull: true })
					|| this.getPosition(true)));
	}
}, Base.each(['scale', 'shear', 'skew'], function(name) {
	this[name] = function() {
		var point = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[name](point,
				center || this.getPosition(true)));
	};
}, {

}), {
	transform: function(matrix, _applyMatrix) {
		if (matrix && matrix.isIdentity())
			matrix = null;
		var _matrix = this._matrix,
			applyMatrix = (_applyMatrix || this._applyMatrix)
				&& (!_matrix.isIdentity() || matrix);
		if (!matrix && !applyMatrix)
			return this;
		if (matrix)
			_matrix.preConcatenate(matrix);
		if (applyMatrix = applyMatrix && this._transformContent(_matrix)) {
			var pivot = this._pivot,
				style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			if (fillColor)
				fillColor.transform(_matrix);
			if (strokeColor)
				strokeColor.transform(_matrix);
			_matrix.reset(true);
		}
		var bounds = this._bounds,
			position = this._position;
		this._changed(9);
		var decomp = bounds && matrix && matrix.decompose();
		if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var rect = bounds[key];
				if (applyMatrix || !rect._internal)
					matrix._transformBounds(rect, rect);
			}
			var getter = this._boundsGetter,
				rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
			if (rect)
				this._position = rect.getCenter(true);
			this._bounds = bounds;
		} else if (matrix && position) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true);
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	},

	_setStyles: function(ctx) {
		var style = this._style,
			fillColor = style.getFillColor(),
			strokeColor = style.getStrokeColor(),
			shadowColor = style.getShadowColor();
		if (fillColor)
			ctx.fillStyle = fillColor.toCanvasStyle(ctx);
		if (strokeColor) {
			var strokeWidth = style.getStrokeWidth();
			if (strokeWidth > 0) {
				ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
				ctx.lineWidth = strokeWidth;
				var strokeJoin = style.getStrokeJoin(),
					strokeCap = style.getStrokeCap(),
					miterLimit = style.getMiterLimit();
				if (strokeJoin)
					ctx.lineJoin = strokeJoin;
				if (strokeCap)
					ctx.lineCap = strokeCap;
				if (miterLimit)
					ctx.miterLimit = miterLimit;
				if (paper.support.nativeDash) {
					var dashArray = style.getDashArray(),
						dashOffset = style.getDashOffset();
					if (dashArray && dashArray.length) {
						if ('setLineDash' in ctx) {
							ctx.setLineDash(dashArray);
							ctx.lineDashOffset = dashOffset;
						} else {
							ctx.mozDash = dashArray;
							ctx.mozDashOffset = dashOffset;
						}
					}
				}
			}
		}
		if (shadowColor) {
			var shadowBlur = style.getShadowBlur();
			if (shadowBlur > 0) {
				ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
				ctx.shadowBlur = shadowBlur;
				var offset = this.getShadowOffset();
				ctx.shadowOffsetX = offset.x;
				ctx.shadowOffsetY = offset.y;
			}
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].chain(matrix);
		if (!globalMatrix.isInvertible())
			return;

		function getViewMatrix(matrix) {
			return viewMatrix ? viewMatrix.chain(matrix) : matrix;
		}

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			globalMatrix._updateVersion = updateVersion;
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
			if (!bounds.width || !bounds.height)
				return;
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.chain(matrix)
				: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform)
			(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
		if (clip)
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish)
			ctx.clip();
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
		if ((this._drawSelected || this._boundsSelected)
				&& this._isUpdated(updateVersion)) {
			var color = this.getSelectedColor(true)
					|| this.getLayer().getSelectedColor(true),
				mx = matrix.chain(this.getGlobalMatrix(true));
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (this._drawSelected)
				this._drawSelected(ctx, mx, selectedItems);
			if (this._boundsSelected) {
				var half = size / 2;
					coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++)
					ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++)
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
	this['removeOn' + Base.capitalize(name)] = function() {
		var hash = {};
		hash[name] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}));

var Group = Item.extend({
	_class: 'Group',
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 1026) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			for (var i = 0, l = this._children.length; i < l; i++) {
				var child = this._children[i];
				if (child._clipMask) {
					clipItem = child;
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem(),
			draw = true;
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
				draw = false;
			} else {
				ctx.beginPath();
				param.dontStart = param.dontFinish = true;
			}
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (draw) {
			for (var i = 0, l = this._children.length; i < l; i++) {
				var item = this._children[i];
				if (item !== clipItem)
					item.draw(ctx, param);
			}
		}
		if (clip) {
			this._currentPath = ctx.currentPath;
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer(arg) {
		var props = Base.isPlainObject(arg)
				? new Base(arg)
				: { children: Array.isArray(arg) ? arg : arguments },
			insert = props.insert;
		props.insert = false;
		Group.call(this, props);
		if (insert || insert === undefined) {
			this._project.addChild(this);
			this.activate();
		}
	},

	_remove: function _remove(notify) {
		if (this._parent)
			return _remove.base.call(this, notify);
		if (this._index != null) {
			var project = this._project;
			if (project._activeLayer === this)
				project._activeLayer = this.getNextSibling()
						|| this.getPreviousSibling();
			Base.splice(project.layers, null, this._index, 1);
			this._installEvents(false);
			project._needsUpdate = true;
			return true;
		}
		return false;
	},

	getNextSibling: function getNextSibling() {
		return this._parent ? getNextSibling.base.call(this)
				: this._project.layers[this._index + 1] || null;
	},

	getPreviousSibling: function getPreviousSibling() {
		return this._parent ? getPreviousSibling.base.call(this)
				: this._project.layers[this._index - 1] || null;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_insert: function _insert(above, item, _preserve) {
		if (item instanceof Layer && !item._parent) {
			this._remove(true, true);
			Base.splice(item._project.layers, [this],
					item._index + (above ? 1 : 0), 0);
			this._setProject(item._project, true);
			return this;
		}
		return _insert.base.call(this, above, item, _preserve);
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsSelected: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props) {
		this._initialize(props);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	clone: function(insert) {
		var copy = new Shape(Item.NO_INSERT);
		copy.setType(this._type);
		copy.setSize(this._size);
		copy.setRadius(this._radius);
		return this._clone(copy, insert);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				var radius = Size.min(this._radius, size.divide(2));
				this._radius.set(radius.width, radius.height);
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius.set(width / 2, height / 2);
			}
			this._size.set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size.set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius.width, radius.height);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size.width, size.height);
				} else if (type === 'ellipse') {
					this._size.set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.setStyle(this._style);
		path.transform(this._matrix);
		if (insert || insert === undefined)
			path.insertAbove(this);
		return path;
	},

	_draw: function(ctx, param, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rect' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx);
			if (hasFill) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		if (getter !== 'getBounds' && this.hasStroke())
			rect = rect.expand(this.getStrokeWidth());
		return matrix ? matrix._transformBounds(rect) : rect;
	}
},
new function() {

	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var i = 0; i < 4; i++) {
				var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(corner, center);
				if ((expand ? rect.expand(expand) : rect).contains(point))
					return center;
			}
		}
	}

	function getEllipseRadius(point, radius) {
		var angle = point.getAngleInRadians(),
			width = radius.width * 2,
			height = radius.height * 2,
			x = width * Math.sin(angle),
			y = height * Math.cos(angle);
		return width * height / (2 * Math.sqrt(x * x + y * y));
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options) {
			var hit = false;
			if (this.hasStroke()) {
				var type = this._type,
					radius = this._radius,
					strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
				if (type === 'rectangle') {
					var center = getCornerCenter(this, point, strokeWidth);
					if (center) {
						var pt = point.subtract(center);
						hit = 2 * Math.abs(pt.getLength()
								- getEllipseRadius(pt, radius)) <= strokeWidth;
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(strokeWidth),
							inner = rect.expand(-strokeWidth);
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					if (type === 'ellipse')
						radius = getEllipseRadius(point, radius);
					hit = 2 * Math.abs(point.getLength() - radius)
							<= strokeWidth;
				}
			}
			return hit
					? new HitResult('stroke', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args));
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item.translate(point);
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: 'getBounds',
	_boundsSelected: true,
	_serializeFields: {
		source: null
	},

	initialize: function Raster(object, position) {
		if (!this._initialize(object,
				position !== undefined && Point.read(arguments, 1))) {
			if (typeof object === 'string') {
				this.setSource(object);
			} else {
				this.setImage(object);
			}
		}
		if (!this._size)
			this._size = new Size();
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	clone: function(insert) {
		var copy = new Raster(Item.NO_INSERT),
			image = this._image,
			canvas = this._canvas;
		if (image) {
			copy.setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(this._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			copy.setCanvas(copyCanvas);
		}
		return this._clone(copy, insert);
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size.equals(size)) {
			var element = this.getElement();
			this.setCanvas(CanvasProvider.getCanvas(size));
			if (element)
				this.getContext(true).drawImage(element, 0, 0,
						size.width, size.height);
		}
	},

	getWidth: function() {
		return this._size.width;
	},

	getHeight: function() {
		return this._size.height;
	},

	isEmpty: function() {
		return this._size.width === 0 && this._size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
		} else {
			this._image = image;
			this._canvas = null;
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(521);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(modify) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (modify) {
			this._image = null;
			this._changed(513);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		return this._image && this._image.src || this.toDataURL();
	},

	setSource: function(src) {
		var that = this,
			image;

		function loaded() {
			var view = that.getView();
			if (view) {
				paper = view._scope;
				that.setImage(image);
				that.emit('load');
				view.update();
			}
		}

			image = document.getElementById(src) || new Image();

		if (image.naturalWidth && image.naturalHeight) {
			setTimeout(loaded, 0);
		} else {
			DomEvent.add(image, {
				load: loaded
			});
			if (!image.src)
				image.src = src;
		}
		this.setImage(image);
	},

	getElement: function() {
		return this._canvas || this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.preConcatenate(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var src = this._image && this._image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL() : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (object.width) {
			bounds = new Rectangle(object);
		} else if (object.x) {
			bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
		}
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		ctx.drawImage(this.getElement(),
				-this._size.width / 2, -this._size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx) {
		var element = this.getElement();
		if (element) {
			ctx.globalAlpha = this._opacity;
			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var PlacedSymbol = Item.extend({
	_class: 'PlacedSymbol',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: { getBounds: 'getStrokeBounds' },
	_boundsSelected: true,
	_serializeFields: {
		symbol: null
	},

	initialize: function PlacedSymbol(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
	},

	_equals: function(item) {
		return this._symbol === item._symbol;
	},

	getSymbol: function() {
		return this._symbol;
	},

	setSymbol: function(symbol) {
		this._symbol = symbol;
		this._changed(9);
	},

	clone: function(insert) {
		var copy = new PlacedSymbol(Item.NO_INSERT);
		copy.setSymbol(this._symbol);
		return this._clone(copy, insert);
	},

	isEmpty: function() {
		return this._symbol._definition.isEmpty();
	},

	_getBounds: function(getter, matrix, cacheItem) {
		var definition = this.symbol._definition;
		return definition._getCachedBounds(getter,
				matrix && matrix.chain(definition._matrix), cacheItem);
	},

	_hitTestSelf: function(point, options) {
		var res = this._symbol._definition._hitTest(point, options);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this.symbol._definition.draw(ctx, param);
	}

});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values) {
			values.enumerable = true;
			this.inject(values);
		}
	},

	statics: {
		getOptions: function(options) {
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut;
		if (count === 0) {
		} else if (count === 1) {
			if (arg0.point) {
				point = arg0.point;
				handleIn = arg0.handleIn;
				handleOut = arg0.handleOut;
			} else {
				point = arg0;
			}
		} else if (count === 2 && typeof arg0 === 'number') {
			point = arguments;
		} else if (count <= 3) {
			point = arg0;
			handleIn = arg1;
			handleOut = arg2;
		} else {
			point = arg0 !== undefined ? [ arg0, arg1 ] : null;
			handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
			handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
	},

	_serialize: function(options) {
		return Base.serialize(this.isLinear() ? this._point
				: [this._point, this._handleIn, this._handleOut],
				options, true);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(25);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this._point.set(point.x, point.y);
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		var point = Point.read(arguments);
		this._handleIn.set(point.x, point.y);
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		var point = Point.read(arguments);
		this._handleOut.set(point.x, point.y);
	},

	isLinear: function() {
		return this._handleIn.isZero() && this._handleOut.isZero();
	},

	setLinear: function(linear) {
		if (linear) {
			this._handleIn.set(0, 0);
			this._handleOut.set(0, 0);
		} else {
		}
	},

	isColinear: function(segment) {
		var next1 = this.getNext(),
			next2 = segment.getNext();
		return this._handleOut.isZero() && next1._handleIn.isZero()
				&& segment._handleOut.isZero() && next2._handleIn.isZero()
				&& next1._point.subtract(this._point).isColinear(
					next2._point.subtract(segment._point));
	},

	isOrthogonal: function() {
		var prev = this.getPrevious(),
			next = this.getNext();
		return prev._handleOut.isZero() && this._handleIn.isZero()
			&& this._handleOut.isZero() && next._handleIn.isZero()
			&& this._point.subtract(prev._point).isOrthogonal(
					next._point.subtract(this._point));
	},

	isArc: function() {
		var next = this.getNext(),
			handle1 = this._handleOut,
			handle2 = next._handleIn,
			kappa = 0.5522847498307936;
		if (handle1.isOrthogonal(handle2)) {
			var from = this._point,
				to = next._point,
				corner = new Line(from, handle1, true).intersect(
						new Line(to, handle2, true), true);
			return corner && Numerical.isZero(handle1.getLength() /
					corner.subtract(from).getLength() - kappa)
				&& Numerical.isZero(handle2.getLength() /
					corner.subtract(to).getLength() - kappa);
		}
		return false;
	},

	_selectionState: 0,

	isSelected: function(_point) {
		var state = this._selectionState;
		return !_point ? !!(state & 7)
			: _point === this._point ? !!(state & 4)
			: _point === this._handleIn ? !!(state & 1)
			: _point === this._handleOut ? !!(state & 2)
			: false;
	},

	setSelected: function(selected, _point) {
		var path = this._path,
			selected = !!selected,
			state = this._selectionState,
			oldState = state,
			flag = !_point ? 7
					: _point === this._point ? 4
					: _point === this._handleIn ? 1
					: _point === this._handleOut ? 2
					: 0;
		if (selected) {
			state |= flag;
		} else {
			state &= ~flag;
		}
		this._selectionState = state;
		if (path && state !== oldState) {
			path._updateSelection(this, oldState, state);
			path._changed(129);
		}
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	reverse: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i  = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y, selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	_serialize: function(options) {
		var f = options.formatter,
			x = f.number(this._x),
			y = f.number(this._y);
		return this.isSelected()
				? { x: x, y: y, selected: true }
				: [x, y];
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		return Numerical.isZero(this._x) && Numerical.isZero(this._y);
	},

	setSelected: function(selected) {
		this._owner.setSelected(selected, this);
	},

	isSelected: function() {
		return this._owner.isSelected(this);
	}
});

var Curve = Base.extend({
	_class: 'Curve',

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length;
		if (count === 3) {
			this._path = arg0;
			this._segment1 = arg1;
			this._segment2 = arg2;
		} else if (count === 0) {
			this._segment1 = new Segment();
			this._segment2 = new Segment();
		} else if (count === 1) {
			this._segment1 = new Segment(arg0.segment1);
			this._segment2 = new Segment(arg0.segment2);
		} else if (count === 2) {
			this._segment1 = new Segment(arg0);
			this._segment2 = new Segment(arg1);
		} else {
			var point1, handle1, handle2, point2;
			if (count === 4) {
				point1 = arg0;
				handle1 = arg1;
				handle2 = arg2;
				point2 = arg3;
			} else if (count === 8) {
				point1 = [arg0, arg1];
				point2 = [arg6, arg7];
				handle1 = [arg2 - arg0, arg3 - arg1];
				handle2 = [arg4 - arg6, arg5 - arg7];
			}
			this._segment1 = new Segment(point1, null, handle1);
			this._segment2 = new Segment(point2, handle2, null);
		}
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		var point = Point.read(arguments);
		this._segment1._point.set(point.x, point.y);
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		var point = Point.read(arguments);
		this._segment2._point.set(point.x, point.y);
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		var point = Point.read(arguments);
		this._segment1._handleOut.set(point.x, point.y);
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		var point = Point.read(arguments);
		this._segment2._handleIn.set(point.x, point.y);
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	},

	getLength: function() {
		if (this._length == null) {
			this._length = this.isLinear()
				? this._segment2._point.getDistance(this._segment1._point)
				: Curve.getLength(this.getValues(), 0, 1);
		}
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	isLinear: function() {
		return this._segment1._handleOut.isZero()
				&& this._segment2._handleIn.isZero();
	},

	isHorizontal: function() {
		return this.isLinear() && Numerical.isZero(
				this._segment1._point._y - this._segment2._point._y);
	},

	getIntersections: function(curve) {
		return Curve.getIntersections(this.getValues(), curve.getValues(),
				this, curve, []);
	},

	_getParameter: function(offset, isParameter) {
		return isParameter
				? offset
				: offset && offset.curve === this
					? offset.parameter
					: offset === undefined && isParameter === undefined
						? 0.5
						: this.getParameterAt(offset, 0);
	},

	divide: function(offset, isParameter, ignoreLinear) {
		var parameter = this._getParameter(offset, isParameter),
			tolerance = 0.00001,
			res = null;
		if (parameter > tolerance && parameter < 1 - tolerance) {
			var parts = Curve.subdivide(this.getValues(), parameter),
				isLinear = ignoreLinear ? false : this.isLinear(),
				left = parts[0],
				right = parts[1];

			if (!isLinear) {
				this._segment1._handleOut.set(left[2] - left[0],
						left[3] - left[1]);
				this._segment2._handleIn.set(right[4] - right[6],
						right[5] - right[7]);
			}

			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						!isLinear && new Point(left[4] - x, left[5] - y),
						!isLinear && new Point(right[2] - x, right[3] - y));

			if (this._path) {
				if (this._segment1._index > 0 && this._segment2._index === 0) {
					this._path.add(segment);
				} else {
					this._path.insert(this._segment2._index, segment);
				}
				res = this;
			} else {
				var end = this._segment2;
				this._segment2 = segment;
				res = new Curve(segment, end);
			}
		}
		return res;
	},

	split: function(offset, isParameter) {
		return this._path
			? this._path.split(this._segment1._index,
					this._getParameter(offset, isParameter))
			: null;
	},

	reverse: function() {
		return new Curve(this._segment2.reverse(), this._segment1.reverse());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut.x, handleOut.y);
		}
		return removed;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

statics: {
	getValues: function(segment1, segment2, matrix) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			values = [
				p1._x, p1._y,
				p1._x + h1._x, p1._y + h1._y,
				p2._x + h2._x, p2._y + h2._y,
				p2._x, p2._y
			];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	evaluate: function(v, t, type) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			tolerance = 0.00001,
			x, y;

		if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
			var isZero = t < tolerance;
			x = isZero ? p1x : p2x;
			y = isZero ? p1y : p2y;
		} else {
			var cx = 3 * (c1x - p1x),
				bx = 3 * (c2x - c1x) - cx,
				ax = p2x - p1x - cx - bx,

				cy = 3 * (c1y - p1y),
				by = 3 * (c2y - c1y) - cy,
				ay = p2y - p1y - cy - by;
			if (type === 0) {
				x = ((ax * t + bx) * t + cx) * t + p1x;
				y = ((ay * t + by) * t + cy) * t + p1y;
			} else {
				if (t < tolerance && c1x === p1x && c1y === p1y
						|| t > 1 - tolerance && c2x === p2x && c2y === p2y) {
					x = c2x - c1x;
					y = c2y - c1y;
				} else if (t < tolerance) {
					x = cx;
					y = cy;
				} else if (t > 1 - tolerance) {
					x = 3 * (p2x - c2x);
					y = 3 * (p2y - c2y);
				} else {
					x = (3 * ax * t + 2 * bx) * t + cx;
					y = (3 * ay * t + 2 * by) * t + cy;
				}
				if (type === 3) {
					var x2 = 6 * ax * t + 2 * bx,
						y2 = 6 * ay * t + 2 * by;
					return (x * y2 - y * x2) / Math.pow(x * x + y * y, 3 / 2);
				}
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	},

	subdivide: function(v, t) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
			p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
			p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
			p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
			p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
			p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
		return [
			[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
			[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
		];
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var p1 = v[coord],
			c1 = v[coord + 2],
			c2 = v[coord + 4],
			p2 = v[coord + 6],
			c = 3 * (c1 - p1),
			b = 3 * (c2 - c1) - c,
			a = p2 - p1 - c - b;
		return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
	},

	getParameterOf: function(v, x, y) {
		var tolerance = 0.00001;
		if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance)
			return 0;
		if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance)
			return 1;
		var txs = [],
			tys = [],
			sx = Curve.solveCubic(v, 0, x, txs, 0, 1),
			sy = Curve.solveCubic(v, 1, y, tys, 0, 1),
			tx, ty;
		for (var cx = 0;  sx == -1 || cx < sx;) {
			if (sx == -1 || (tx = txs[cx++]) >= 0 && tx <= 1) {
				for (var cy = 0; sy == -1 || cy < sy;) {
					if (sy == -1 || (ty = tys[cy++]) >= 0 && ty <= 1) {
						if (sx == -1) tx = ty;
						else if (sy == -1) ty = tx;
						if (Math.abs(tx - ty) < tolerance)
							return (tx + ty) * 0.5;
					}
				}
				if (sx == -1)
					break;
			}
		}
		return null;
	},

	getPart: function(v, from, to) {
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return v;
	},

	isLinear: function(v) {
		var isZero = Numerical.isZero;
		return isZero(v[0] - v[2]) && isZero(v[1] - v[3])
				&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]);
	},

	isFlatEnough: function(v, tolerance) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			ux = 3 * c1x - 2 * p1x - p2x,
			uy = 3 * c1y - 2 * p1y - p2y,
			vx = 3 * c2x - 2 * p2x - p1x,
			vy = 3 * c2y - 2 * p2y - p1y;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				< 10 * tolerance * tolerance;
	},

	getArea: function(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		return (  3.0 * c1y * p1x - 1.5 * c1y * c2x
				- 1.5 * c1y * p2x - 3.0 * p1y * c1x
				- 1.5 * p1y * c2x - 0.5 * p1y * p2x
				+ 1.5 * c2y * p1x + 1.5 * c2y * c1x
				- 3.0 * c2y * p2x + 0.5 * p2y * p1x
				+ 1.5 * p2y * c1x + 3.0 * p2y * c2x) / 10;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}
		var a = 3 * (v1 - v2) - v0 + v3,
			b = 2 * (v0 + v2) - 4 * v1,
			c = v1 - v0,
			count = Numerical.solveQuadratic(a, b, c, roots),
			tMin = 0.00001,
			tMax = 1 - tMin;
		add(v3, 0);
		for (var i = 0; i < count; i++) {
			var t = roots[i],
				u = 1 - t;
			if (tMin < t && t < tMax)
				add(u * u * u * v0
					+ 3 * u * u * t * v1
					+ 3 * u * t * t * v2
					+ t * t * t * v3,
					padding);
		}
	}
}}, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name]([this._segment1,
						this._segment2], false, this._path.getStyle());
			}
			return bounds.clone();
		};
	},
{

}), Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name, index) {
		this[name + 'At'] = function(offset, isParameter) {
			var values = this.getValues();
			return Curve.evaluate(values, isParameter
					? offset : Curve.getParameterAt(values, offset, 0), index);
		};
		this[name] = function(parameter) {
			return Curve.evaluate(this.getValues(), parameter, index);
		};
	},
{
	beans: false,

	getParameterAt: function(offset, start) {
		return Curve.getParameterAt(this.getValues(), offset, start);
	},

	getParameterOf: function() {
		var point = Point.read(arguments);
		return Curve.getParameterOf(this.getValues(), point.x, point.y);
	},

	getLocationAt: function(offset, isParameter) {
		if (!isParameter)
			offset = this.getParameterAt(offset);
		return offset >= 0 && offset <= 1 && new CurveLocation(this, offset);
	},

	getLocationOf: function() {
		return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
				true);
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(
						Curve.evaluate(values, t, 0), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 0.00001) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		var pt = Curve.evaluate(values, minT, 0);
		return new CurveLocation(this, minT, pt, null, null, null,
				point.getDistance(pt));
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}

}),
new function() {

	function getLengthIntegrand(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],

			ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
			bx = 6 * (p1x + c2x) - 12 * c1x,
			cx = 3 * (c1x - p1x),

			ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
			by = 6 * (p1y + c2y) - 12 * c1y,
			cy = 3 * (c1y - p1y);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	return {
		statics: true,

		getLength: function(v, a, b) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			var isZero = Numerical.isZero;
			if (a === 0 && b === 1
					&& isZero(v[0] - v[2]) && isZero(v[1] - v[3])
					&& isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
				var dx = v[6] - v[0],
					dy = v[7] - v[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			var ds = getLengthIntegrand(v);
			return Numerical.integrate(ds, a, b, getIterations(a, b));
		},

		getParameterAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0
			if (offset === 0)
				return start;
			var forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Numerical.integrate(ds, a, b,
						getIterations(a, b));
			if (Math.abs(offset) >= rangeLength)
				return forward ? b : a;
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 16,
					0.00001);
		}
	};
}, new function() {
	function addLocation(locations, include, curve1, t1, point1, curve2, t2,
			point2) {
		var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
		if (!include || include(loc))
			locations.push(loc);
	}

	function addCurveIntersections(v1, v2, curve1, curve2, locations, include,
			tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
		if (recursion > 20)
			return;
		var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			tolerance = 0.00001,
			hullEpsilon = 1e-9,
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			tMinNew, tMaxNew, tDiff;
		if (q0x === q3x && uMax - uMin <= hullEpsilon && recursion > 3) {
			tMinNew = (tMax + tMin) / 2;
			tMaxNew = tMinNew;
			tDiff = 0;
		} else {
			var hull = getConvexHull(dp0, dp1, dp2, dp3),
				top = hull[0],
				bottom = hull[1],
				tMinClip, tMaxClip;
			tMinClip = clipConvexHull(top, bottom, dMin, dMax);
			top.reverse();
			bottom.reverse();
			tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
			if (tMinClip == null || tMaxClip == null)
				return false;
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			tDiff = tMaxClip - tMinClip;
			tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
			tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
		}
		if (oldTDiff > 0.8 && tDiff > 0.8) {
			if (tMaxNew - tMinNew > uMax - uMin) {
				var parts = Curve.subdivide(v1, 0.5),
					t = tMinNew + (tMaxNew - tMinNew) / 2;
				addCurveIntersections(
					v2, parts[0], curve2, curve1, locations, include,
					uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					v2, parts[1], curve2, curve1, locations, include,
					uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
			} else {
				var parts = Curve.subdivide(v2, 0.5),
					t = uMin + (uMax - uMin) / 2;
				addCurveIntersections(
					parts[0], v1, curve2, curve1, locations, include,
					uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					parts[1], v1, curve2, curve1, locations, include,
					t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		} else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
			var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
				t2 = uMin + (uMax - uMin) / 2;
			if (reverse) {
				addLocation(locations, include,
						curve2, t2, Curve.evaluate(v2, t2, 0),
						curve1, t1, Curve.evaluate(v1, t1, 0));
			} else {
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		} else {
			addCurveIntersections(v2, v1, curve2, curve1, locations, include,
					uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
		}
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			getSignedDistance = Line.getSignedDistance,
			dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
			dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
			flip = false,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
			flip = dist1 < 0;
		} else {
			var pmax, cross = 0,
				distZero = dist1 === 0 || dist2 === 0;
			if (Math.abs(dist1) > Math.abs(dist2)) {
				pmax = p1;
				cross = (dq3 - dq2 - (dq3 - dq0) / 3)
						* (2 * (dq3 - dq2) - dq3 + dq1) / 3;
			} else {
				pmax = p2;
				cross = (dq1 - dq0 + (dq0 - dq3) / 3)
						* (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
			}
			hull = cross < 0 || distZero
					? [[p0, pmax, p3], [p0, p3]]
					: [[p0, p1, p2, p3], [p0, p3]];
			flip = dist1 ? dist1 < 0 : dist2 < 0;
		}
		return flip ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		var tProxy,
			tVal = null,
			px, py,
			qx, qy;
		for (var i = 0, l = hullBottom.length - 1; i < l; i++) {
			py = hullBottom[i][1];
			qy = hullBottom[i + 1][1];
			if (py < qy) {
				tProxy = null;
			} else if (qy <= dMax) {
				px = hullBottom[i][0];
				qx = hullBottom[i + 1][0];
				tProxy = px + (dMax - py) * (qx - px) / (qy - py);
			} else {
				continue;
			}
			break;
		}
		if (hullTop[0][1] <= dMax)
			tProxy = hullTop[0][0];
		for (var i = 0, l = hullTop.length - 1; i < l; i++) {
			py = hullTop[i][1];
			qy = hullTop[i + 1][1];
			if (py >= dMin) {
				tVal = tProxy;
			} else if (py > qy) {
				tVal = null;
			} else if (qy >= dMin) {
				px = hullTop[i][0];
				qx = hullTop[i + 1][0];
				tVal = px + (dMin  - py) * (qx - px) / (qy - py);
			} else {
				continue;
			}
			break;
		}
		return tVal;
	}

	function addCurveLineIntersections(v1, v2, curve1, curve2, locations,
			include) {
		var flip = Curve.isLinear(v1),
			vc = flip ? v2 : v1,
			vl = flip ? v1 : v2,
			lx1 = vl[0], ly1 = vl[1],
			lx2 = vl[6], ly2 = vl[7],
			ldx = lx2 - lx1,
			ldy = ly2 - ly1,
			angle = Math.atan2(-ldy, ldx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rlx2 = ldx * cos - ldy * sin,
			rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0],
			rvc = [];
		for(var i = 0; i < 8; i += 2) {
			var x = vc[i] - lx1,
				y = vc[i + 1] - ly1;
			rvc.push(
				x * cos - y * sin,
				y * cos + x * sin);
		}
		var roots = [],
			count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
		for (var i = 0; i < count; i++) {
			var tc = roots[i],
				x = Curve.evaluate(rvc, tc, 0).x;
			if (x >= 0 && x <= rlx2) {
				var tl = Curve.getParameterOf(rvl, x, 0),
					t1 = flip ? tl : tc,
					t2 = flip ? tc : tl;
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		}
	}

	function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
		var point = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (point) {
			var x = point.x,
				y = point.y;
			addLocation(locations, include,
					curve1, Curve.getParameterOf(v1, x, y), point,
					curve2, Curve.getParameterOf(v2, x, y), point);
		}
	}

	return { statics: {
		getIntersections: function(v1, v2, curve1, curve2, locations, include) {
			var linear1 = Curve.isLinear(v1),
				linear2 = Curve.isLinear(v2);
			(linear1 && linear2
				? addLineIntersection
				: linear1 || linear2
					? addCurveLineIntersections
					: addCurveIntersections)(
						v1, v2, curve1, curve2, locations, include,
						0, 1, 0, 1, 0, false, 0);
			return locations;
		}
	}};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',
	beans: true,

	initialize: function CurveLocation(curve, parameter, point, _curve2,
			_parameter2, _point2, _distance) {
		this._id = CurveLocation._id = (CurveLocation._id || 0) + 1;
		this._curve = curve;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
		this._parameter = parameter;
		this._point = point;
		this._curve2 = _curve2;
		this._parameter2 = _parameter2;
		this._point2 = _point2;
		this._distance = _distance;
	},

	getSegment: function(_preferFirst) {
		if (!this._segment) {
			var curve = this.getCurve(),
				parameter = this.getParameter();
			if (parameter === 1) {
				this._segment = curve._segment2;
			} else if (parameter === 0 || _preferFirst) {
				this._segment = curve._segment1;
			} else if (parameter == null) {
				return null;
			} else {
				this._segment = curve.getPartLength(0, parameter)
					< curve.getPartLength(parameter, 1)
						? curve._segment1
						: curve._segment2;
			}
		}
		return this._segment;
	},

	getCurve: function(_uncached) {
		if (!this._curve || _uncached) {
			this._curve = this._segment1.getCurve();
			if (this._curve.getParameterOf(this._point) == null)
				this._curve = this._segment2.getPrevious().getCurve();
		}
		return this._curve;
	},

	getIntersection: function() {
		var intersection = this._intersection;
		if (!intersection && this._curve2) {
			var param = this._parameter2;
			this._intersection = intersection = new CurveLocation(
					this._curve2, param, this._point2 || this._point, this);
			intersection._intersection = this;
		}
		return intersection;
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getOffset: function() {
		var path = this.getPath();
		return path ? path._getOffset(this) : this.getCurveOffset();
	},

	getCurveOffset: function() {
		var curve = this.getCurve(),
			parameter = this.getParameter();
		return parameter != null && curve && curve.getPartLength(0, parameter);
	},

	getParameter: function(_uncached) {
		if ((this._parameter == null || _uncached) && this._point) {
			var curve = this.getCurve(_uncached);
			this._parameter = curve && curve.getParameterOf(this._point);
		}
		return this._parameter;
	},

	getPoint: function(_uncached) {
		if ((!this._point || _uncached) && this._parameter != null) {
			var curve = this.getCurve(_uncached);
			this._point = curve && curve.getPointAt(this._parameter, true);
		}
		return this._point;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(true);
		return curve && curve.divide(this.getParameter(true), true);
	},

	split: function() {
		var curve = this.getCurve(true);
		return curve && curve.split(this.getParameter(true), true);
	},

	equals: function(loc) {
		var isZero = Numerical.isZero;
		return this === loc
				|| loc
					&& this._curve === loc._curve
					&& this._curve2 === loc._curve2
					&& isZero(this._parameter - loc._parameter)
					&& isZero(this._parameter2 - loc._parameter2)
				|| false;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var parameter = this.getParameter();
		if (parameter != null)
			parts.push('parameter: ' + f.number(parameter));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	}
}, Base.each(['getTangent', 'getNormal', 'getCurvature'], function(name) {
	var get = name + 'At';
	this[name] = function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve[get](parameter, true);
	};
}, {}));

var PathItem = Item.extend({
	_class: 'PathItem',

	initialize: function PathItem() {
	},

	getIntersections: function(path, _matrix, _expand) {
		if (this === path)
			path = null;
		var locations = [],
			curves1 = this.getCurves(),
			curves2 = path ? path.getCurves() : curves1,
			matrix1 = this._matrix.orNullIfIdentity(),
			matrix2 = path ? (_matrix || path._matrix).orNullIfIdentity()
				: matrix1,
			length1 = curves1.length,
			length2 = path ? curves2.length : length1,
			values2 = [],
			MIN = 1e-11,
			MAX = 1 - 1e-11;
		if (path && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
			return [];
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = path ? curve1.getValues(matrix1) : values2[i];
			if (!path) {
				var seg1 = curve1.getSegment1(),
					seg2 = curve1.getSegment2(),
					h1 = seg1._handleOut,
					h2 = seg2._handleIn;
				if (new Line(seg1._point.subtract(h1), h1.multiply(2), true)
						.intersect(new Line(seg2._point.subtract(h2),
						h2.multiply(2), true), false)) {
					var parts = Curve.subdivide(values1);
					Curve.getIntersections(
						parts[0], parts[1], curve1, curve1, locations,
						function(loc) {
							if (loc._parameter <= MAX) {
								loc._parameter /= 2;
								loc._parameter2 = 0.5 + loc._parameter2 / 2;
								return true;
							}
						}
					);
				}
			}
			for (var j = path ? 0 : i + 1; j < length2; j++) {
				Curve.getIntersections(
					values1, values2[j], curve1, curves2[j], locations,
					!path && (j === i + 1 || j === length2 - 1 && i === 0)
						&& function(loc) {
							var t = loc._parameter;
							return t >= MIN && t <= MAX;
						}
				);
			}
		}
		var last = locations.length - 1;
		for (var i = last; i >= 0; i--) {
			var loc = locations[i],
				next = loc._curve.getNext(),
				next2 = loc._curve2.getNext();
			if (next && loc._parameter >= MAX) {
				loc._parameter = 0;
				loc._curve = next;
			}
			if (next2 && loc._parameter2 >= MAX) {
				loc._parameter2 = 0;
				loc._curve2 = next2;
			}
		}

		function compare(loc1, loc2) {
			var path1 = loc1.getPath(),
				path2 = loc2.getPath();
			return path1 === path2
					? (loc1.getIndex() + loc1.getParameter())
							- (loc2.getIndex() + loc2.getParameter())
					: path1._id - path2._id;
		}

		if (last > 0) {
			locations.sort(compare);
			for (var i = last; i >= 1; i--) {
				if (locations[i].equals(locations[i === 0 ? last : i - 1])) {
					locations.splice(i, 1);
					last--;
				}
			}
		}
		if (_expand) {
			for (var i = last; i >= 0; i--)
				locations.push(locations[i].getIntersection());
			locations.sort(compare);
		}
		return locations;
	},

	_asPathItem: function() {
		return this;
	},

	setPathData: function(data) {

		var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current = start);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				if (move && previous && previous !== 'z')
					this.closePath(true);
				for (var j = 0; j < length; j += 2)
					this[j === 0 && move ? 'moveTo' : 'lineTo'](
							current = getPoint(j));
				control = current;
				if (move)
					start = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[0], +coords[1]),
							+coords[2], +coords[4], +coords[3]);
				}
				break;
			case 'z':
				this.closePath(true);
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = this._getWinding(point, false, true);
		return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
	}

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._selectedSegmentState = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return Base.equals(this._segments, item._segments);
	},

	clone: function(insert) {
		var copy = new Path(Item.NO_INSERT);
		copy.setSegments(this._segments);
		copy._closed = this._closed;
		if (this._clockwise !== undefined)
			copy._clockwise = this._clockwise;
		return this._clone(copy, insert);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			var parent = this._parent;
			if (parent)
				parent._currentPath = undefined;
			this._length = this._clockwise = undefined;
			if (this._curves && !(flags & 16)) {
				for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
			this._monoCurves = undefined;
		} else if (flags & 32) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected();
		this._segments.length = 0;
		this._selectedSegmentState = 0;
		this._curves = undefined;
		if (segments && segments.length > 0)
			this._add(Segment.readAll(segments));
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(25);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords, false);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine)
						parts.push('l' + f.pair(curX - prevX, curY - prevY));
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							+ ' ' + f.pair(inX - prevX, inY - prevY)
							+ ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (length === 0)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	}
}, {

	isEmpty: function() {
		return this._segments.length === 0;
	},

	isPolygon: function() {
		for (var i = 0, l = this._segments.length; i < l; i++) {
			if (!this._segments[i].isLinear())
				return false;
		}
		return true;
	},

	_transformContent: function(matrix) {
		var coords = new Array(6);
		for (var i = 0, l = this._segments.length; i < l; i++)
			this._segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selectionState)
				this._updateSelection(segment, 0, segment._selectionState);
		}
		if (append) {
			segments.push.apply(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves || segs._curves) {
			if (!curves)
				curves = this._curves = [];
			var from = index > 0 ? index - 1 : index,
				start = from,
				to = Math.min(from + amount, this._countCurves());
			if (segs._curves) {
				curves.splice.apply(curves, [from, 0].concat(segs._curves));
				start += segs._curves.length;
			}
			for (var i = start; i < to; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(from, to);
		}
		this._changed(25);
		return segs;
	},

	_adjustCurves: function(from, to) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = from; i < to; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && from === 0 ? segments.length - 1
				: from - 1]) {
			curve._segment2 = segments[from] || segments[0];
			curve._changed();
		}
		if (curve = curves[to]) {
			curve._segment1 = segments[to];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readAll(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readAll(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(from, to, _includeCurves) {
		from = from || 0;
		to = Base.pick(to, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(from, to - from),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selectionState)
				this._updateSelection(segment, segment._selectionState, 0);
			segment._index = segment._path = null;
		}
		for (var i = from, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = from > 0 && to === count + (this._closed ? 1 : 0)
					? from - 1
					: from,
				curves = curves.splice(index, amount);
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(25);
		return removed;
	},

	clear: '#removeSegments',

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves();
			this._length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				this._length += curves[i].getLength();
		}
		return this._length;
	},

	getArea: function() {
		var curves = this.getCurves();
		var area = 0;
		for (var i = 0, l = curves.length; i < l; i++)
			area += curves[i].getArea();
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this._selected && length > 0 && this._selectedSegmentState
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelected: function setSelected(selected) {
		if (!selected)
			this._selectSegments(false);
		setSelected.base.call(this, selected);
	},

	_selectSegments: function(selected) {
		var length = this._segments.length;
		this._selectedSegmentState = selected
				? length * 7 : 0;
		for (var i = 0; i < length; i++)
			this._segments[i]._selectionState = selected
					? 7 : 0;
	},

	_updateSelection: function(segment, oldState, newState) {
		segment._selectionState = newState;
		var total = this._selectedSegmentState += newState - oldState;
		if (total > 0)
			this.setSelected(true);
	},

	flatten: function(maxDistance) {
		var iterator = new PathIterator(this, 64, 0.1),
			pos = 0,
			step = iterator.length / Math.ceil(iterator.length / maxDistance),
			end = iterator.length + (this._closed ? -step : step) / 2;
		var segments = [];
		while (pos <= end) {
			segments.push(new Segment(iterator.evaluate(pos, 0)));
			pos += step;
		}
		this.setSegments(segments);
	},

	reduce: function() {
		var curves = this.getCurves();
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (curve.isLinear() && curve.getLength() === 0)
				curve.remove();
		}
		return this;
	},

	simplify: function(tolerance) {
		if (this._segments.length > 2) {
			var fitter = new PathFitter(this, tolerance || 2.5);
			this.setSegments(fitter.fit());
		}
	},

	split: function(index, parameter) {
		if (parameter === null)
			return;
		if (arguments.length === 1) {
			var arg = index;
			if (typeof arg === 'number')
				arg = this.getLocationAt(arg);
			index = arg.index;
			parameter = arg.parameter;
		}
		var tolerance = 0.00001;
		if (parameter >= 1 - tolerance) {
			index++;
			parameter--;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (parameter > tolerance) {
				curves[index++].divide(parameter, true);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else if (index > 0) {
				path = this._clone(new Path().insertAbove(this, true));
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	isClockwise: function() {
		if (this._clockwise !== undefined)
			return this._clockwise;
		return Path.isClockwise(this._segments);
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
		this._clockwise = clockwise;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		if (this._clockwise !== undefined)
			this._clockwise = !this._clockwise;
		this._changed(9);
	},

	join: function(path) {
		if (path) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (last1._point.equals(last2._point))
				path.reverse();
			var first1,
				first2 = path.getFirstSegment();
			if (last1._point.equals(first2._point)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				first1 = this.getFirstSegment();
				if (first1._point.equals(first2._point))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1._point.equals(last2._point)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path.closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.equals(last._point)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isColinear(i, j) {
			return segments[i].isColinear(segments[j]);
		}

		function isOrthogonal(i) {
			return segments[i].isOrthogonal();
		}

		function isArc(i) {
			return segments[i].isArc();
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (this.isPolygon() && segments.length === 4
				&& isColinear(0, 2) && isColinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isColinear(1, 5) && isColinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			shape.setStyle(this._style);
			if (insert || insert === undefined)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	_hitTestSelf: function(point, options) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			radius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (radius !== null) {
			if (radius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = radius * style.getMiterLimit();
				strokePadding = tolerancePadding.add(new Point(radius, radius));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			if (join !== 'round' || cap !== 'round') {
				area = new Path({ internal: true, closed: true });
				if (closed || segment._index > 0
						&& segment._index < numSegments - 1) {
					if (join !== 'round' && (segment._handleIn.isZero()
							|| segment._handleOut.isZero()))
						Path._addBevelJoin(segment, join, radius, miterLimit,
								addToArea, true);
				} else if (cap !== 'round') {
					Path._addSquareCap(segment, cap, radius, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
			return isCloseEnough(segment._point, strokePadding);
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (radius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var parameter = loc.getParameter();
				if (parameter === 0 || parameter === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point) <= miterLimit
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var loc = this.getLocationAt(offset, isParameter);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	_getOffset: function(location) {
		var index = location && location.getIndex();
		if (index != null) {
			var curves = this.getCurves(),
				offset = 0;
			for (var i = 0; i < index; i++)
				offset += curves[i].getLength();
			var curve = curves[index],
				parameter = location.getParameter();
			if (parameter > 0)
				offset += curve.getPartLength(0, parameter);
			return offset;
		}
		return null;
	},

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset, isParameter) {
		var curves = this.getCurves(),
			length = 0;
		if (isParameter) {
			var index = ~~offset;
			return curves[index].getLocationAt(offset - index, true);
		}
		for (var i = 0, l = curves.length; i < l; i++) {
			var start = length,
				curve = curves[i];
			length += curve.getLength();
			if (length > offset) {
				return curve.getLocationAt(offset - start);
			}
		}
		if (offset <= this.getLength())
			return new CurveLocation(curves[curves.length - 1], 1);
		return null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}
}), new function() {

	function drawHandles(ctx, segments, matrix, size) {
		var half = size / 2;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		var coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			var state = segment._selectionState,
				pX = coords[0],
				pY = coords[1];
			if (state & 1)
				drawHandle(2);
			if (state & 2)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (!(state & 4)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (!dontStart && this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
				if (!dontStart)
					this._currentPath = ctx.currentPath;
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var iterator = new PathIterator(this, 32, 0.25,
								strokeMatrix),
							length = iterator.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								iterator.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
}, new function() {

	function getFirstControlPoints(rhs) {
		var n = rhs.length,
			x = [],
			tmp = [],
			b = 2;
		x[0] = rhs[0] / b;
		for (var i = 1; i < n; i++) {
			tmp[i] = 1 / b;
			b = (i < n - 1 ? 4 : 2) - tmp[i];
			x[i] = (rhs[i] - x[i - 1]) / b;
		}
		for (var i = 1; i < n; i++) {
			x[n - i - 1] -= tmp[n - i] * x[n - i];
		}
		return x;
	}

	return {
		smooth: function() {
			var segments = this._segments,
				size = segments.length,
				closed = this._closed,
				n = size,
				overlap = 0;
			if (size <= 2)
				return;
			if (closed) {
				overlap = Math.min(size, 4);
				n += Math.min(size, overlap) * 2;
			}
			var knots = [];
			for (var i = 0; i < size; i++)
				knots[i + overlap] = segments[i]._point;
			if (closed) {
				for (var i = 0; i < overlap; i++) {
					knots[i] = segments[i + size - overlap]._point;
					knots[i + size + overlap] = segments[i]._point;
				}
			} else {
				n--;
			}
			var rhs = [];

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
			rhs[0] = knots[0]._x + 2 * knots[1]._x;
			rhs[n - 1] = 3 * knots[n - 1]._x;
			var x = getFirstControlPoints(rhs);

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
			rhs[0] = knots[0]._y + 2 * knots[1]._y;
			rhs[n - 1] = 3 * knots[n - 1]._y;
			var y = getFirstControlPoints(rhs);

			if (closed) {
				for (var i = 0, j = size; i < overlap; i++, j++) {
					var f1 = i / overlap,
						f2 = 1 - f1,
						ie = i + overlap,
						je = j + overlap;
					x[j] = x[i] * f1 + x[j] * f2;
					y[j] = y[i] * f1 + y[j] * f2;
					x[je] = x[ie] * f2 + x[je] * f1;
					y[je] = y[ie] * f2 + y[je] * f1;
				}
				n--;
			}
			var handleIn = null;
			for (var i = overlap; i <= n - overlap; i++) {
				var segment = segments[i - overlap];
				if (handleIn)
					segment.setHandleIn(handleIn.subtract(segment._point));
				if (i < n) {
					segment.setHandleOut(
							new Point(x[i], y[i]).subtract(segment._point));
					handleIn = i < n - 1
							? new Point(
								2 * knots[i + 1]._x - x[i + 1],
								2 * knots[i + 1]._y - y[i + 1])
							: new Point(
								(knots[n]._x + x[n - 1]) / 2,
								(knots[n]._y + y[n - 1]) / 2);
				}
			}
			if (closed && handleIn) {
				var segment = this._segments[0];
				segment.setHandleIn(handleIn.subtract(segment._point));
			}
		}
	};
}, new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (segments.length === 0)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else {
				var radius = Size.read(arguments);
				if (radius.isZero())
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					abs = Math.abs,
					EPSILON = 1e-11,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq =  x * x,
					ySq =  y * y;
				var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < EPSILON)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1)
							* Math.sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center);
				if (centerSide === 0) {
					extent = throughSide * Math.abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			var ext = Math.abs(extent),
				count = ext >= 360 ? 4 : Math.ceil(ext / 90),
				inc = extent / count,
				half = inc * Math.PI / 360,
				z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
				segments = [];
			for (var i = 0; i <= count; i++) {
				var pt = to,
					out = null;
				if (i < count) {
					out = vector.rotate(90).multiply(z);
					if (matrix) {
						pt = matrix._transformPoint(vector);
						out = matrix._transformPoint(vector.add(out))
								.subtract(pt);
					} else {
						pt = center.add(vector);
					}
				}
				if (i === 0) {
					current.setHandleOut(out);
				} else {
					var _in = vector.rotate(-90).multiply(z);
					if (matrix) {
						_in = matrix._transformPoint(vector.add(_in))
								.subtract(pt);
					}
					segments.push(new Segment(pt, _in, out));
				}
				vector = vector.rotate(inc);
			}
			this._add(segments);
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(join) {
			this.setClosed(true);
			if (join)
				this.join();
		}
	};
}, {

	_getBounds: function(getter, matrix) {
		return Path[getter](this._segments, this._closed, this.getStyle(),
				matrix);
	},

statics: {
	isClockwise: function(segments) {
		var sum = 0;
		for (var i = 0, l = segments.length; i < l; i++) {
			var v = Curve.getValues(
					segments[i], segments[i + 1 < l ? i + 1 : 0]);
			for (var j = 2; j < 8; j += 2)
				sum += (v[j - 2] - v[j]) * (v[j + 1] + v[j - 1]);
		}
		return sum > 0;
	},

	getBounds: function(segments, closed, style, matrix, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6), false),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords, false);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, style, matrix) {
		if (!style.hasStroke())
			return Path.getBounds(segments, closed, style, matrix);
		var length = segments.length - (closed ? 0 : 1),
			radius = style.getStrokeWidth() / 2,
			padding = Path._getPenPadding(radius, matrix),
			bounds = Path.getBounds(segments, closed, style, matrix, padding),
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = radius * style.getMiterLimit();
		var joinBounds = new Rectangle(new Size(padding).multiply(2));

		function add(point) {
			bounds = bounds.include(matrix
				? matrix._transformPoint(point, point) : point);
		}

		function addRound(segment) {
			bounds = bounds.unite(joinBounds.setCenter(matrix
				? matrix._transformPoint(segment._point) : segment._point));
		}

		function addJoin(segment, join) {
			var handleIn = segment._handleIn,
				handleOut = segment._handleOut;
			if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
					&& handleIn.isColinear(handleOut)) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, radius, miterLimit, add);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, radius, add);
			}
		}

		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getPenPadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var mx = matrix.shiftless(),
			hor = mx.transform(new Point(radius, 0)),
			ver = mx.transform(new Point(0, radius)),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = -Math.atan(b * tan / a),
			ty = Math.atan(b / (tan * a));
		return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPointAt(0, true),
			normal1 = curve1.getNormalAt(1, true),
			normal2 = curve2.getNormalAt(0, true),
			step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
		normal1.setLength(step);
		normal2.setLength(step);
		if (area) {
			addPoint(point);
			addPoint(point.add(normal1));
		}
		if (join === 'miter') {
			var corner = new Line(
					point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(
					point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit) {
				addPoint(corner);
				if (!area)
					return;
			}
		}
		if (!area)
			addPoint(point.add(normal1));
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, addPoint, area) {
		var point = segment._point,
			loc = segment.getLocation(),
			normal = loc.getNormal().normalize(radius);
		if (area) {
			addPoint(point.subtract(normal));
			addPoint(point.add(normal));
		}
		if (cap === 'square')
			point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, style, matrix, strokePadding,
			joinPadding) {
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			for (var j = 0; j < 6; j += 2) {
				var padding = j === 0 ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	getRoughBounds: function(segments, closed, style, matrix) {
		var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
			joinRadius = strokeRadius;
		if (strokeRadius > 0) {
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
		}
		return Path.getHandleBounds(segments, closed, style, matrix,
				Path._getPenPadding(strokeRadius, matrix),
				Path._getPenPadding(joinRadius, matrix));
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert === false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props);
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert === false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = !(sides % 3),
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items, _preserve) {
		items = insertChildren.base.call(this, index, items, _preserve, Path);
		for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
			var item = items[i];
			if (item._clockwise === undefined)
				item.setClockwise(item._index === 0);
		}
		return items;
	},

	reverse: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].reverse();
	},

	smooth: function() {
		for (var i = 0, l = this._children.length; i < l; i++)
			this._children[i].smooth();
	},

	isClockwise: function() {
		var child = this.getFirstChild();
		return child && child.isClockwise();
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() !== !!clockwise)
			this.reverse();
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++)
			curves.push.apply(curves, children[i].getCurves());
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getFirstCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.chain(mx) : mx, _precision));
		}
		return paths.join(' ');
	}
}, {
	_getChildHitTestOptions: function(options) {
		return options.class === Path || options.type === 'path'
				? options
				: new Base(options, { fill: false });
	},

	_draw: function(ctx, param, strokeMatrix) {
		var children = this._children;
		if (children.length === 0)
			return;

		if (this._currentPath) {
			ctx.currentPath = this._currentPath;
		} else {
			param = param.extend({ dontStart: true, dontFinish: true });
			ctx.beginPath();
			for (var i = 0, l = children.length; i < l; i++)
				children[i].draw(ctx, param, strokeMatrix);
			this._currentPath = ctx.currentPath;
		}

		if (!param.clip) {
			this._setStyles(ctx);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectedItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectedItems[child._id])
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.chain(mx));
		}
	}
}, new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && children.length === 0)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	var fields = {
		moveTo: function() {
			var current = getCurrentPath(this),
				path = current && current.isEmpty() ? current : new Path();
			if (path !== current)
				this.addChild(path);
			path.moveTo.apply(path, arguments);
		},

		moveBy: function() {
			var current = getCurrentPath(this, true),
				last = current && current.getLastSegment(),
				point = Point.read(arguments);
			this.moveTo(last ? point.add(last._point) : point);
		},

		closePath: function(join) {
			getCurrentPath(this, true).closePath(join);
		}
	};

	Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
			'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
			function(key) {
				fields[key] = function() {
					var path = getCurrentPath(this, true);
					path[key].apply(path, arguments);
				};
			}
	);

	return fields;
});

PathItem.inject(new function() {
	function computeBoolean(path1, path2, operator, subtract) {
		function preparePath(path) {
			return path.clone(false).reduce().reorient().transform(null, true);
		}

		var _path1 = preparePath(path1),
			_path2 = path2 && path1 !== path2 && preparePath(path2);
		if (!_path1.isClockwise())
			_path1.reverse();
		if (_path2 && !(subtract ^ _path2.isClockwise()))
			_path2.reverse();
		splitPath(_path1.getIntersections(_path2, null, true));

		var chain = [],
			windings = [],
			lengths = [],
			segments = [],
			monoCurves = [];

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				segments.push.apply(segments, path._segments);
				monoCurves.push.apply(monoCurves, path._getMonoCurves());
			}
		}

		collect(_path1._children || [_path1]);
		if (_path2)
			collect(_path2._children || [_path2]);
		segments.sort(function(a, b) {
			var _a = a._intersection,
				_b = b._intersection;
			return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
		});
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			if (segment._winding != null)
				continue;
			chain.length = windings.length = lengths.length = 0;
			var totalLength = 0,
				startSeg = segment;
			do {
				chain.push(segment);
				lengths.push(totalLength += segment.getCurve().getLength());
				segment = segment.getNext();
			} while (segment && !segment._intersection && segment !== startSeg);
			for (var j = 0; j < 3; j++) {
				var length = totalLength * Math.random(),
					amount = lengths.length,
					k = 0;
				do {
					if (lengths[k] >= length) {
						if (k > 0)
							length -= lengths[k - 1];
						break;
					}
				} while (++k < amount);
				var curve = chain[k].getCurve(),
					point = curve.getPointAt(length),
					hor = curve.isHorizontal(),
					path = curve._path;
				if (path._parent instanceof CompoundPath)
					path = path._parent;
				windings[j] = subtract && _path2
						&& (path === _path1 && _path2._getWinding(point, hor)
						|| path === _path2 && !_path1._getWinding(point, hor))
						? 0
						: getWinding(point, monoCurves, hor);
			}
			windings.sort();
			var winding = windings[1];
			for (var j = chain.length - 1; j >= 0; j--)
				chain[j]._winding = winding;
		}
		var result = new CompoundPath();
		result.addChildren(tracePaths(segments, operator), true);
		_path1.remove();
		if (_path2)
			_path2.remove();
		result = result.reduce();
		result.setStyle(path1._style);
		return result;
	}

	function splitPath(intersections) {
		var TOLERANCE = 0.00001,
			linearSegments;

		function resetLinear() {
			for (var i = 0, l = linearSegments.length; i < l; i++) {
				var segment = linearSegments[i];
				segment._handleOut.set(0, 0);
				segment._handleIn.set(0, 0);
			}
		}

		for (var i = intersections.length - 1, curve, prevLoc; i >= 0; i--) {
			var loc = intersections[i],
				t = loc._parameter;
			if (prevLoc && prevLoc._curve === loc._curve
					&& prevLoc._parameter > 0) {
				t /= prevLoc._parameter;
			} else {
				if (linearSegments)
					resetLinear();
				curve = loc._curve;
				linearSegments = curve.isLinear() && [];
			}
			var newCurve,
				segment;
			if (newCurve = curve.divide(t, true, true)) {
				segment = newCurve._segment1;
				curve = newCurve.getPrevious();
			} else {
				segment = t < TOLERANCE
					? curve._segment1
					: t > 1 - TOLERANCE
						? curve._segment2
						: curve.getPartLength(0, t) < curve.getPartLength(t, 1)
							? curve._segment1
							: curve._segment2;
			}
			segment._intersection = loc.getIntersection();
			loc._segment = segment;
			if (linearSegments)
				linearSegments.push(segment);
			prevLoc = loc;
		}
		if (linearSegments)
			resetLinear();
	}

	function getWinding(point, curves, horizontal, testContains) {
		var TOLERANCE = 0.00001,
			x = point.x,
			y = point.y,
			windLeft = 0,
			windRight = 0,
			roots = [],
			abs = Math.abs,
			MAX = 1 - TOLERANCE;
		if (horizontal) {
			var yTop = -Infinity,
				yBottom = Infinity,
				yBefore = y - TOLERANCE,
				yAfter = y + TOLERANCE;
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if (Curve.solveCubic(values, 0, x, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--) {
						var y0 = Curve.evaluate(values, roots[j], 0).y;
						if (y0 < yBefore && y0 > yTop) {
							yTop = y0;
						} else if (y0 > yAfter && y0 < yBottom) {
							yBottom = y0;
						}
					}
				}
			}
			yTop = (yTop + y) / 2;
			yBottom = (yBottom + y) / 2;
			if (yTop > -Infinity)
				windLeft = getWinding(new Point(x, yTop), curves);
			if (yBottom < Infinity)
				windRight = getWinding(new Point(x, yBottom), curves);
		} else {
			var xBefore = x - TOLERANCE,
				xAfter = x + TOLERANCE;
			for (var i = 0, l = curves.length; i < l; i++) {
				var curve = curves[i],
					values = curve.values,
					winding = curve.winding,
					next = curve.next;
				if (winding && (winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
					&& Curve.solveCubic(values, 1, y, roots, 0,
						!next.winding && next.values[1] === y ? 1 : MAX) === 1){
					var t = roots[0],
						x0 = Curve.evaluate(values, t, 0).x,
						slope = Curve.evaluate(values, t, 1).y;
					if (abs(slope) < TOLERANCE && !Curve.isLinear(values)
							|| t < TOLERANCE && slope * Curve.evaluate(
								curve.previous.values, t, 1).y < 0) {
						if (testContains && x0 >= xBefore && x0 <= xAfter) {
							++windLeft;
							++windRight;
						}
					} else if (x0 <= xBefore) {
						windLeft += winding;
					} else if (x0 >= xAfter) {
						windRight += winding;
					}
				}
			}
		}
		return Math.max(abs(windLeft), abs(windRight));
	}

	function tracePaths(segments, operator, selfOp) {
		operator = operator || function() {
			return true;
		};
		var paths = [],
			ZERO = 1e-3,
			ONE = 1 - 1e-3;
		for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
			seg = startSeg = segments[i];
			if (seg._visited || !operator(seg._winding))
				continue;
			var path = new Path(Item.NO_INSERT),
				inter = seg._intersection,
				startInterSeg = inter && inter._segment,
				added = false,
				dir = 1;
			do {
				var handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn,
					interSeg;
				if (added && (!operator(seg._winding) || selfOp)
						&& (inter = seg._intersection)
						&& (interSeg = inter._segment)
						&& interSeg !== startSeg) {
					if (selfOp) {
						seg._visited = interSeg._visited;
						seg = interSeg;
						dir = 1;
					} else {
						var c1 = seg.getCurve();
						if (dir > 0)
							c1 = c1.getPrevious();
						var t1 = c1.getTangentAt(dir < 1 ? ZERO : ONE, true),
							c4 = interSeg.getCurve(),
							c3 = c4.getPrevious(),
							t3 = c3.getTangentAt(ONE, true),
							t4 = c4.getTangentAt(ZERO, true),
							w3 = t1.cross(t3),
							w4 = t1.cross(t4);
						if (w3 * w4 !== 0) {
							var curve = w3 < w4 ? c3 : c4,
								nextCurve = operator(curve._segment1._winding)
									? curve
									: w3 < w4 ? c4 : c3,
								nextSeg = nextCurve._segment1;
							dir = nextCurve === c3 ? -1 : 1;
							if (nextSeg._visited && seg._path !== nextSeg._path
										|| !operator(nextSeg._winding)) {
								dir = 1;
							} else {
								seg._visited = interSeg._visited;
								seg = interSeg;
								if (nextSeg._visited)
									dir = 1;
							}
						} else {
							dir = 1;
						}
					}
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
				}
				path.add(new Segment(seg._point, added && handleIn, handleOut));
				added = true;
				seg._visited = true;
				seg = dir > 0 ? seg.getNext() : seg. getPrevious();
			} while (seg && !seg._visited
					&& seg !== startSeg && seg !== startInterSeg
					&& (seg._intersection || operator(seg._winding)));
			if (seg && (seg === startSeg || seg === startInterSeg)) {
				path.firstSegment.setHandleIn((seg === startInterSeg
						? startInterSeg : seg)._handleIn);
				path.setClosed(true);
			} else {
				path.lastSegment._handleOut.set(0, 0);
			}
			if (path._segments.length >
					(path._closed ? path.isPolygon() ? 2 : 0 : 1))
				paths.push(path);
		}
		return paths;
	}

	return {
		_getWinding: function(point, horizontal, testContains) {
			return getWinding(point, this._getMonoCurves(),
					horizontal, testContains);
		},

		unite: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 1 || w === 0;
			}, false);
		},

		intersect: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 2;
			}, false);
		},

		subtract: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 1;
			}, true);
		},

		exclude: function(path) {
			return new Group([this.subtract(path), path.subtract(this)]);
		},

		divide: function(path) {
			return new Group([this.subtract(path), this.intersect(path)]);
		}
	};
});

Path.inject({
	_getMonoCurves: function() {
		var monoCurves = this._monoCurves,
			prevCurve;

		function insertCurve(v) {
			var y0 = v[1],
				y1 = v[7],
				curve = {
					values: v,
					winding: y0 === y1
						? 0
						: y0 > y1
							? -1
							: 1,
					previous: prevCurve,
					next: null
				};
			if (prevCurve)
				prevCurve.next = curve;
			monoCurves.push(curve);
			prevCurve = curve;
		}

		function handleCurve(v) {
			if (Curve.getLength(v) === 0)
				return;
			var y0 = v[1],
				y1 = v[3],
				y2 = v[5],
				y3 = v[7];
			if (Curve.isLinear(v)) {
				insertCurve(v);
			} else {
				var a = 3 * (y1 - y2) - y0 + y3,
					b = 2 * (y0 + y2) - 4 * y1,
					c = y1 - y0,
					TOLERANCE = 0.00001,
					roots = [];
				var count = Numerical.solveQuadratic(a, b, c, roots, TOLERANCE,
						1 - TOLERANCE);
				if (count === 0) {
					insertCurve(v);
				} else {
					roots.sort();
					var t = roots[0],
						parts = Curve.subdivide(v, t);
					insertCurve(parts[0]);
					if (count > 1) {
						t = (roots[1] - t) / (1 - t);
						parts = Curve.subdivide(parts[1], t);
						insertCurve(parts[0]);
					}
					insertCurve(parts[1]);
				}
			}
		}

		if (!monoCurves) {
			monoCurves = this._monoCurves = [];
			var curves = this.getCurves(),
				segments = this._segments;
			for (var i = 0, l = curves.length; i < l; i++)
				handleCurve(curves[i].getValues());
			if (!this._closed && segments.length > 1) {
				var p1 = segments[segments.length - 1]._point,
					p2 = segments[0]._point,
					p1x = p1._x, p1y = p1._y,
					p2x = p2._x, p2y = p2._y;
				handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
			}
			if (monoCurves.length > 0) {
				var first = monoCurves[0],
					last = monoCurves[monoCurves.length - 1];
				first.previous = last;
				last.next = first;
			}
		}
		return monoCurves;
	},

	getInteriorPoint: function() {
		var bounds = this.getBounds(),
			point = bounds.getCenter(true);
		if (!this.contains(point)) {
			var curves = this._getMonoCurves(),
				roots = [],
				y = point.y,
				xIntercepts = [];
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if ((curves[i].winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
						&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--)
						xIntercepts.push(Curve.evaluate(values, roots[j], 0).x);
				}
				if (xIntercepts.length > 1)
					break;
			}
			point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
		}
		return point;
	},

	reorient: function() {
		this.setClockwise(true);
		return this;
	}
});

CompoundPath.inject({
	_getMonoCurves: function() {
		var children = this._children,
			monoCurves = [];
		for (var i = 0, l = children.length; i < l; i++)
			monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
		return monoCurves;
	},

	reorient: function() {
		var children = this.removeChildren().sort(function(a, b) {
			return b.getBounds().getArea() - a.getBounds().getArea();
		});
		this.addChildren(children);
		var clockwise = children[0].isClockwise();
		for (var i = 1, l = children.length; i < l; i++) {
			var point = children[i].getInteriorPoint(),
				counters = 0;
			for (var j = i - 1; j >= 0; j--) {
				if (children[j].contains(point))
					counters++;
			}
			children[i].setClockwise(counters % 2 === 0 && clockwise);
		}
		return this;
	}
});

var PathIterator = Base.extend({
	_class: 'PathIterator',

	initialize: function(path, maxRecursion, tolerance, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minDifference = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, minT, maxT) {
			if ((maxT - minT) > minDifference
					&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {
				var split = Curve.subdivide(curve),
					halfT = (minT + maxT) / 2;
				computeParts(split[0], index, minT, halfT);
				computeParts(split[1], index, halfT, maxT);
			} else {
				var x = curve[6] - curve[0],
					y = curve[7] - curve[1],
					dist = Math.sqrt(x * x + y * y);
				if (dist > 0.00001) {
					length += dist;
					parts.push({
						offset: length,
						value: maxT,
						index: index
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2, segments[0]);

		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	getParameterAt: function(offset) {
		var i, j = this.index;
		for (;;) {
			i = j;
			if (j == 0 || this.parts[--j].offset < offset)
				break;
		}
		for (var l = this.parts.length; i < l; i++) {
			var part = this.parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = this.parts[i - 1];
				var prevVal = prev && prev.index == part.index ? prev.value : 0,
					prevLen = prev ? prev.offset : 0;
				return {
					value: prevVal + (part.value - prevVal)
						* (offset - prevLen) / (part.offset - prevLen),
					index: part.index
				};
			}
		}
		var part = this.parts[this.parts.length - 1];
		return {
			value: 1,
			index: part.index
		};
	},

	evaluate: function(offset, type) {
		var param = this.getParameterAt(offset);
		return Curve.evaluate(this.curves[param.index], param.value, type);
	},

	drawPart: function(ctx, from, to) {
		from = this.getParameterAt(from);
		to = this.getParameterAt(to);
		for (var i = from.index; i <= to.index; i++) {
			var curve = Curve.getPart(this.curves[i],
					i == from.index ? from.value : 0,
					i == to.index ? to.value : 1);
			if (i == from.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name, index) {
		this[name + 'At'] = function(offset) {
			return this.evaluate(offset, index);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path, error) {
		this.points = [];
		var segments = path._segments,
			prev;
		for (var i = 0, l = segments.length; i < l; i++) {
			var point = segments[i].point.clone();
			if (!prev || !prev.equals(point)) {
				this.points.push(point);
				prev = point;
			}
		}
		this.error = error;
	},

	fit: function() {
		var points = this.points,
			length = points.length;
		this.segments = length > 0 ? [new Segment(points[0])] : [];
		if (length > 1)
			this.fitCubic(0, length - 1,
				points[1].subtract(points[0]).normalize(),
				points[length - 2].subtract(points[length - 1]).normalize());
		return this.segments;
	},

	fitCubic: function(first, last, tan1, tan2) {
		if (last - first == 1) {
			var pt1 = this.points[first],
				pt2 = this.points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(this.error, this.error * this.error),
			split;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < this.error) {
				this.addCurve(curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var V1 = this.points[split - 1].subtract(this.points[split]),
			V2 = this.points[split].subtract(this.points[split + 1]),
			tanCenter = V1.add(V2).divide(2).normalize();
		this.fitCubic(first, split, tan1, tanCenter);
		this.fitCubic(split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(curve) {
		var prev = this.segments[this.segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		this.segments.push(
				new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-11,
			pt1 = this.points[first],
			pt2 = this.points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = this.points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1, alpha2;
		if (Math.abs(detC0C1) > epsilon) {
			var detC0X	= C[0][0] * X[1]	- C[1][0] * X[0],
				detXC1	= X[0]	  * C[1][1] - X[1]	  * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			if (Math.abs(c0) > epsilon) {
				alpha1 = alpha2 = X[0] / c0;
			} else if (Math.abs(c1) > epsilon) {
				alpha1 = alpha2 = X[1] / c1;
			} else {
				alpha1 = alpha2 = 0;
			}
		}

		var segLength = pt2.getDistance(pt1);
		epsilon *= segLength;
		if (alpha1 < epsilon || alpha2 < epsilon) {
			alpha1 = alpha2 = segLength / 3;
		}

		return [pt1, pt1.add(tan1.normalize(alpha1)),
				pt2.add(tan2.normalize(alpha2)), pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		if (Math.abs(df) < 0.00001)
			return u;
		return u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_boundsSelected: true,
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsGetter: 'getBounds',

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	_clone: function _clone(copy) {
		copy.setContent(this._content);
		return _clone.base.call(this, copy);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(265);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	clone: function(insert) {
		return this._clone(new PointText(Item.NO_INSERT), insert);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx) {
		if (!this._content)
			return;
		this._setStyles(ctx);
		var style = this._style,
			lines = this._lines,
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (style.hasFill()) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(getter, matrix) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var bounds = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		colorCache = {},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
			components;
		if (match) {
			components = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^rgba?\((.*)\)$/)) {
			components = match[1].split(',');
			for (var i = 0, l = components.length; i < l; i++) {
				var value = +components[i];
				components[i] = i < 3 ? value / 255 : value;
			}
		} else {
			var cached = colorCache[string];
			if (!cached) {
				if (!colorCtx) {
					colorCtx = CanvasProvider.getContext(1, 1);
					colorCtx.globalCompositeOperation = 'copy';
				}
				colorCtx.fillStyle = 'rgba(0,0,0,0)';
				colorCtx.fillStyle = string;
				colorCtx.fillRect(0, 0, 1, 1);
				var data = colorCtx.getImageData(0, 0, 1, 1).data;
				cached = colorCache[string] = [
					data[0] / 255,
					data[1] / 255,
					data[2] / 255
				];
			}
			components = cached.slice();
		}
		return components;
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = name === 'gradient'
					? function(value) {
						var current = this._components[0];
						value = Gradient.read(Array.isArray(value) ? value
								: arguments, 0, { readNull: true });
						if (current !== value) {
							if (current)
								current._removeOwner(this);
							if (value)
								value._addOwner(this);
						}
						return value;
					}
					: type === 'gradient'
						? function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
						: function(value) {
							return value == null || isNaN(value) ? 0 : value;
						};

			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				value = parser.call(this, value);
				if (value != null) {
					this._components[index] = value;
					this._changed();
				}
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var slice = Array.prototype.slice,
				args = arguments,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (this.__read)
						read = 1;
					args = slice.call(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (this.__read)
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					if (values.length > length)
						values = slice.call(values, 0, length);
				} else if (argType === 'string') {
					type = 'rgb';
					components = fromCSS(arg);
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type];
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && i === 0 && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (this.__read && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (type === 'gradient')
				this._id = Color._id = (Color._id || 0) + 1;
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (this.__read)
				this.__read = read;
		},

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner)
				this._owner._changed(65);
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this._alpha === col._alpha
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				canvasGradient;
			if (gradient._radial) {
				var radius = destination.getDistance(origin),
					highlight = components[3];
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i];
				canvasGradient.addColorStop(stop._rampPoint,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			}
		}
	});
}, new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

Base.each(Color._types, function(properties, type) {
	var ctor = this[Base.capitalize(type) + 'Color'] = function(arg) {
			var argType = arg != null && typeof arg,
				components = argType === 'object' && arg.length != null
					? arg
					: argType === 'string'
						? null
						: arguments;
			return components
					? new Color(type, components)
					: new Color(arg);
		};
	if (type.length == 3) {
		var acronym = type.toUpperCase();
		Color[acronym] = this[acronym + 'Color'] = ctor;
	}
}, Base.exports);

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = Gradient._id = (Gradient._id || 0) + 1;
		if (stops && this._set(stops))
			stops = radial = null;
		if (!this._stops)
			this.setStops(stops || ['white', 'black']);
		if (this._radial == null)
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
			this._owners[i]._changed();
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (this._owners.length === 0)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++)
			stops[i] = this._stops[i].clone();
		return new Gradient(stops);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (this.stops) {
			for (var i = 0, l = this._stops.length; i < l; i++)
				this._stops[i]._owner = undefined;
		}
		if (stops.length < 2)
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		this._stops = GradientStop.readAll(stops, 0, { clone: true });
		for (var i = 0, l = this._stops.length; i < l; i++) {
			var stop = this._stops[i];
			stop._owner = this;
			if (stop._defaultRamp)
				stop.setRampPoint(i / (l - 1));
		}
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class
				&& this._stops.length === gradient._stops.length) {
			for (var i = 0, l = this._stops.length; i < l; i++) {
				if (!this._stops[i].equals(gradient._stops[i]))
					return false;
			}
			return true;
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		if (arg0) {
			var color, rampPoint;
			if (arg1 === undefined && Array.isArray(arg0)) {
				color = arg0[0];
				rampPoint = arg0[1];
			} else if (arg0.color) {
				color = arg0.color;
				rampPoint = arg0.rampPoint;
			} else {
				color = arg0;
				rampPoint = arg1;
			}
			this.setColor(color);
			this.setRampPoint(rampPoint);
		}
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._rampPoint);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize([this._color, this._rampPoint], options, true,
				dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(65);
	},

	getRampPoint: function() {
		return this._rampPoint;
	},

	setRampPoint: function(rampPoint) {
		this._defaultRamp = rampPoint == null;
		this._rampPoint = rampPoint || 0;
		this._changed();
	},

	getColor: function() {
		return this._color;
	},

	setColor: function(color) {
		this._color = Color.read(arguments);
		if (this._color === color)
			this._color = color.clone();
		this._color._owner = this;
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._rampPoint == stop._rampPoint
				|| false;
	}
});

var Style = Base.extend(new function() {
	var defaults = {
		fillColor: undefined,
		strokeColor: undefined,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		windingRule: 'nonzero',
		shadowColor: undefined,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: undefined,
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		font: 'sans-serif',
		leading: null,
		justification: 'left'
	};

	var flags = {
		strokeWidth: 97,
		strokeCap: 97,
		strokeJoin: 97,
		strokeScaling: 105,
		miterLimit: 97,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	};

	var item = { beans: true },
		fields = {
			_defaults: defaults,
			_textDefaults: new Base(defaults, {
				fillColor: new Color()
			}),
			beans: true
		};

	Base.each(defaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children;
			if (children && children.length > 0
					&& !(owner instanceof CompoundPath)) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			} else {
				var old = this._values[key];
				if (old != value) {
					if (isColor) {
						if (old)
							old._owner = undefined;
						if (value && value.constructor === Color) {
							if (value._owner)
								value = value.clone();
							value._owner = owner;
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 65);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				value;
			if (!children || children.length === 0 || _dontMerge
					|| owner instanceof CompoundPath) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone)
						value = value.clone();
					this._values[key] = value;
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
						if (value && isColor)
							value._owner = owner;
					}
				}
				return value;
			}
			for (var i = 0, l = children.length; i < l; i++) {
				var childValue = children[i]._style[get]();
				if (i === 0) {
					value = childValue;
				} else if (!Base.equals(value, childValue)) {
					return undefined;
				}
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Item.inject(item);
	return fields;
}, {
	_class: 'Style',

	initialize: function Style(style, _owner, _project) {
		this._values = {};
		this._owner = _owner;
		this._project = _owner && _owner._project || _project || paper.project;
		if (_owner instanceof TextItem)
			this._defaults = this._textDefaults;
		if (style)
			this.set(style);
	},

	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		return style === this || style && this._class === style._class
				&& Base.equals(this._values, style._values)
				|| false;
	},

	hasFill: function() {
		return !!this.getFillColor();
	},

	hasStroke: function() {
		return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		return !!this.getShadowColor() && this.getShadowBlur() > 0;
	},

	getView: function() {
		return this._project.getView();
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		getPrefixed: function(el, name) {
			return handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.addEventListener(parts[i], func, false);
		}
	},

	remove: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.removeEventListener(parts[i], func, false);
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	},

	stop: function(event) {
		event.stopPropagation();
		event.preventDefault();
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = typeof window === 'object' &&
			DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		focused = true,
		timer;

	if ( typeof window === 'object' ) {
		DomEvent.add(window, {
			focus: function() {
				focused = true;
			},
			blur: function() {
				focused = false;
			}
		});
	}

	function handleCallbacks() {
		for (var i = callbacks.length - 1; i >= 0; i--) {
			var entry = callbacks[i],
				func = entry[0],
				el = entry[1];
			if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
					|| focused) && DomElement.isInView(el)) {
				callbacks.splice(i, 1);
				func();
			}
		}
		if (nativeRequest) {
			if (callbacks.length) {
				nativeRequest(handleCallbacks);
			} else {
				requested = false;
			}
		}
	}

	return function(callback, element) {
		callbacks.push([callback, element]);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		var size;
		if ( !noCanvas ) {
			if (!this._pixelRatio)
				this._pixelRatio = window.devicePixelRatio || 1;
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userSelect: none,
				touchAction: none,
				touchCallout: none,
				contentZooming: none,
				userDrag: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});
			if (PaperScope.hasAttribute(element, 'resize')) {
				var offset = DomElement.getOffset(element, true),
					that = this;
				size = DomElement.getViewportBounds(element)
						.getSize().subtract(offset);
				this._windowEvents = {
					resize: function() {
						if (!DomElement.isInvisible(element))
							offset = DomElement.getOffset(element, true);
						that.setViewSize(DomElement.getViewportBounds(element)
								.getSize().subtract(offset));
					}
				};
				DomEvent.add(window, this._windowEvents);
			} else {
				size = DomElement.getSize(element);
				if (size.isNaN() || size.isZero()) {
					var getSize = function(name) {
						return element[name]
								|| parseInt(element.getAttribute(name), 10);
					};
					size = new Size(getSize('width'), getSize('height'));
				}
			}
			this._setViewSize(size);
			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}

		} else {
			if (!this._pixelRatio)
				this._pixelRatio = 1;
			this._id = 'view-' + View._id++;
			size = new Size(element.width, element.height);
		}
		View._views.push(this);
		View._viewsById[this._id] = this;
		this._viewSize = size;
		(this._matrix = new Matrix())._owner = this;
		this._zoom = 1;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		if (this._project._view === this)
			this._project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: {
		onFrame: {
			install: function() {
				this.play();
			},

			uninstall: function() {
				this.pause();
			}
		},

		onResize: {}
	},

	_animate: false,
	_time: 0,
	_count: 0,

	_requestFrame: function() {
		var that = this;
		DomEvent.requestAnimationFrame(function() {
			that._requested = false;
			if (!that._animate)
				return;
			that._requestFrame();
			that._handleFrame();
		}, this._element);
		this._requested = true;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._before ? now - this._before : 0;
		this._before = now;
		this._handlingFrame = true;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
		this._handlingFrame = false;
		this.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_update: function() {
		this._project._needsUpdate = true;
		if (this._handlingFrame)
			return;
		if (this._animate) {
			this._handleFrame();
		} else {
			this.update();
		}
	},

	_changed: function(flags) {
		if (flags & 1)
			this._project._needsUpdate = true;
	},

	_transform: function(matrix) {
		this._matrix.concatenate(matrix);
		this._bounds = null;
		this._update();
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._viewSize.set(size.width, size.height);
		this._setViewSize(size);
		this._bounds = null;
		this.emit('resize', {
			size: size,
			delta: delta
		});
		this._update();
	},

	_setViewSize: function(size) {
		var element = this._element;
		element.width = size.width;
		element.height = size.height;
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.scrollBy(center.subtract(this.getCenter()));
	},

	getZoom: function() {
		return this._zoom;
	},

	setZoom: function(zoom) {
		this._transform(new Matrix().scale(zoom / this._zoom,
			this.getCenter()));
		this._zoom = zoom;
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	scrollBy: function() {
		this._transform(new Matrix().translate(Point.read(arguments).negate()));
	},

	play: function() {
		this._animate = true;
		if (!this._requested)
			this._requestFrame();
	},

	pause: function() {
		this._animate = false;
	},

	draw: function() {
		this.update();
	},

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	}

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (typeof element === 'string')
				element = document.getElementById(element);
			return new CanvasView(project, element);
		}
	}
}, new function() {
	if ( noCanvas ) {
		return;
	}

	var tool,
		prevFocus,
		tempFocus,
		dragging = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[target.getAttribute('id')];
	}

	function viewToProject(view, event) {
		return view.viewToProject(DomEvent.getOffset(event, view._element));
	}

	function updateFocus() {
		if (!View._focused || !View._focused.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				var view = View._views[i];
				if (view && view.isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, point, event) {
		view._handleEvent('mousemove', point, event);
		var tool = view._scope.tool;
		if (tool) {
			tool._handleEvent(dragging && tool.responds('mousedrag')
					? 'mousedrag' : 'mousemove', point, event);
		}
		view.update();
		return tool;
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {
		'selectstart dragstart': function(event) {
			if (dragging)
				event.preventDefault();
		}
	};

	var docEvents = {
		mouseout: function(event) {
			var view = View._focused,
				target = DomEvent.getRelatedTarget(event);
			if (view && (!target || target.nodeName === 'HTML'))
				handleMouseMove(view, viewToProject(view, event), event);
		},

		scroll: updateFocus
	};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event),
			point = viewToProject(view, event);
		dragging = true;
		view._handleEvent('mousedown', point, event);
		if (tool = view._scope.tool)
			tool._handleEvent('mousedown', point, event);
		view.update();
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!dragging) {
			var target = getView(event);
			if (target) {
				if (view !== target)
					handleMouseMove(view, viewToProject(view, event), event);
				prevFocus = view;
				view = View._focused = tempFocus = target;
			} else if (tempFocus && tempFocus === view) {
				view = View._focused = prevFocus;
				updateFocus();
			}
		}
		if (view) {
			var point = viewToProject(view, event);
			if (dragging || view.getBounds().contains(point))
				tool = handleMouseMove(view, point, event);
		}
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (!view || !dragging)
			return;
		var point = viewToProject(view, event);
		dragging = false;
		view._handleEvent('mouseup', point, event);
		if (tool)
			tool._handleEvent('mouseup', point, event);
		view.update();
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	return {
		_viewEvents: viewEvents,

		_handleEvent: function() {},

		statics: {
			updateFocus: updateFocus
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if ( !noCanvas ) {
			if (!(canvas instanceof HTMLCanvasElement)) {
				var size = Size.read(arguments);
				if (size.isZero())
					throw new Error(
							'Cannot create CanvasView with the provided argument: '
							+ [].slice.call(arguments, 1));
				canvas = CanvasProvider.getCanvas(size);
			}
			this._context = canvas.getContext('2d');
		}
		this._eventCounters = {};
		this._pixelRatio = 1;
		if (!noCanvas && !/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(this._context,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
	},

	_setViewSize: function(size) {
		var width = size.width,
			height = size.height,
			pixelRatio = this._pixelRatio,
			element = this._element,
			style = element.style;
		element.width = width * pixelRatio;
		element.height = height * pixelRatio;
		if (pixelRatio !== 1) {
			style.width = width + 'px';
			style.height = height + 'px';
			this._context.scale(pixelRatio, pixelRatio);
		}
	},

	getPixelSize: function(size) {
		var ctx = this._context,
			prevFont = ctx.font;
		ctx.font = size + ' serif';
		size = parseFloat(ctx.font);
		ctx.font = prevFont;
		return size;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		var project = this._project;
		if (!project || !project._needsUpdate)
			return false;
		var ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		project.draw(ctx, this._matrix, this._pixelRatio);
		project._needsUpdate = false;
		return true;
	}
}, new function() {

	var downPoint,
		lastPoint,
		overPoint,
		downItem,
		lastItem,
		overItem,
		dragItem,
		dblClick,
		clickTime;

	function callEvent(view, type, event, point, target, lastPoint) {
		var item = target,
			mouseEvent;

		function call(obj) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point, target,
							lastPoint ? point.subtract(lastPoint) : null);
				}
				if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
					event.preventDefault();
					return true;
				}
			}
		}

		while (item) {
			if (call(item))
				return true;
			item = item.getParent();
		}
		if (call(view))
			return true;
		return false;
	}

	return {
		_handleEvent: function(type, point, event) {
			if (!this._eventCounters[type])
				return;
			var project = this._project,
				hit = project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				item = hit && hit.item,
				stopped = false;
			switch (type) {
			case 'mousedown':
				stopped = callEvent(this, type, event, point, item);
				dblClick = lastItem == item && (Date.now() - clickTime < 300);
				downItem = lastItem = item;
				downPoint = lastPoint = overPoint = point;
				dragItem = !stopped && item;
				while (dragItem && !dragItem.responds('mousedrag'))
					dragItem = dragItem._parent;
				break;
			case 'mouseup':
				stopped = callEvent(this, type, event, point, item, downPoint);
				if (dragItem) {
					if (lastPoint && !lastPoint.equals(point))
						callEvent(this, 'mousedrag', event, point, dragItem,
								lastPoint);
					if (item !== dragItem) {
						overPoint = point;
						callEvent(this, 'mousemove', event, point, item,
								overPoint);
					}
				}
				if (!stopped && item && item === downItem) {
					clickTime = Date.now();
					callEvent(this, dblClick && downItem.responds('doubleclick')
							? 'doubleclick' : 'click', event, downPoint, item);
					dblClick = false;
				}
				downItem = dragItem = null;
				break;
			case 'mousemove':
				if (dragItem)
					stopped = callEvent(this, 'mousedrag', event, point,
							dragItem, lastPoint);
				if (!stopped) {
					if (item !== overItem)
						overPoint = point;
					stopped = callEvent(this, type, event, point, item,
							overPoint);
				}
				lastPoint = overPoint = point;
				if (item !== overItem) {
					callEvent(this, 'mouseleave', event, point, overItem);
					overItem = item;
					callEvent(this, 'mouseenter', event, point, item);
				}
				break;
			}
			return stopped;
		}
	};
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
	},

	isPrevented: false,
	isStopped: false,

	preventDefault: function() {
		this.isPrevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.isStopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(down, key, character, event) {
		Event.call(this, event);
		this.type = down ? 'keydown' : 'keyup';
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {
	if ( noCanvas ) {
		return;
	}

	var specialKeys = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'control',
		18: 'option',
		19: 'pause',
		20: 'caps-lock',
		27: 'escape',
		32: 'space',
		35: 'end',
		36: 'home',
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down',
		46: 'delete',
		91: 'command',
		93: 'command',
		224: 'command'
	},

	specialChars = {
		9: true,
		13: true,
		32: true
	},

	modifiers = new Base({
		shift: false,
		control: false,
		option: false,
		command: false,
		capsLock: false,
		space: false
	}),

	charCodeMap = {},
	keyMap = {},
	downCode;

	function handleKey(down, keyCode, charCode, event) {
		var character = charCode ? String.fromCharCode(charCode) : '',
			specialKey = specialKeys[keyCode],
			key = specialKey || character.toLowerCase(),
			type = down ? 'keydown' : 'keyup',
			view = View._focused,
			scope = view && view.isVisible() && view._scope,
			tool = scope && scope.tool,
			name;
		keyMap[key] = down;
		if (specialKey && (name = Base.camelize(specialKey)) in modifiers)
			modifiers[name] = down;
		if (down) {
			charCodeMap[keyCode] = charCode;
		} else {
			delete charCodeMap[keyCode];
		}
		if (tool && tool.responds(type)) {
			paper = scope;
			tool.emit(type, new KeyEvent(down, key, character, event));
			if (view)
				view.update();
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var code = event.which || event.keyCode;
			if (code in specialKeys || modifiers.command) {
				handleKey(true, code,
						code in specialChars || modifiers.command ? code : 0,
						event);
			} else {
				downCode = code;
			}
		},

		keypress: function(event) {
			if (downCode != null) {
				handleKey(true, downCode, event.which || event.keyCode, event);
				downCode = null;
			}
		},

		keyup: function(event) {
			var code = event.which || event.keyCode;
			if (code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		Event.call(this, event);
		this.type = type;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return /^mouse(down|up)$/.test(this.type)
				? this.tool._downCount
				: this.tool._count;
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
			'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onKeyDown', 'onKeyUp' ],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._firstMove = true;
		this._count = 0;
		this._downCount = 0;
		this._set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (this._minDistance != null && this._maxDistance != null
				&& this._minDistance > this._maxDistance) {
			this._maxDistance = this._minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && this._maxDistance != null
				&& this._maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = distance;
		this._maxDistance = distance;
	},

	_updateEvent: function(type, point, minDistance, maxDistance, start,
			needsChange, matchMaxDistance) {
		if (!start) {
			if (minDistance != null || maxDistance != null) {
				var minDist = minDistance != null ? minDistance : 0,
					vector = point.subtract(this._point),
					distance = vector.getLength();
				if (distance < minDist)
					return false;
				var maxDist = maxDistance != null ? maxDistance : 0;
				if (maxDist != 0) {
					if (distance > maxDist) {
						point = this._point.add(vector.normalize(maxDist));
					} else if (matchMaxDistance) {
						return false;
					}
				}
			}
			if (needsChange && point.equals(this._point))
				return false;
		}
		this._lastPoint = start && type == 'mousemove' ? point : this._point;
		this._point = point;
		switch (type) {
		case 'mousedown':
			this._lastPoint = this._downPoint;
			this._downPoint = this._point;
			this._downCount++;
			break;
		case 'mouseup':
			this._lastPoint = this._downPoint;
			break;
		}
		this._count = start ? 0 : this._count + 1;
		return true;
	},

	_fireEvent: function(type, event) {
		var sets = paper.project._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
		return this.responds(type)
				&& this.emit(type, new ToolEvent(this, type, event));
	},

	_handleEvent: function(type, point, event) {
		paper = this._scope;
		var called = false;
		switch (type) {
		case 'mousedown':
			this._updateEvent(type, point, null, null, true, false, false);
			called = this._fireEvent(type, event);
			break;
		case 'mousedrag':
			var needsChange = false,
				matchMaxDistance = false;
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, false, needsChange, matchMaxDistance)) {
				called = this._fireEvent(type, event) || called;
				needsChange = true;
				matchMaxDistance = true;
			}
			break;
		case 'mouseup':
			if (!point.equals(this._point)
					&& this._updateEvent('mousedrag', point, this.minDistance,
							this.maxDistance, false, false, false)) {
				called = this._fireEvent('mousedrag', event);
			}
			this._updateEvent(type, point, null, this.maxDistance, false,
					false, false);
			called = this._fireEvent(type, event) || called;
			this._updateEvent(type, point, null, null, true, false, false);
			this._firstMove = true;
			break;
		case 'mousemove':
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, this._firstMove, true, false)) {
				called = this._fireEvent(type, event) || called;
				this._firstMove = false;
			}
			break;
		}
		if (called)
			event.preventDefault();
		return called;
	}

});

var Http = {
	request: function(method, url, callback) {
		var xhr = new (window.ActiveXObject || XMLHttpRequest)(
					'Microsoft.XMLHTTP');
		xhr.open(method.toUpperCase(), url, true);
		if ('overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain');
		xhr.onreadystatechange = function() {
			if (xhr.readyState === 4) {
				var status = xhr.status;
				if (status === 0 || status === 200) {
					callback.call(xhr, xhr.responseText);
				} else {
					throw new Error('Could not load ' + url + ' (Error '
							+ status + ')');
				}
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if ( noCanvas ) {
			return { getContext: function() {} };
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
		}
		var ctx = canvas.getContext('2d');
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		return this.getCanvas(width, height).getContext('2d');
	},

	release: function(obj) {
		var canvas = obj.canvas ? obj.canvas : obj;
		canvas.getContext('2d').restore();
		this.canvases.push(canvas);
	}
};

var BlendMode = new function() {
	if ( noCanvas ) {
		return;
	}

	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	Base.each(modes, function(func, mode) {
		var darken = mode === 'darken',
			ok = false;
		ctx.save();
		try {
			ctx.fillStyle = darken ? '#300' : '#a00';
			ctx.fillRect(0, 0, 1, 1);
			ctx.globalCompositeOperation = mode;
			if (ctx.globalCompositeOperation === mode) {
				ctx.fillStyle = darken ? '#a00' : '#300';
				ctx.fillRect(0, 0, 1, 1);
				ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
			}
		} catch (e) {}
		ctx.restore();
		nativeModes[mode] = ok;
	});
	CanvasProvider.release(ctx);

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SVGStyles = Base.each({
	fillColor: ['fill', 'color'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

var SVGNamespaces = {
	href: 'http://www.w3.org/1999/xlink',
	xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
	var formatter;

	function setAttributes(node, attrs) {
		for (var key in attrs) {
			var val = attrs[key],
				namespace = SVGNamespaces[key];
			if (typeof val === 'number')
				val = formatter.number(val);
			if (namespace) {
				node.setAttributeNS(namespace, key, val);
			} else {
				node.setAttribute(key, val);
			}
		}
		return node;
	}

	function createElement(tag, attrs) {
		return setAttributes(
			document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
	}

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			matrix = matrix.shiftless();
			var point = matrix._inverseTransform(trans);
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
			trans = null;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed && !decomposed.shearing) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = createElement('g', attrs);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = createElement('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					setAttributes(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = item.toDataURL();
		return createElement('image', attrs);
	}

	function exportPath(item, options) {
		if (options.matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			type,
			attrs = getTransform(item._matrix);
		if (segments.length === 0)
			return null;
		if (item.isPolygon()) {
			if (segments.length >= 3) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for(i = 0, l = segments.length; i < l; i++)
					parts.push(formatter.point(segments[i]._point));
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var first = segments[0]._point,
					last = segments[segments.length - 1]._point;
				attrs.set({
					x1: first.x,
					y1: first.y,
					x2: last.x,
					y2: last.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return createElement(type, attrs);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return createElement(type, attrs);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return createElement('path', attrs);
	}

	function exportPlacedSymbol(item, options) {
		var attrs = getTransform(item._matrix, true),
			symbol = item.getSymbol(),
			symbolNode = getDefinition(symbol, 'symbol'),
			definition = symbol.getDefinition(),
			bounds = definition.getBounds();
		if (!symbolNode) {
			symbolNode = createElement('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			symbolNode.appendChild(exportSVG(definition, options));
			setDefinition(symbol, symbolNode, 'symbol');
		}
		attrs.href = '#' + symbolNode.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = formatter.number(bounds.width);
		attrs.height = formatter.number(bounds.height);
		return createElement('use', attrs);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin().transform(),
				destination = color.getDestination().transform(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					highlight = highlight.transform();
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = createElement(
					(radial ? 'radial' : 'linear') + 'Gradient', attrs);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha();
				attrs = {
					offset: stop._rampPoint,
					'stop-color': stopColor.toCSS(true)
				};
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(createElement('stop', attrs));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = createElement('text', getTransform(item._matrix, true));
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		PlacedSymbol: exportPlacedSymbol,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent();

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SVGStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				attrs[entry.attribute] = value == null
					? 'none'
					: type === 'number'
						? formatter.number(value)
						: type === 'color'
							? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array'
								? value.join(',')
								: type === 'lookup'
									? entry.toSVG[value]
									: value;
			}
		});

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return setAttributes(node, attrs);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-' + item._id];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + id;
		definitions.svgs[type + '-' + item._id] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = createElement('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(createElement('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data  !== '{}')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var layers = this.layers,
				view = this.getView(),
				size = view.getViewSize(),
				node = createElement('svg', {
					x: 0,
					y: 0,
					width: size.width,
					height: size.height,
					version: '1.1',
					xmlns: 'http://www.w3.org/2000/svg',
					'xmlns:xlink': 'http://www.w3.org/1999/xlink'
				}),
				parent = node,
				matrix = view._matrix;
			if (!matrix.isIdentity())
				parent = node.appendChild(
						createElement('g', getTransform(matrix)));
			for (var i = 0, l = layers.length; i < l; i++)
				parent.appendChild(exportSVG(layers[i], options, true));
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	function getValue(node, name, isString, allowNull) {
		var namespace = SVGNamespaces[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		if (value === 'null')
			value = null;
		return value == null
				? allowNull
					? null
					: isString
						? ''
						: 0
				: isString
					? value
					: parseFloat(value);
	}

	function getPoint(node, x, y, allowNull) {
		x = getValue(node, x, false, allowNull);
		y = getValue(node, y, false, allowNull);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull) {
		w = getValue(node, w, false, allowNull);
		h = getValue(node, h, false, allowNull);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none'
				? null
				: type === 'number'
					? parseFloat(value)
					: type === 'array'
						? value ? value.split(/[\s,]+/g).map(parseFloat) : []
						: type === 'color'
							? getDefinition(value) || value
							: type === 'lookup'
								? lookup[value]
								: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& (child = importSVG(childNode, options, false))
					&& !(child instanceof Symbol))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || type === 'defs') {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		var data = node.getAttribute('d'),
			param = { pathData: data };
		return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
				? new CompoundPath(param)
				: new Path(param);
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			isRadial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, isRadial);
		}
		var origin, destination, highlight;
		if (isRadial) {
			origin = getPoint(node, 'cx', 'cy');
			destination = origin.add(getValue(node, 'r'), 0);
			highlight = getPoint(node, 'fx', 'fy', true);
		} else {
			origin = getPoint(node, 'x1', 'y1');
			destination = getPoint(node, 'x2', 'y2');
		}
		applyAttributes(
			new Color(gradient, origin, destination, highlight), node);
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1) {
					var next = child.nextSibling;
					document.body.appendChild(child);
					var item = importSVG(child, options, isRoot);
					if (next) {
						node.insertBefore(child, next);
					} else {
						node.appendChild(child);
					}
					return item;
				}
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node, 'width', 'height');
				this.setSize(size);
				var center = this._matrix._transformPoint(
						getPoint(node, 'x', 'y').add(size.divide(2)));
				this.translate(center);
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new Symbol(importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node, 'x', 'y');
			return definition
					? definition instanceof Symbol
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			var point = getPoint(node, 'x', 'y'),
				size = getSize(node, 'width', 'height'),
				radius = getSize(node, 'rx', 'ry');
			return new Shape.Rectangle(new Rectangle(point, size), radius);
		},

		line: function(node) {
			return new Path.Line(getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node, 'x', 'y')
					.add(getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		}
	};

	function applyTransform(item, value, name, node) {
		var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
			matrix = new Matrix();
		for (var i = 0, l = transforms.length; i < l; i++) {
			var transform = transforms[i];
			if (!transform)
				break;
			var parts = transform.split(/\(\s*/),
				command = parts[0],
				v = parts[1].split(/[\s,]+/g);
			for (var j = 0, m = v.length; j < m; j++)
				v[j] = parseFloat(v[j]);
			switch (command) {
			case 'matrix':
				matrix.concatenate(
						new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
				break;
			case 'rotate':
				matrix.rotate(v[0], v[1], v[2]);
				break;
			case 'translate':
				matrix.translate(v[0], v[1]);
				break;
			case 'scale':
				matrix.scale(v);
				break;
			case 'skewX':
				matrix.skew(v[0], 0);
				break;
			case 'skewY':
				matrix.skew(0, v[0]);
				break;
			}
		}
		item.transform(matrix);
	}

	function applyOpacity(item, value, name) {
		var color = item[name === 'fill-opacity' ? 'getFillColor'
				: 'getStrokeColor']();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.each(SVGStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			item[entry.set](convertValue(value, entry.type, entry.fromSVG));
			if (entry.type === 'color' && item instanceof Shape) {
				var color = item[entry.get]();
				if (color)
					color.transform(new Matrix().translate(
							item.getPosition(true).negate()));
			}
		};
	}, {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			var percentage = value.match(/(.*)%$/);
			item.setRampPoint(percentage
					? percentage[1] / 100
					: parseFloat(value));
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, 'width', 'height', true);
			if (item instanceof Group) {
				var scale = size ? rect.getSize().divide(size) : 1,
					matrix = new Matrix().translate(rect.getPoint()).scale(scale);
				item.transform(matrix.inverted());
			} else if (item instanceof Symbol) {
				if (size)
					rect.setSize(size);
				var clip = getAttribute(node, 'overflow', styles) != 'visible',
					group = item._definition;
				if (clip && !rect.contains(group.getBounds())) {
					clip = new Shape.Rectangle(rect).transform(group._matrix);
					clip.setClipMask(true);
					group.addChild(clip);
				}
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value
				? undefined
				: value === 'none'
					? null
					: value;
	}

	function applyAttributes(item, node, isRoot) {
		var styles = {
			node: DomElement.getStyles(node) || {},
			parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
		};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			if (value !== undefined)
				item = Base.pick(apply(item, value, name, node, styles), item);
		});
		return item;
	}

	var definitions = {};
	function getDefinition(value) {
		var match = value && value.match(/\((?:#|)([^)']+)/);
		return match && definitions[match[1]];
	}

	function importSVG(source, options, isRoot) {
		if (!source)
			return null;
		if (!options) {
			options = {};
		} else if (typeof options === 'function') {
			options = { onLoad: options };
		}

		var node = source,
			scope = paper;

		function onLoadCallback(svg) {
			paper = scope;
			var item = importSVG(svg, options, isRoot),
				onLoad = options.onLoad,
				view = scope.project && scope.getView();
			if (onLoad)
				onLoad.call(this, item);
			view.update();
		}

		if (isRoot) {
			if (typeof source === 'string' && !/^.*</.test(source)) {
				node = document.getElementById(source);
				if (node) {
					source = null;
				} else {
					return Http.request('get', source, onLoadCallback);
				}
			} else if (typeof File !== 'undefined' && source instanceof File) {
				var reader = new FileReader();
				reader.onload = function() {
					onLoadCallback(reader.result);
				};
				return reader.readAsText(source);
			}
		}

		if (typeof source === 'string')
			node = new DOMParser().parseFromString(source, 'image/svg+xml');
		if (!node.nodeName)
			throw new Error('Unsupported SVG source: ' + source);
		var type = node.nodeName.toLowerCase(),
			importer = importers[type],
			item,
			data = node.getAttribute && node.getAttribute('data-paper-data'),
			settings = scope.settings,
			prevApplyMatrix = settings.applyMatrix;
		settings.applyMatrix = false;
		item = importer && importer(node, type, options, isRoot) || null;
		settings.applyMatrix = prevApplyMatrix;
		if (item) {
			if (type !== '#document' && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport;
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (isRoot)
			definitions = {};
		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return this.addChild(importSVG(node, options, true));
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, true);
		}
	});
};

paper = new (PaperScope.inject(Base.exports, {
	enumerable: true,
	Base: Base,
	Numerical: Numerical,
	Key: Key
}))();

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
};

}).call(this,require('_process'))
},{"_process":"/home/louisremi/Workspace/plumin.js/node_modules/browserify/node_modules/process/browser.js"}],"/home/louisremi/Workspace/plumin.js/src/Contour.js":[function(require,module,exports){
var paper = require('../node_modules/paper/dist/paper-core.js');

function Contour( args ) {
	paper.Path.prototype.constructor.call( this, args );

	this.nodes = this.segments;
}

Contour.prototype = Object.create(paper.Path.prototype);
Contour.prototype.constructor = Contour;

Contour.prototype.addNodes = paper.Path.prototype.addSegments;

Contour.prototype.prepareOT = function( path ) {
	path.commands.push({
		type: 'M',
		x: Math.round( this.firstSegment.point.x ) || 0,
		y: Math.round( this.firstSegment.point.y ) || 0
	});

	this.curves.forEach(function( curve ) {
		if ( curve.isLinear() ) {
			path.commands.push({
				type: 'L',
				x: Math.round( curve.point2.x ) || 0,
				y: Math.round( curve.point2.y ) || 0
			});

		} else {
			path.commands.push({
				type: 'C',
				x1: Math.round( curve.point1.x + curve.handle1.x ) || 0,
				y1: Math.round( curve.point1.y + curve.handle1.y ) || 0,
				x2: Math.round( curve.point2.x + curve.handle2.x ) || 0,
				y2: Math.round( curve.point2.y + curve.handle2.y ) || 0,
				x: Math.round( curve.point2.x ) || 0,
				y: Math.round( curve.point2.y ) || 0
			});
		}
	});

	return path;
};

module.exports = Contour;
},{"../node_modules/paper/dist/paper-core.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js"}],"/home/louisremi/Workspace/plumin.js/src/Font.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	Glyph = require('./Glyph.js');

function Font( args ) {
	if ( !args ) {
		args = {};
	}

	if ( !args.styleName ) {
		args.styleName = 'Regular';
	}

	if ( !args.unitsPerEm ) {
		args.unitsPerEm = 1024;
	}

	this.ot = new opentype.Font( args );

	this.glyphs = [];
	this.glyphMap = {};
	this.charMap = {};
	this.altMap = {};
	this._subset = false;

	this.addGlyph(new Glyph({
		name: '.notdef',
		unicode: 0
	}));
}

Font.prototype.addGlyph = function( glyph ) {
	this.glyphs.push( glyph );
	this.glyphMap[glyph.name] = glyph;

	// build the default cmap
	// if multiple glyphs share the same unicode, use the glyph where unicode and name are equal
	if ( !this.charMap[glyph.unicode] ||
			( glyph.name.length === 1 && glyph.name.charCodeAt(0) === glyph.unicode ) ) {

		this.charMap[glyph.unicode] = glyph;
	}

	// build the alternates map
	if ( !this.altMap[glyph.unicode] ) {
		this.altMap[glyph.unicode] = [];
	}
	this.altMap[glyph.unicode].push( glyph );

	return this;
};

Font.prototype.addGlyphs = function( glyphs ) {
	glyphs.forEach(function( glyph ) {
		this.addGlyph(glyph);

	}, this);

	return this;
};

Object.defineProperty( Font.prototype, 'subset', {
	get: function() {
		return this._subset;
	},
	set: function( set ) {
		if ( set === false ) {
			return ( this._subset = false );
		}

		return ( this._subset = (typeof set === 'string' ? set.split('') : set)
			.filter(function(e, i, arr) {
				return arr.lastIndexOf(e) === i;
			})
			.map(function(e) {
				return e.charCodeAt(0);
			})
			.sort()
		);
	}
});

Font.prototype.getGlyphSubset = function( set ) {
	if ( set !== undefined ) {
		this.subset = set;
	}

	// reuse last subset if possible
	if ( this._lastSubset && this._lastSubset[0] === ( this._subset || [] ).join() ) {
		return this._lastSubset[1];
	}

	// memoize last subset
	this._lastSubset = [
		( this._subset || [] ).join(),
		this.glyphs.filter(function( glyph ) {
			if ( this._subset === false && ( glyph.unicode !== false || glyph.unicodes.length ) ) {
				return true;
			}

			if ( this._subset.indexOf( glyph.unicode ) !== -1 ) {
				return true;
			}

			// TODO: handle multiple unicodes

			return false;
		}, this)
	];

	return this._lastSubset[1];
};

Font.prototype.prepareOT = function( set ) {
	this.ot.glyphs = this.getGlyphSubset( set ).map(function( glyph ) {
		return glyph.prepareOT();
	});

	return this;
};

if ( typeof window === 'object' && window.document ) {

	var _URL = window.URL || window.webkitURL,
		ruleIndex;
	Font.prototype.addToFonts = document.fonts ?
		// CSS font loading, lightning fast
		function( buffer ) {
			var fontface = new FontFace(
				this.ot.familyName,
				buffer || this.ot.toBuffer()
			);

			document.fonts.add( fontface );

			if ( this.lastFontFace ) {
				document.fonts.delete( this.lastFontFace );
			}

			this.lastFontFace = fontface;

			return this;
		}:
		function( buffer ) {
			var url = _URL.createObjectURL(
				new Blob(
					[ new DataView( buffer || this.ot.toBuffer() ) ],
					{type: 'font/opentype'}
				)
			);

			if ( ruleIndex ) {
				document.styleSheets[0].deleteRule( ruleIndex );
			}

			ruleIndex = document.styleSheets[0].insertRule(
				'@font-face { font-family: "' + this.ot.familyName + '"; src: url(' + url + '); }',
				ruleIndex || document.styleSheets[0].cssRules.length
			);

			return this;
		};

	Font.prototype.download = function( buffer ) {
		var reader = new FileReader();

		reader.onloadend = function() {
			window.location = reader.result;
		};

		reader.readAsDataURL(new Blob(
			[ new DataView( buffer || this.ot.toBuffer() ) ],
			{type: 'font/opentype'}
		));

		return this;
	};

}

module.exports = Font;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","./Glyph.js":"/home/louisremi/Workspace/plumin.js/src/Glyph.js"}],"/home/louisremi/Workspace/plumin.js/src/Glyph.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	paper = require('../node_modules/paper/dist/paper-core.js');

function Glyph( args ) {
	paper.Group.prototype.constructor.apply( this );

	if ( args.unicode === undefined ) {
		args.unicode = args.name.charCodeAt(0);
	}

	if ( typeof args.unicode === 'string' ) {
		args.unicode = args.unicode.charCodeAt(0);
	}

	this.name = args.name;
	this.unicode = args.unicode;

	this.ot = new opentype.Glyph( args );
	this.ot.path = new opentype.Path();

	this.contours = [];
	this.anchors = [];
	this.components = [];
	this.parentAnchors = [];
}

Glyph.prototype = Object.create(paper.Group.prototype);
Glyph.prototype.constructor = Glyph;

Glyph.prototype.addContour = function( item ) {
	this.addChild( item );
	this.contours.push( item );
	return this;
};

Glyph.prototype.addComponent = function( item ) {
	this.addChild( item );
	this.components.push( item );
	return this;
};

Glyph.prototype.addAnchor = function( item ) {
	this.anchors.push( item );
	return this;
};

Glyph.prototype.addParentAnchor = function( item ) {
	this.parentAnchors.push( item );
	return this;
};

Glyph.prototype.prepareOT = function( path ) {
	if ( !path ) {
		this.ot.path.commands = [];
		path = this.ot.path;
	}

	this.contours.forEach(function( contour ) {
		contour.prepareOT( this.ot.path );
	}, this);

	return this.ot;
};

module.exports = Glyph;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","../node_modules/paper/dist/paper-core.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js"}],"/home/louisremi/Workspace/plumin.js/src/Node.js":[function(require,module,exports){
var paper = require('../node_modules/paper/dist/paper-core.js');

Object.defineProperty( paper.Segment.prototype, 'x', {
	get: function() {
		return this.point.x;
	},
	set: function( value ) {
		this.point.x = value;
	}
});

Object.defineProperty( paper.Segment.prototype, 'y', {
	get: function() {
		return this.point.y;
	},
	set: function( value ) {
		this.point.y = value;
	}
});

module.exports = paper.Segment;
},{"../node_modules/paper/dist/paper-core.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js"}],"/home/louisremi/Workspace/plumin.js/src/plumin.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	paper = require('../node_modules/paper/dist/paper-core.js'),
	Font = require('./Font.js'),
	Glyph = require('./Glyph.js'),
	Contour = require('./Contour.js'),
	Node = require('./Node.js');

function plumin() {}

plumin.opentype = opentype;
plumin.paper = paper;
plumin.Font = Font;
plumin.Glyph = Glyph;
plumin.Contour = Contour;
plumin.Node = Node;
plumin.Point = paper.Point;
plumin.Matrix = paper.Matrix;
plumin.setup = paper.setup.bind(paper);

module.exports = plumin;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","../node_modules/paper/dist/paper-core.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js","./Contour.js":"/home/louisremi/Workspace/plumin.js/src/Contour.js","./Font.js":"/home/louisremi/Workspace/plumin.js/src/Font.js","./Glyph.js":"/home/louisremi/Workspace/plumin.js/src/Glyph.js","./Node.js":"/home/louisremi/Workspace/plumin.js/src/Node.js"}]},{},["/home/louisremi/Workspace/plumin.js/src/plumin.js"])("/home/louisremi/Workspace/plumin.js/src/plumin.js")
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9jaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvZHJhdy5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvZW5jb2RpbmcuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL2ZvbnQuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL2dseXBoLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9vcGVudHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3BhdGguanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvY2ZmLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvY21hcC5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dseWYuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9ncG9zLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvaGVhZC5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2hoZWEuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9obXR4LmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMva2Vybi5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2xvY2EuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9tYXhwLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvbmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL29zMi5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL3Bvc3QuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9zZm50LmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWNvcmUuanMiLCJzcmMvQ29udG91ci5qcyIsInNyYy9Gb250LmpzIiwic3JjL0dseXBoLmpzIiwic3JjL05vZGUuanMiLCJzcmMvcGx1bWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzU1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x6WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5NdXRhdGlvbk9ic2VydmVyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBbXTtcblxuICAgIGlmIChjYW5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVMaXN0ID0gcXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBxdWV1ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoaGlkZGVuRGl2LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5zZXRBdHRyaWJ1dGUoJ3llcycsICdubycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiLy8gUnVuLXRpbWUgY2hlY2tpbmcgb2YgcHJlY29uZGl0aW9ucy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIHByZWRpY2F0ZSBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZXhwb3J0cy5hcmd1bWVudCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcblxuLy8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gaXMgdHJ1ZS5cbi8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbmV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5hcmd1bWVudDtcbiIsIi8vIERyYXdpbmcgdXRpbGl0eSBmdW5jdGlvbnMuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gRHJhdyBhIGxpbmUgb24gdGhlIGdpdmVuIGNvbnRleHQgZnJvbSBwb2ludCBgeDEseTFgIHRvIHBvaW50IGB4Mix5MmAuXG5mdW5jdGlvbiBsaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5cbmV4cG9ydHMubGluZSA9IGxpbmU7XG4iLCIvLyBHbHlwaCBlbmNvZGluZ1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjZmZTdGFuZGFyZFN0cmluZ3MgPSBbXG4gICAgJy5ub3RkZWYnLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLCAnYW1wZXJzYW5kJywgJ3F1b3RlcmlnaHQnLFxuICAgICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLCAnemVybycsICdvbmUnLCAndHdvJyxcbiAgICAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJywgJ2VxdWFsJywgJ2dyZWF0ZXInLFxuICAgICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJyxcbiAgICAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JywgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLFxuICAgICdxdW90ZWxlZnQnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JyxcbiAgICAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLCAnZXhjbGFtZG93bicsICdjZW50JywgJ3N0ZXJsaW5nJyxcbiAgICAnZnJhY3Rpb24nLCAneWVuJywgJ2Zsb3JpbicsICdzZWN0aW9uJywgJ2N1cnJlbmN5JywgJ3F1b3Rlc2luZ2xlJywgJ3F1b3RlZGJsbGVmdCcsICdndWlsbGVtb3RsZWZ0JyxcbiAgICAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdlbmRhc2gnLCAnZGFnZ2VyJywgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICdwYXJhZ3JhcGgnLFxuICAgICdidWxsZXQnLCAncXVvdGVzaW5nbGJhc2UnLCAncXVvdGVkYmxiYXNlJywgJ3F1b3RlZGJscmlnaHQnLCAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLFxuICAgICdxdWVzdGlvbmRvd24nLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ2RpZXJlc2lzJywgJ3JpbmcnLFxuICAgICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsICdvZ29uZWsnLCAnY2Fyb24nLCAnZW1kYXNoJywgJ0FFJywgJ29yZGZlbWluaW5lJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLFxuICAgICdvcmRtYXNjdWxpbmUnLCAnYWUnLCAnZG90bGVzc2knLCAnbHNsYXNoJywgJ29zbGFzaCcsICdvZScsICdnZXJtYW5kYmxzJywgJ29uZXN1cGVyaW9yJywgJ2xvZ2ljYWxub3QnLCAnbXUnLFxuICAgICd0cmFkZW1hcmsnLCAnRXRoJywgJ29uZWhhbGYnLCAncGx1c21pbnVzJywgJ1Rob3JuJywgJ29uZXF1YXJ0ZXInLCAnZGl2aWRlJywgJ2Jyb2tlbmJhcicsICdkZWdyZWUnLCAndGhvcm4nLFxuICAgICd0aHJlZXF1YXJ0ZXJzJywgJ3R3b3N1cGVyaW9yJywgJ3JlZ2lzdGVyZWQnLCAnbWludXMnLCAnZXRoJywgJ211bHRpcGx5JywgJ3RocmVlc3VwZXJpb3InLCAnY29weXJpZ2h0JyxcbiAgICAnQWFjdXRlJywgJ0FjaXJjdW1mbGV4JywgJ0FkaWVyZXNpcycsICdBZ3JhdmUnLCAnQXJpbmcnLCAnQXRpbGRlJywgJ0NjZWRpbGxhJywgJ0VhY3V0ZScsICdFY2lyY3VtZmxleCcsXG4gICAgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjdW1mbGV4JywgJ0lkaWVyZXNpcycsICdJZ3JhdmUnLCAnTnRpbGRlJywgJ09hY3V0ZScsICdPY2lyY3VtZmxleCcsXG4gICAgJ09kaWVyZXNpcycsICdPZ3JhdmUnLCAnT3RpbGRlJywgJ1NjYXJvbicsICdVYWN1dGUnLCAnVWNpcmN1bWZsZXgnLCAnVWRpZXJlc2lzJywgJ1VncmF2ZScsICdZYWN1dGUnLFxuICAgICdZZGllcmVzaXMnLCAnWmNhcm9uJywgJ2FhY3V0ZScsICdhY2lyY3VtZmxleCcsICdhZGllcmVzaXMnLCAnYWdyYXZlJywgJ2FyaW5nJywgJ2F0aWxkZScsICdjY2VkaWxsYScsICdlYWN1dGUnLFxuICAgICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLCAnZWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyY3VtZmxleCcsICdpZGllcmVzaXMnLCAnaWdyYXZlJywgJ250aWxkZScsICdvYWN1dGUnLFxuICAgICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLCAnb2dyYXZlJywgJ290aWxkZScsICdzY2Fyb24nLCAndWFjdXRlJywgJ3VjaXJjdW1mbGV4JywgJ3VkaWVyZXNpcycsICd1Z3JhdmUnLFxuICAgICd5YWN1dGUnLCAneWRpZXJlc2lzJywgJ3pjYXJvbicsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICdkb2xsYXJvbGRzdHlsZScsICdkb2xsYXJzdXBlcmlvcicsXG4gICAgJ2FtcGVyc2FuZHNtYWxsJywgJ0FjdXRlc21hbGwnLCAncGFyZW5sZWZ0c3VwZXJpb3InLCAncGFyZW5yaWdodHN1cGVyaW9yJywgJzI2NiBmZicsICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJywgJ2ZvdXJvbGRzdHlsZScsICdmaXZlb2xkc3R5bGUnLCAnc2l4b2xkc3R5bGUnLFxuICAgICdzZXZlbm9sZHN0eWxlJywgJ2VpZ2h0b2xkc3R5bGUnLCAnbmluZW9sZHN0eWxlJywgJ2NvbW1hc3VwZXJpb3InLCAndGhyZWVxdWFydGVyc2VtZGFzaCcsICdwZXJpb2RzdXBlcmlvcicsXG4gICAgJ3F1ZXN0aW9uc21hbGwnLCAnYXN1cGVyaW9yJywgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICdpc3VwZXJpb3InLCAnbHN1cGVyaW9yJyxcbiAgICAnbXN1cGVyaW9yJywgJ25zdXBlcmlvcicsICdvc3VwZXJpb3InLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnZmYnLCAnZmZpJywgJ2ZmbCcsXG4gICAgJ3BhcmVubGVmdGluZmVyaW9yJywgJ3BhcmVucmlnaHRpbmZlcmlvcicsICdDaXJjdW1mbGV4c21hbGwnLCAnaHlwaGVuc3VwZXJpb3InLCAnR3JhdmVzbWFsbCcsICdBc21hbGwnLFxuICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJywgJ05zbWFsbCcsICdPc21hbGwnLCAnUHNtYWxsJywgJ1FzbWFsbCcsICdSc21hbGwnLCAnU3NtYWxsJywgJ1RzbWFsbCcsICdVc21hbGwnLCAnVnNtYWxsJywgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsICdZc21hbGwnLCAnWnNtYWxsJywgJ2NvbG9ubW9uZXRhcnknLCAnb25lZml0dGVkJywgJ3J1cGlhaCcsICdUaWxkZXNtYWxsJywgJ2V4Y2xhbWRvd25zbWFsbCcsXG4gICAgJ2NlbnRvbGRzdHlsZScsICdMc2xhc2hzbWFsbCcsICdTY2Fyb25zbWFsbCcsICdaY2Fyb25zbWFsbCcsICdEaWVyZXNpc3NtYWxsJywgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsXG4gICAgJ0RvdGFjY2VudHNtYWxsJywgJ01hY3JvbnNtYWxsJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLCAnT2dvbmVrc21hbGwnLCAnUmluZ3NtYWxsJywgJ0NlZGlsbGFzbWFsbCcsXG4gICAgJ3F1ZXN0aW9uZG93bnNtYWxsJywgJ29uZWVpZ2h0aCcsICd0aHJlZWVpZ2h0aHMnLCAnZml2ZWVpZ2h0aHMnLCAnc2V2ZW5laWdodGhzJywgJ29uZXRoaXJkJywgJ3R3b3RoaXJkcycsXG4gICAgJ3plcm9zdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJywgJ3NpeHN1cGVyaW9yJywgJ3NldmVuc3VwZXJpb3InLCAnZWlnaHRzdXBlcmlvcicsICduaW5lc3VwZXJpb3InLFxuICAgICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLCAndGhyZWVpbmZlcmlvcicsICdmb3VyaW5mZXJpb3InLCAnZml2ZWluZmVyaW9yJywgJ3NpeGluZmVyaW9yJyxcbiAgICAnc2V2ZW5pbmZlcmlvcicsICdlaWdodGluZmVyaW9yJywgJ25pbmVpbmZlcmlvcicsICdjZW50aW5mZXJpb3InLCAnZG9sbGFyaW5mZXJpb3InLCAncGVyaW9kaW5mZXJpb3InLFxuICAgICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJywgJ0FhY3V0ZXNtYWxsJywgJ0FjaXJjdW1mbGV4c21hbGwnLCAnQXRpbGRlc21hbGwnLCAnQWRpZXJlc2lzc21hbGwnLFxuICAgICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsICdFZ3JhdmVzbWFsbCcsICdFYWN1dGVzbWFsbCcsICdFY2lyY3VtZmxleHNtYWxsJywgJ0VkaWVyZXNpc3NtYWxsJyxcbiAgICAnSWdyYXZlc21hbGwnLCAnSWFjdXRlc21hbGwnLCAnSWNpcmN1bWZsZXhzbWFsbCcsICdJZGllcmVzaXNzbWFsbCcsICdFdGhzbWFsbCcsICdOdGlsZGVzbWFsbCcsICdPZ3JhdmVzbWFsbCcsXG4gICAgJ09hY3V0ZXNtYWxsJywgJ09jaXJjdW1mbGV4c21hbGwnLCAnT3RpbGRlc21hbGwnLCAnT2RpZXJlc2lzc21hbGwnLCAnT0VzbWFsbCcsICdPc2xhc2hzbWFsbCcsICdVZ3JhdmVzbWFsbCcsXG4gICAgJ1VhY3V0ZXNtYWxsJywgJ1VjaXJjdW1mbGV4c21hbGwnLCAnVWRpZXJlc2lzc21hbGwnLCAnWWFjdXRlc21hbGwnLCAnVGhvcm5zbWFsbCcsICdZZGllcmVzaXNzbWFsbCcsICcwMDEuMDAwJyxcbiAgICAnMDAxLjAwMScsICcwMDEuMDAyJywgJzAwMS4wMDMnLCAnQmxhY2snLCAnQm9sZCcsICdCb29rJywgJ0xpZ2h0JywgJ01lZGl1bScsICdSZWd1bGFyJywgJ1JvbWFuJywgJ1NlbWlib2xkJ107XG5cbnZhciBjZmZTdGFuZGFyZEVuY29kaW5nID0gW1xuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLCAnYW1wZXJzYW5kJywgJ3F1b3RlcmlnaHQnLFxuICAgICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLCAnemVybycsICdvbmUnLCAndHdvJyxcbiAgICAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJywgJ2VxdWFsJywgJ2dyZWF0ZXInLFxuICAgICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJyxcbiAgICAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JywgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLFxuICAgICdxdW90ZWxlZnQnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JyxcbiAgICAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLCAnZnJhY3Rpb24nLCAneWVuJywgJ2Zsb3JpbicsICdzZWN0aW9uJywgJ2N1cnJlbmN5JywgJ3F1b3Rlc2luZ2xlJyxcbiAgICAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICcnLCAnZW5kYXNoJywgJ2RhZ2dlcicsXG4gICAgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICcnLCAncGFyYWdyYXBoJywgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsXG4gICAgJ2d1aWxsZW1vdHJpZ2h0JywgJ2VsbGlwc2lzJywgJ3BlcnRob3VzYW5kJywgJycsICdxdWVzdGlvbmRvd24nLCAnJywgJ2dyYXZlJywgJ2FjdXRlJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLFxuICAgICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ2RpZXJlc2lzJywgJycsICdyaW5nJywgJ2NlZGlsbGEnLCAnJywgJ2h1bmdhcnVtbGF1dCcsICdvZ29uZWsnLCAnY2Fyb24nLFxuICAgICdlbWRhc2gnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJ0FFJywgJycsICdvcmRmZW1pbmluZScsICcnLCAnJywgJycsXG4gICAgJycsICdMc2xhc2gnLCAnT3NsYXNoJywgJ09FJywgJ29yZG1hc2N1bGluZScsICcnLCAnJywgJycsICcnLCAnJywgJ2FlJywgJycsICcnLCAnJywgJ2RvdGxlc3NpJywgJycsICcnLFxuICAgICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnXTtcblxudmFyIGNmZkV4cGVydEVuY29kaW5nID0gW1xuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnc3BhY2UnLCAnZXhjbGFtc21hbGwnLCAnSHVuZ2FydW1sYXV0c21hbGwnLCAnJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAndHdvZG90ZW5sZWFkZXInLCAnb25lZG90ZW5sZWFkZXInLFxuICAgICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ2ZyYWN0aW9uJywgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJyxcbiAgICAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsICdzZXZlbm9sZHN0eWxlJywgJ2VpZ2h0b2xkc3R5bGUnLCAnbmluZW9sZHN0eWxlJywgJ2NvbG9uJyxcbiAgICAnc2VtaWNvbG9uJywgJ2NvbW1hc3VwZXJpb3InLCAndGhyZWVxdWFydGVyc2VtZGFzaCcsICdwZXJpb2RzdXBlcmlvcicsICdxdWVzdGlvbnNtYWxsJywgJycsICdhc3VwZXJpb3InLFxuICAgICdic3VwZXJpb3InLCAnY2VudHN1cGVyaW9yJywgJ2RzdXBlcmlvcicsICdlc3VwZXJpb3InLCAnJywgJycsICdpc3VwZXJpb3InLCAnJywgJycsICdsc3VwZXJpb3InLCAnbXN1cGVyaW9yJyxcbiAgICAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICcnLCAnJywgJ3JzdXBlcmlvcicsICdzc3VwZXJpb3InLCAndHN1cGVyaW9yJywgJycsICdmZicsICdmaScsICdmbCcsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAnJywgJ3BhcmVucmlnaHRpbmZlcmlvcicsICdDaXJjdW1mbGV4c21hbGwnLCAnaHlwaGVuc3VwZXJpb3InLCAnR3JhdmVzbWFsbCcsICdBc21hbGwnLFxuICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJywgJ05zbWFsbCcsICdPc21hbGwnLCAnUHNtYWxsJywgJ1FzbWFsbCcsICdSc21hbGwnLCAnU3NtYWxsJywgJ1RzbWFsbCcsICdVc21hbGwnLCAnVnNtYWxsJywgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsICdZc21hbGwnLCAnWnNtYWxsJywgJ2NvbG9ubW9uZXRhcnknLCAnb25lZml0dGVkJywgJ3J1cGlhaCcsICdUaWxkZXNtYWxsJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnZXhjbGFtZG93bnNtYWxsJywgJ2NlbnRvbGRzdHlsZScsICdMc2xhc2hzbWFsbCcsICcnLCAnJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLFxuICAgICdCcmV2ZXNtYWxsJywgJ0Nhcm9uc21hbGwnLCAnJywgJ0RvdGFjY2VudHNtYWxsJywgJycsICcnLCAnTWFjcm9uc21hbGwnLCAnJywgJycsICdmaWd1cmVkYXNoJywgJ2h5cGhlbmluZmVyaW9yJyxcbiAgICAnJywgJycsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJywgJycsICcnLCAnJywgJ29uZXF1YXJ0ZXInLCAnb25laGFsZicsICd0aHJlZXF1YXJ0ZXJzJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJywgJycsXG4gICAgJycsICd6ZXJvc3VwZXJpb3InLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJyxcbiAgICAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLFxuICAgICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLCAnc2V2ZW5pbmZlcmlvcicsICdlaWdodGluZmVyaW9yJyxcbiAgICAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJyxcbiAgICAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsXG4gICAgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLCAnSWdyYXZlc21hbGwnLCAnSWFjdXRlc21hbGwnLFxuICAgICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJywgJ09hY3V0ZXNtYWxsJyxcbiAgICAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJywgJ1VhY3V0ZXNtYWxsJyxcbiAgICAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJ107XG5cbnZhciBzdGFuZGFyZE5hbWVzID0gW1xuICAgICcubm90ZGVmJywgJy5udWxsJywgJ25vbm1hcmtpbmdyZXR1cm4nLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLFxuICAgICdhbXBlcnNhbmQnLCAncXVvdGVzaW5nbGUnLCAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJyxcbiAgICAnemVybycsICdvbmUnLCAndHdvJywgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsXG4gICAgJ2VxdWFsJywgJ2dyZWF0ZXInLCAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLFxuICAgICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsXG4gICAgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLCAnZ3JhdmUnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLFxuICAgICdwJywgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLFxuICAgICdBZGllcmVzaXMnLCAnQXJpbmcnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ050aWxkZScsICdPZGllcmVzaXMnLCAnVWRpZXJlc2lzJywgJ2FhY3V0ZScsICdhZ3JhdmUnLFxuICAgICdhY2lyY3VtZmxleCcsICdhZGllcmVzaXMnLCAnYXRpbGRlJywgJ2FyaW5nJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsICdlZ3JhdmUnLCAnZWNpcmN1bWZsZXgnLCAnZWRpZXJlc2lzJyxcbiAgICAnaWFjdXRlJywgJ2lncmF2ZScsICdpY2lyY3VtZmxleCcsICdpZGllcmVzaXMnLCAnbnRpbGRlJywgJ29hY3V0ZScsICdvZ3JhdmUnLCAnb2NpcmN1bWZsZXgnLCAnb2RpZXJlc2lzJyxcbiAgICAnb3RpbGRlJywgJ3VhY3V0ZScsICd1Z3JhdmUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ2RhZ2dlcicsICdkZWdyZWUnLCAnY2VudCcsICdzdGVybGluZycsICdzZWN0aW9uJyxcbiAgICAnYnVsbGV0JywgJ3BhcmFncmFwaCcsICdnZXJtYW5kYmxzJywgJ3JlZ2lzdGVyZWQnLCAnY29weXJpZ2h0JywgJ3RyYWRlbWFyaycsICdhY3V0ZScsICdkaWVyZXNpcycsICdub3RlcXVhbCcsXG4gICAgJ0FFJywgJ09zbGFzaCcsICdpbmZpbml0eScsICdwbHVzbWludXMnLCAnbGVzc2VxdWFsJywgJ2dyZWF0ZXJlcXVhbCcsICd5ZW4nLCAnbXUnLCAncGFydGlhbGRpZmYnLCAnc3VtbWF0aW9uJyxcbiAgICAncHJvZHVjdCcsICdwaScsICdpbnRlZ3JhbCcsICdvcmRmZW1pbmluZScsICdvcmRtYXNjdWxpbmUnLCAnT21lZ2EnLCAnYWUnLCAnb3NsYXNoJywgJ3F1ZXN0aW9uZG93bicsXG4gICAgJ2V4Y2xhbWRvd24nLCAnbG9naWNhbG5vdCcsICdyYWRpY2FsJywgJ2Zsb3JpbicsICdhcHByb3hlcXVhbCcsICdEZWx0YScsICdndWlsbGVtb3RsZWZ0JywgJ2d1aWxsZW1vdHJpZ2h0JyxcbiAgICAnZWxsaXBzaXMnLCAnbm9uYnJlYWtpbmdzcGFjZScsICdBZ3JhdmUnLCAnQXRpbGRlJywgJ090aWxkZScsICdPRScsICdvZScsICdlbmRhc2gnLCAnZW1kYXNoJywgJ3F1b3RlZGJsbGVmdCcsXG4gICAgJ3F1b3RlZGJscmlnaHQnLCAncXVvdGVsZWZ0JywgJ3F1b3RlcmlnaHQnLCAnZGl2aWRlJywgJ2xvemVuZ2UnLCAneWRpZXJlc2lzJywgJ1lkaWVyZXNpcycsICdmcmFjdGlvbicsXG4gICAgJ2N1cnJlbmN5JywgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3F1b3Rlc2luZ2xiYXNlJyxcbiAgICAncXVvdGVkYmxiYXNlJywgJ3BlcnRob3VzYW5kJywgJ0FjaXJjdW1mbGV4JywgJ0VjaXJjdW1mbGV4JywgJ0FhY3V0ZScsICdFZGllcmVzaXMnLCAnRWdyYXZlJywgJ0lhY3V0ZScsXG4gICAgJ0ljaXJjdW1mbGV4JywgJ0lkaWVyZXNpcycsICdJZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JywgJ2FwcGxlJywgJ09ncmF2ZScsICdVYWN1dGUnLCAnVWNpcmN1bWZsZXgnLFxuICAgICdVZ3JhdmUnLCAnZG90bGVzc2knLCAnY2lyY3VtZmxleCcsICd0aWxkZScsICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ3JpbmcnLCAnY2VkaWxsYScsICdodW5nYXJ1bWxhdXQnLFxuICAgICdvZ29uZWsnLCAnY2Fyb24nLCAnTHNsYXNoJywgJ2xzbGFzaCcsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1pjYXJvbicsICd6Y2Fyb24nLCAnYnJva2VuYmFyJywgJ0V0aCcsICdldGgnLFxuICAgICdZYWN1dGUnLCAneWFjdXRlJywgJ1Rob3JuJywgJ3Rob3JuJywgJ21pbnVzJywgJ211bHRpcGx5JywgJ29uZXN1cGVyaW9yJywgJ3R3b3N1cGVyaW9yJywgJ3RocmVlc3VwZXJpb3InLFxuICAgICdvbmVoYWxmJywgJ29uZXF1YXJ0ZXInLCAndGhyZWVxdWFydGVycycsICdmcmFuYycsICdHYnJldmUnLCAnZ2JyZXZlJywgJ0lkb3RhY2NlbnQnLCAnU2NlZGlsbGEnLCAnc2NlZGlsbGEnLFxuICAgICdDYWN1dGUnLCAnY2FjdXRlJywgJ0NjYXJvbicsICdjY2Fyb24nLCAnZGNyb2F0J107XG5cbi8vIFRoaXMgaXMgdGhlIGVuY29kaW5nIHVzZWQgZm9yIGZvbnRzIGNyZWF0ZWQgZnJvbSBzY3JhdGNoLlxuLy8gSXQgbG9vcHMgdGhyb3VnaCBhbGwgZ2x5cGhzIGFuZCBmaW5kcyB0aGUgYXBwcm9wcmlhdGUgdW5pY29kZSB2YWx1ZS5cbi8vIFNpbmNlIGl0J3MgbGluZWFyIHRpbWUsIG90aGVyIGVuY29kaW5ncyB3aWxsIGJlIGZhc3Rlci5cbmZ1bmN0aW9uIERlZmF1bHRFbmNvZGluZyhmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbn1cblxuRGVmYXVsdEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgY29kZSwgZ2x5cGhzLCBpLCBnbHlwaCwgajtcbiAgICBjb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHM7XG4gICAgaWYgKGdseXBocykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaC51bmljb2Rlc1tqXSA9PT0gY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgIHRoaXMuY21hcCA9IGNtYXA7XG59XG5cbkNtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIHRoaXMuY21hcC5nbHlwaEluZGV4TWFwW2MuY2hhckNvZGVBdCgwKV0gfHwgMDtcbn07XG5cbmZ1bmN0aW9uIENmZkVuY29kaW5nKGVuY29kaW5nLCBjaGFyc2V0KSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIHRoaXMuY2hhcnNldCA9IGNoYXJzZXQ7XG59XG5cbkNmZkVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgY29kZSwgY2hhck5hbWU7XG4gICAgY29kZSA9IHMuY2hhckNvZGVBdCgwKTtcbiAgICBjaGFyTmFtZSA9IHRoaXMuZW5jb2RpbmdbY29kZV07XG4gICAgcmV0dXJuIHRoaXMuY2hhcnNldC5pbmRleE9mKGNoYXJOYW1lKTtcbn07XG5cbmZ1bmN0aW9uIEdseXBoTmFtZXMocG9zdCkge1xuICAgIHZhciBpO1xuICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG4gICAgY2FzZSAxOlxuICAgICAgICB0aGlzLm5hbWVzID0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzLnNsaWNlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPCBleHBvcnRzLnN0YW5kYXJkTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IGV4cG9ydHMuc3RhbmRhcmROYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IHBvc3QubmFtZXNbcG9zdC5nbHlwaE5hbWVJbmRleFtpXSAtIGV4cG9ydHMuc3RhbmRhcmROYW1lcy5sZW5ndGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgMi41OlxuICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzW2kgKyBwb3N0LmdseXBoTmFtZUluZGV4W2ldXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG5HbHlwaE5hbWVzLnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpO1xufTtcblxuR2x5cGhOYW1lcy5wcm90b3R5cGUuZ2x5cGhJbmRleFRvTmFtZSA9IGZ1bmN0aW9uIChnaWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc1tnaWRdO1xufTtcblxuZnVuY3Rpb24gYWRkR2x5cGhOYW1lcyhmb250KSB7XG4gICAgdmFyIGdseXBoSW5kZXhNYXAsIGNoYXJDb2RlcywgaSwgYywgZ2x5cGhJbmRleCwgZ2x5cGg7XG4gICAgZ2x5cGhJbmRleE1hcCA9IGZvbnQudGFibGVzLmNtYXAuZ2x5cGhJbmRleE1hcDtcbiAgICBjaGFyQ29kZXMgPSBPYmplY3Qua2V5cyhnbHlwaEluZGV4TWFwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hhckNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2dseXBoSW5kZXhdO1xuICAgICAgICBnbHlwaC5hZGRVbmljb2RlKHBhcnNlSW50KGMpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGZvbnQuZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZm9udC5nbHlwaHNbaV07XG4gICAgICAgIGlmIChmb250LmNmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5jZmZFbmNvZGluZy5jaGFyc2V0W2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLmNmZlN0YW5kYXJkU3RyaW5ncyA9IGNmZlN0YW5kYXJkU3RyaW5ncztcbmV4cG9ydHMuY2ZmU3RhbmRhcmRFbmNvZGluZyA9IGNmZlN0YW5kYXJkRW5jb2Rpbmc7XG5leHBvcnRzLmNmZkV4cGVydEVuY29kaW5nID0gY2ZmRXhwZXJ0RW5jb2Rpbmc7XG5leHBvcnRzLnN0YW5kYXJkTmFtZXMgPSBzdGFuZGFyZE5hbWVzO1xuZXhwb3J0cy5EZWZhdWx0RW5jb2RpbmcgPSBEZWZhdWx0RW5jb2Rpbmc7XG5leHBvcnRzLkNtYXBFbmNvZGluZyA9IENtYXBFbmNvZGluZztcbmV4cG9ydHMuQ2ZmRW5jb2RpbmcgPSBDZmZFbmNvZGluZztcbmV4cG9ydHMuR2x5cGhOYW1lcyA9IEdseXBoTmFtZXM7XG5leHBvcnRzLmFkZEdseXBoTmFtZXMgPSBhZGRHbHlwaE5hbWVzO1xuIiwiLy8gVGhlIEZvbnQgb2JqZWN0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcbnZhciBzZm50ID0gcmVxdWlyZSgnLi90YWJsZXMvc2ZudCcpO1xudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi9lbmNvZGluZycpO1xuXG4vLyBBIEZvbnQgcmVwcmVzZW50cyBhIGxvYWRlZCBPcGVuVHlwZSBmb250IGZpbGUuXG4vLyBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuLy8gb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG5mdW5jdGlvbiBGb250KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBPUyBYIHdpbGwgY29tcGxhaW4gaWYgdGhlIG5hbWVzIGFyZSBlbXB0eSwgc28gd2UgcHV0IGEgc2luZ2xlIHNwYWNlIGV2ZXJ5d2hlcmUgYnkgZGVmYXVsdC5cbiAgICB0aGlzLmZhbWlseU5hbWUgPSBvcHRpb25zLmZhbWlseU5hbWUgfHwgJyAnO1xuICAgIHRoaXMuc3R5bGVOYW1lID0gb3B0aW9ucy5zdHlsZU5hbWUgfHwgJyAnO1xuICAgIHRoaXMuZGVzaWduZXIgPSBvcHRpb25zLmRlc2lnbmVyIHx8ICcgJztcbiAgICB0aGlzLmRlc2lnbmVyVVJMID0gb3B0aW9ucy5kZXNpZ25lclVSTCB8fCAnICc7XG4gICAgdGhpcy5tYW51ZmFjdHVyZXIgPSBvcHRpb25zLm1hbnVmYWN0dXJlciB8fCAnICc7XG4gICAgdGhpcy5tYW51ZmFjdHVyZXJVUkwgPSBvcHRpb25zLm1hbnVmYWN0dXJlclVSTCB8fCAnICc7XG4gICAgdGhpcy5saWNlbnNlID0gb3B0aW9ucy5saWNlbnNlIHx8ICcgJztcbiAgICB0aGlzLmxpY2Vuc2VVUkwgPSBvcHRpb25zLmxpY2Vuc2VVUkwgfHwgJyAnO1xuICAgIHRoaXMudmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiB8fCAnVmVyc2lvbiAwLjEnO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uIHx8ICcgJztcbiAgICB0aGlzLmNvcHlyaWdodCA9IG9wdGlvbnMuY29weXJpZ2h0IHx8ICcgJztcbiAgICB0aGlzLnRyYWRlbWFyayA9IG9wdGlvbnMudHJhZGVtYXJrIHx8ICcgJztcbiAgICB0aGlzLnVuaXRzUGVyRW0gPSBvcHRpb25zLnVuaXRzUGVyRW0gfHwgMTAwMDtcbiAgICB0aGlzLnN1cHBvcnRlZCA9IHRydWU7XG4gICAgdGhpcy5nbHlwaHMgPSBvcHRpb25zLmdseXBocyB8fCBbXTtcbiAgICB0aGlzLmVuY29kaW5nID0gbmV3IGVuY29kaW5nLkRlZmF1bHRFbmNvZGluZyh0aGlzKTtcbiAgICB0aGlzLnRhYmxlcyA9IHt9O1xufVxuXG4vLyBDaGVjayBpZiB0aGUgZm9udCBoYXMgYSBnbHlwaCBmb3IgdGhlIGdpdmVuIGNoYXJhY3Rlci5cbkZvbnQucHJvdG90eXBlLmhhc0NoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgZ2x5cGggaW5kZXguXG4vLyBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuLy8gdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbkZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgocyk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgR2x5cGggb2JqZWN0LlxuLy8gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbi8vIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIGdseXBoSW5kZXgsIGdseXBoO1xuICAgIGdseXBoSW5kZXggPSB0aGlzLmNoYXJUb0dseXBoSW5kZXgoYyk7XG4gICAgZ2x5cGggPSB0aGlzLmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHNbMF07IC8vIC5ub3RkZWZcbiAgICB9XG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuLy8gQ29udmVydCB0aGUgZ2l2ZW4gdGV4dCB0byBhIGxpc3Qgb2YgR2x5cGggb2JqZWN0cy5cbi8vIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBzdHJpY3Qgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gY2hhcmFjdGVycyBhbmRcbi8vIGdseXBocywgc28gdGhlIGxpc3Qgb2YgcmV0dXJuZWQgZ2x5cGhzIGNhbiBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBnaXZlbiBzdHJpbmcuXG5Gb250LnByb3RvdHlwZS5zdHJpbmdUb0dseXBocyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdmFyIGksIGMsIGdseXBocztcbiAgICBnbHlwaHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjID0gc1tpXTtcbiAgICAgICAgZ2x5cGhzLnB1c2godGhpcy5jaGFyVG9HbHlwaChjKSk7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nbHlwaE5hbWVzLm5hbWVUb0dseXBoSW5kZXgobmFtZSk7XG59O1xuXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGdseXBoSW5kZXgsIGdseXBoO1xuICAgIGdseXBoSW5kZXggPSB0aGlzLm5hbWV0b0dseXBoSW5kZXgobmFtZSk7XG4gICAgZ2x5cGggPSB0aGlzLmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHNbMF07IC8vIC5ub3RkZWZcbiAgICB9XG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuRm9udC5wcm90b3R5cGUuZ2x5cGhJbmRleFRvTmFtZSA9IGZ1bmN0aW9uIChnaWQpIHtcbiAgICBpZiAoIXRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGdpZCk7XG59O1xuXG4vLyBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGtlcm5pbmcgcGFpciBiZXR3ZWVuIHRoZSBsZWZ0IGdseXBoIChvciBpdHMgaW5kZXgpXG4vLyBhbmQgdGhlIHJpZ2h0IGdseXBoIChvciBpdHMgaW5kZXgpLiBJZiBubyBrZXJuaW5nIHBhaXIgaXMgZm91bmQsIHJldHVybiAwLlxuLy8gVGhlIGtlcm5pbmcgdmFsdWUgZ2V0cyBhZGRlZCB0byB0aGUgYWR2YW5jZSB3aWR0aCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBzcGFjaW5nXG4vLyBiZXR3ZWVuIGdseXBocy5cbkZvbnQucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uIChsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICBsZWZ0R2x5cGggPSBsZWZ0R2x5cGguaW5kZXggfHwgbGVmdEdseXBoO1xuICAgIHJpZ2h0R2x5cGggPSByaWdodEdseXBoLmluZGV4IHx8IHJpZ2h0R2x5cGg7XG4gICAgdmFyIGdwb3NLZXJuaW5nID0gdGhpcy5nZXRHcG9zS2VybmluZ1ZhbHVlO1xuICAgIHJldHVybiBncG9zS2VybmluZyA/IGdwb3NLZXJuaW5nKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkgOlxuICAgICAgICAodGhpcy5rZXJuaW5nUGFpcnNbbGVmdEdseXBoICsgJywnICsgcmlnaHRHbHlwaF0gfHwgMCk7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCBpbiB0aGUgZ2l2ZW4gdGV4dC5cbi8vIFRoZSBjYWxsYmFjayBnZXRzIGAoZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKWAuXG5Gb250LnByb3RvdHlwZS5mb3JFYWNoR2x5cGggPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGtlcm5pbmcsIGZvbnRTY2FsZSwgZ2x5cGhzLCBpLCBnbHlwaCwga2VybmluZ1ZhbHVlO1xuICAgIGlmICghdGhpcy5zdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAga2VybmluZyA9IG9wdGlvbnMua2VybmluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMua2VybmluZztcbiAgICBmb250U2NhbGUgPSAxIC8gdGhpcy51bml0c1BlckVtICogZm9udFNpemU7XG4gICAgZ2x5cGhzID0gdGhpcy5zdHJpbmdUb0dseXBocyh0ZXh0KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBjYWxsYmFjayhnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZ2x5cGguYWR2YW5jZVdpZHRoKSB7XG4gICAgICAgICAgICB4ICs9IGdseXBoLmFkdmFuY2VXaWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VybmluZyAmJiBpIDwgZ2x5cGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGtlcm5pbmdWYWx1ZSA9IHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuLy9cbi8vIHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuIChkZWZhdWx0OiA3Milcbi8vIE9wdGlvbnMgaXMgYW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgY29udGFpbnM6XG4vLyAtIGtlcm5pbmcgLSBXaGV0aGVyIHRvIHRha2Uga2VybmluZyBpbmZvcm1hdGlvbiBpbnRvIGFjY291bnQuIChkZWZhdWx0OiB0cnVlKVxuLy9cbi8vIFJldHVybnMgYSBQYXRoIG9iamVjdC5cbkZvbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZnVsbFBhdGggPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uIChnbHlwaCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBnbHlwaC5nZXRQYXRoKHgsIHksIGZvbnRTaXplKTtcbiAgICAgICAgZnVsbFBhdGguZXh0ZW5kKHBhdGgpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbn07XG5cbi8vIERyYXcgdGhlIHRleHQgb24gdGhlIGdpdmVuIGRyYXdpbmcgY29udGV4dC5cbi8vXG4vLyBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4vLyB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLiAoZGVmYXVsdDogNzIpXG4vLyBPcHRpb25zIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuLy8gLSBrZXJuaW5nIC0gV2hldGhlciB0byB0YWtlIGtlcm5pbmcgaW5mb3JtYXRpb24gaW50byBhY2NvdW50LiAoZGVmYXVsdDogdHJ1ZSlcbkZvbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0UGF0aCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykuZHJhdyhjdHgpO1xufTtcblxuLy8gRHJhdyB0aGUgcG9pbnRzIG9mIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4vLyBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuLy9cbi8vIGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbi8vIHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuIChkZWZhdWx0OiA3Milcbi8vIE9wdGlvbnMgaXMgYW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgY29udGFpbnM6XG4vLyAtIGtlcm5pbmcgLSBXaGV0aGVyIHRvIHRha2Uga2VybmluZyBpbmZvcm1hdGlvbiBpbnRvIGFjY291bnQuIChkZWZhdWx0OiB0cnVlKVxuRm9udC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uIChjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uIChnbHlwaCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICAgICAgZ2x5cGguZHJhd1BvaW50cyhjdHgsIHgsIHksIGZvbnRTaXplKTtcbiAgICB9KTtcbn07XG5cbi8vIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMgZm9yIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4vLyBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cbi8vIEJsdWUgbGluZXMgaW5kaWNhdGUgdGhlIGdseXBoIGJvdW5kaW5nIGJveC5cbi8vIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cbi8vXG4vLyBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4vLyB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLiAoZGVmYXVsdDogNzIpXG4vLyBPcHRpb25zIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuLy8gLSBrZXJuaW5nIC0gV2hldGhlciB0byB0YWtlIGtlcm5pbmcgaW5mb3JtYXRpb24gaW50byBhY2NvdW50LiAoZGVmYXVsdDogdHJ1ZSlcbkZvbnQucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24gKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24gKGdseXBoLCB4LCB5LCBmb250U2l6ZSkge1xuICAgICAgICBnbHlwaC5kcmF3TWV0cmljcyhjdHgsIHgsIHksIGZvbnRTaXplKTtcbiAgICB9KTtcbn07XG5cbi8vIFZhbGlkYXRlXG5Gb250LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgICB2YXIgZm9udCA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBhc3NlcnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nQXR0cmlidXRlKGF0dHJOYW1lKSB7XG4gICAgICAgIGFzc2VydChmb250W2F0dHJOYW1lXSAmJiBmb250W2F0dHJOYW1lXS50cmltKCkubGVuZ3RoID4gMCwgJ05vICcgKyBhdHRyTmFtZSArICcgc3BlY2lmaWVkLicpO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZpY2F0aW9uIGluZm9ybWF0aW9uXG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCdmYW1pbHlOYW1lJyk7XG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCd3ZWlnaHROYW1lJyk7XG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCdtYW51ZmFjdHVyZXInKTtcbiAgICBhc3NlcnRTdHJpbmdBdHRyaWJ1dGUoJ2NvcHlyaWdodCcpO1xuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgndmVyc2lvbicpO1xuXG4gICAgLy8gRGltZW5zaW9uIGluZm9ybWF0aW9uXG4gICAgYXNzZXJ0KHRoaXMudW5pdHNQZXJFbSA+IDAsICdObyB1bml0c1BlckVtIHNwZWNpZmllZC4nKTtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbi8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuRm9udC5wcm90b3R5cGUudG9UYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNmbnQuZm9udFRvVGFibGUodGhpcyk7XG59O1xuXG5Gb250LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2ZudFRhYmxlID0gdGhpcy50b1RhYmxlcygpO1xuICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzLmxlbmd0aCk7XG4gICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludEFycmF5W2ldID0gYnl0ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbml0aWF0ZSBhIGRvd25sb2FkIG9mIHRoZSBPcGVuVHlwZSBmb250LlxuRm9udC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gdGhpcy5mYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyB0aGlzLnN0eWxlTmFtZSArICcub3RmJztcbiAgICB2YXIgYnVmZmVyID0gdGhpcy50b0J1ZmZlcigpO1xuXG4gICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtID0gd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbTtcbiAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0od2luZG93LlRFTVBPUkFSWSwgYnVmZmVyLmJ5dGVMZW5ndGgsIGZ1bmN0aW9uIChmcykge1xuICAgICAgICBmcy5yb290LmdldEZpbGUoZmlsZU5hbWUsIHtjcmVhdGU6IHRydWV9LCBmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKGZ1bmN0aW9uICh3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10sIHt0eXBlOiAnZm9udC9vcGVudHlwZSd9KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGUoYmxvYik7XG5cbiAgICAgICAgICAgICAgICAgd3JpdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dyaXRlZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYXZpZ2F0aW5nIHRvIHRoZSBmaWxlIHdpbGwgZG93bmxvYWQgaXQuXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSBmaWxlRW50cnkudG9VUkwoKTtcbiAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufTtcblxuZXhwb3J0cy5Gb250ID0gRm9udDtcbiIsIi8vIFRoZSBHbHlwaCBvYmplY3RcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJyk7XG52YXIgZHJhdyA9IHJlcXVpcmUoJy4vZHJhdycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxuLy8gQSBHbHlwaCBpcyBhbiBpbmRpdmlkdWFsIG1hcmsgdGhhdCBvZnRlbiBjb3JyZXNwb25kcyB0byBhIGNoYXJhY3Rlci5cbi8vIFNvbWUgZ2x5cGhzLCBzdWNoIGFzIGxpZ2F0dXJlcywgYXJlIGEgY29tYmluYXRpb24gb2YgbWFueSBjaGFyYWN0ZXJzLlxuLy8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cbi8vXG4vLyBUaGUgYEdseXBoYCBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIGRyYXdpbmcgdGhlIHBhdGggYW5kIGl0cyBwb2ludHMuXG5mdW5jdGlvbiBHbHlwaChvcHRpb25zKSB7XG4gICAgdGhpcy5mb250ID0gb3B0aW9ucy5mb250IHx8IG51bGw7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLnVuaWNvZGUgPSBvcHRpb25zLnVuaWNvZGUgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMudW5pY29kZXMgPSBvcHRpb25zLnVuaWNvZGVzIHx8IG9wdGlvbnMudW5pY29kZSAhPT0gdW5kZWZpbmVkID8gW29wdGlvbnMudW5pY29kZV0gOiBbXTtcbiAgICB0aGlzLnhNaW4gPSBvcHRpb25zLnhNaW4gfHwgMDtcbiAgICB0aGlzLnlNaW4gPSBvcHRpb25zLnlNaW4gfHwgMDtcbiAgICB0aGlzLnhNYXggPSBvcHRpb25zLnhNYXggfHwgMDtcbiAgICB0aGlzLnlNYXggPSBvcHRpb25zLnlNYXggfHwgMDtcbiAgICB0aGlzLmFkdmFuY2VXaWR0aCA9IG9wdGlvbnMuYWR2YW5jZVdpZHRoIHx8IDA7XG4gICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8IG51bGw7XG59XG5cbkdseXBoLnByb3RvdHlwZS5hZGRVbmljb2RlID0gZnVuY3Rpb24gKHVuaWNvZGUpIHtcbiAgICBpZiAodGhpcy51bmljb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy51bmljb2RlID0gdW5pY29kZTtcbiAgICB9XG4gICAgdGhpcy51bmljb2Rlcy5wdXNoKHVuaWNvZGUpO1xufTtcblxuLy8gQ29udmVydCB0aGUgZ2x5cGggdG8gYSBQYXRoIHdlIGNhbiBkcmF3IG9uIGEgZHJhd2luZyBjb250ZXh0LlxuLy9cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplLCBpbiBwaXhlbHMgKGRlZmF1bHQ6IDcyKS5cbkdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKHgsIHksIGZvbnRTaXplKSB7XG4gICAgdmFyIHNjYWxlLCBwLCBjb21tYW5kcywgY21kO1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiA3MjtcbiAgICBzY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHggKyAoY21kLnggKiBzY2FsZSksIHkgKyAoLWNtZC55ICogc2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBwLmxpbmVUbyh4ICsgKGNtZC54ICogc2NhbGUpLCB5ICsgKC1jbWQueSAqIHNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyAoY21kLngxICogc2NhbGUpLCB5ICsgKC1jbWQueTEgKiBzY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHNjYWxlKSwgeSArICgtY21kLnkgKiBzY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHAuY3VydmVUbyh4ICsgKGNtZC54MSAqIHNjYWxlKSwgeSArICgtY21kLnkxICogc2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLngyICogc2NhbGUpLCB5ICsgKC1jbWQueTIgKiBzY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHNjYWxlKSwgeSArICgtY21kLnkgKiBzY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG59O1xuXG4vLyBTcGxpdCB0aGUgZ2x5cGggaW50byBjb250b3Vycy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB0b1xuLy8gcHJvdmlkZSByYXcgYWNjZXNzIHRvIHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lcy5cbkdseXBoLnByb3RvdHlwZS5nZXRDb250b3VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udG91cnMsIGN1cnJlbnRDb250b3VyLCBpLCBwdDtcbiAgICBpZiAodGhpcy5wb2ludHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnRvdXJzID0gW107XG4gICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgcHQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59O1xuXG4vLyBDYWxjdWxhdGUgdGhlIHhNaW4veU1pbi94TWF4L3lNYXgvbHNiL3JzYiBmb3IgYSBHbHlwaC5cbkdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICB2YXIgeENvb3JkcyA9IFtdO1xuICAgIHZhciB5Q29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSAhPT0gJ1onKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJyB8fCBjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngxKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBtZXRyaWNzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5nOiAwXG4gICAgfTtcbiAgICBtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcgPSB0aGlzLmFkdmFuY2VXaWR0aCAtIG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nIC0gKG1ldHJpY3MueE1heCAtIG1ldHJpY3MueE1pbik7XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59O1xuXG4vLyBEcmF3IHRoZSBnbHlwaCBvbiB0aGUgZ2l2ZW4gY29udGV4dC5cbi8vXG4vLyBjdHggLSBUaGUgZHJhd2luZyBjb250ZXh0LlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUsIGluIHBpeGVscyAoZGVmYXVsdDogNzIpLlxuR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIHRoaXMuZ2V0UGF0aCh4LCB5LCBmb250U2l6ZSkuZHJhdyhjdHgpO1xufTtcblxuLy8gRHJhdyB0aGUgcG9pbnRzIG9mIHRoZSBnbHlwaC5cbi8vIE9uLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIGJsdWUsIG9mZi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiByZWQuXG4vL1xuLy8gY3R4IC0gVGhlIGRyYXdpbmcgY29udGV4dC5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplLCBpbiBwaXhlbHMgKGRlZmF1bHQ6IDcyKS5cbkdseXBoLnByb3RvdHlwZS5kcmF3UG9pbnRzID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcblxuICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGwsIHgsIHksIHNjYWxlKSB7XG4gICAgICAgIHZhciBqLCBQSV9TUSA9IE1hdGguUEkgKiAyO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSk7XG4gICAgICAgICAgICBjdHguYXJjKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSwgMiwgMCwgUElfU1EsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlLCBpLCBibHVlQ2lyY2xlcywgcmVkQ2lyY2xlcywgcGF0aCwgY21kO1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiAyNDtcbiAgICBzY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgYmx1ZUNpcmNsZXMgPSBbXTtcbiAgICByZWRDaXJjbGVzID0gW107XG4gICAgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmx1ZUNpcmNsZXMucHVzaCh7eDogY21kLngsIHk6IC1jbWQueX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbWQueDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVkQ2lyY2xlcy5wdXNoKHt4OiBjbWQueDEsIHk6IC1jbWQueTF9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kLngyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngyLCB5OiAtY21kLnkyfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXdDaXJjbGVzKGJsdWVDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGRyYXdDaXJjbGVzKHJlZENpcmNsZXMsIHgsIHksIHNjYWxlKTtcbn07XG5cbi8vIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMuXG4vLyBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cbi8vIEJsdWUgbGluZXMgaW5kaWNhdGUgdGhlIGdseXBoIGJvdW5kaW5nIGJveC5cbi8vIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cbi8vXG4vLyBjdHggLSBUaGUgZHJhd2luZyBjb250ZXh0LlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUsIGluIHBpeGVscyAoZGVmYXVsdDogNzIpLlxuR2x5cGgucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICB2YXIgc2NhbGU7XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDI0O1xuICAgIHNjYWxlID0gMSAvIHRoaXMuZm9udC51bml0c1BlckVtICogZm9udFNpemU7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgLy8gRHJhdyB0aGUgb3JpZ2luXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBkcmF3LmxpbmUoY3R4LCB4LCAtMTAwMDAsIHgsIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHksIDEwMDAwLCB5KTtcbiAgICAvLyBEcmF3IHRoZSBnbHlwaCBib3hcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh0aGlzLnhNaW4gKiBzY2FsZSksIC0xMDAwMCwgeCArICh0aGlzLnhNaW4gKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHRoaXMueE1heCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHRoaXMueE1heCAqIHNjYWxlKSwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSArICgtdGhpcy55TWluICogc2NhbGUpLCAxMDAwMCwgeSArICgtdGhpcy55TWluICogc2NhbGUpKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXRoaXMueU1heCAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXRoaXMueU1heCAqIHNjYWxlKSk7XG4gICAgLy8gRHJhdyB0aGUgYWR2YW5jZSB3aWR0aFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh0aGlzLmFkdmFuY2VXaWR0aCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHRoaXMuYWR2YW5jZVdpZHRoICogc2NhbGUpLCAxMDAwMCk7XG59O1xuXG5leHBvcnRzLkdseXBoID0gR2x5cGg7XG4iLCIvLyBvcGVudHlwZS5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVib3gvb3BlbnR5cGUuanNcbi8vIChjKSAyMDE0IEZyZWRlcmlrIERlIEJsZXNlclxuLy8gb3BlbnR5cGUuanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbi8qIGdsb2JhbCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIFVpbnQ4QXJyYXksIFhNTEh0dHBSZXF1ZXN0ICAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4vZW5jb2RpbmcnKTtcbnZhciBfZm9udCA9IHJlcXVpcmUoJy4vZm9udCcpO1xudmFyIGdseXBoID0gcmVxdWlyZSgnLi9nbHlwaCcpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxudmFyIGNtYXAgPSByZXF1aXJlKCcuL3RhYmxlcy9jbWFwJyk7XG52YXIgY2ZmID0gcmVxdWlyZSgnLi90YWJsZXMvY2ZmJyk7XG52YXIgZ2x5ZiA9IHJlcXVpcmUoJy4vdGFibGVzL2dseWYnKTtcbnZhciBncG9zID0gcmVxdWlyZSgnLi90YWJsZXMvZ3BvcycpO1xudmFyIGhlYWQgPSByZXF1aXJlKCcuL3RhYmxlcy9oZWFkJyk7XG52YXIgaGhlYSA9IHJlcXVpcmUoJy4vdGFibGVzL2hoZWEnKTtcbnZhciBobXR4ID0gcmVxdWlyZSgnLi90YWJsZXMvaG10eCcpO1xudmFyIGtlcm4gPSByZXF1aXJlKCcuL3RhYmxlcy9rZXJuJyk7XG52YXIgbG9jYSA9IHJlcXVpcmUoJy4vdGFibGVzL2xvY2EnKTtcbnZhciBtYXhwID0gcmVxdWlyZSgnLi90YWJsZXMvbWF4cCcpO1xudmFyIF9uYW1lID0gcmVxdWlyZSgnLi90YWJsZXMvbmFtZScpO1xudmFyIG9zMiA9IHJlcXVpcmUoJy4vdGFibGVzL29zMicpO1xudmFyIHBvc3QgPSByZXF1aXJlKCcuL3RhYmxlcy9wb3N0Jyk7XG5cbi8vIEZpbGUgbG9hZGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gQ29udmVydCBhIE5vZGUuanMgQnVmZmVyIHRvIGFuIEFycmF5QnVmZmVyXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1ZmZlcikge1xuICAgIHZhciBpLFxuICAgICAgICBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKSxcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZGF0YVtpXSA9IGJ1ZmZlcltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG59XG5cbmZ1bmN0aW9uIGxvYWRGcm9tRmlsZShwYXRoLCBjYWxsYmFjaykge1xuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24gKGVyciwgYnVmZmVyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCB0b0FycmF5QnVmZmVyKGJ1ZmZlcikpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBsb2FkRnJvbVVybCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICcgKyByZXF1ZXN0LnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZCgpO1xufVxuXG4vLyBQdWJsaWMgQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFBhcnNlIHRoZSBPcGVuVHlwZSBmaWxlIGRhdGEgKGFzIGFuIEFycmF5QnVmZmVyKSBhbmQgcmV0dXJuIGEgRm9udCBvYmplY3QuXG4vLyBJZiB0aGUgZmlsZSBjb3VsZCBub3QgYmUgcGFyc2VkIChtb3N0IGxpa2VseSBiZWNhdXNlIGl0IGNvbnRhaW5zIFBvc3RzY3JpcHQgb3V0bGluZXMpXG4vLyB3ZSByZXR1cm4gYW4gZW1wdHkgRm9udCBvYmplY3Qgd2l0aCB0aGUgYHN1cHBvcnRlZGAgZmxhZyBzZXQgdG8gYGZhbHNlYC5cbmZ1bmN0aW9uIHBhcnNlQnVmZmVyKGJ1ZmZlcikge1xuICAgIHZhciBmb250LCBkYXRhLCB2ZXJzaW9uLCBudW1UYWJsZXMsIGksIHAsIHRhZywgb2Zmc2V0LCBobXR4T2Zmc2V0LCBnbHlmT2Zmc2V0LCBsb2NhT2Zmc2V0LFxuICAgICAgICBjZmZPZmZzZXQsIGtlcm5PZmZzZXQsIGdwb3NPZmZzZXQsIGluZGV4VG9Mb2NGb3JtYXQsIG51bUdseXBocywgbG9jYVRhYmxlLFxuICAgICAgICBzaG9ydFZlcnNpb247XG4gICAgLy8gT3BlblR5cGUgZm9udHMgdXNlIGJpZyBlbmRpYW4gYnl0ZSBvcmRlcmluZy5cbiAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHR5cGVkIGFycmF5IHZpZXcgdHlwZXMsIGJlY2F1c2UgdGhleSBvcGVyYXRlIHdpdGggdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGhvc3QgY29tcHV0ZXIuXG4gICAgLy8gSW5zdGVhZCB3ZSB1c2UgRGF0YVZpZXdzIHdoZXJlIHdlIGNhbiBzcGVjaWZ5IGVuZGlhbm5lc3MuXG5cbiAgICBmb250ID0gbmV3IF9mb250LkZvbnQoKTtcbiAgICBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCk7XG5cbiAgICB2ZXJzaW9uID0gcGFyc2UuZ2V0Rml4ZWQoZGF0YSwgMCk7XG4gICAgaWYgKHZlcnNpb24gPT09IDEuMCkge1xuICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJzaW9uID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDApO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gJ09UVE8nKSB7XG4gICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ2NmZic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIHZlcnNpb24gJyArIHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDQpO1xuXG4gICAgLy8gT2Zmc2V0IGludG8gdGhlIHRhYmxlIHJlY29yZHMuXG4gICAgcCA9IDEyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAnY21hcCc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5jbWFwID0gY21hcC5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC5lbmNvZGluZyA9IG5ldyBlbmNvZGluZy5DbWFwRW5jb2RpbmcoZm9udC50YWJsZXMuY21hcCk7XG4gICAgICAgICAgICBpZiAoIWZvbnQuZW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICBmb250LnN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMuaGVhZCA9IGhlYWQucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQudW5pdHNQZXJFbSA9IGZvbnQudGFibGVzLmhlYWQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIGluZGV4VG9Mb2NGb3JtYXQgPSBmb250LnRhYmxlcy5oZWFkLmluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGhlYSc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5oaGVhID0gaGhlYS5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG4gICAgICAgICAgICBmb250LmRlc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuZGVzY2VuZGVyO1xuICAgICAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzID0gZm9udC50YWJsZXMuaGhlYS5udW1iZXJPZkhNZXRyaWNzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2htdHgnOlxuICAgICAgICAgICAgaG10eE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYXhwJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLm1heHAgPSBtYXhwLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250Lm51bUdseXBocyA9IG51bUdseXBocyA9IGZvbnQudGFibGVzLm1heHAubnVtR2x5cGhzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMubmFtZSA9IF9uYW1lLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250LmZhbWlseU5hbWUgPSBmb250LnRhYmxlcy5uYW1lLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICBmb250LnN0eWxlTmFtZSA9IGZvbnQudGFibGVzLm5hbWUuZm9udFN1YmZhbWlseTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPUy8yJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLm9zMiA9IG9zMi5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMucG9zdCA9IHBvc3QucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQuZ2x5cGhOYW1lcyA9IG5ldyBlbmNvZGluZy5HbHlwaE5hbWVzKGZvbnQudGFibGVzLnBvc3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2dseWYnOlxuICAgICAgICAgICAgZ2x5Zk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsb2NhJzpcbiAgICAgICAgICAgIGxvY2FPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQ0ZGICc6XG4gICAgICAgICAgICBjZmZPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAna2Vybic6XG4gICAgICAgICAgICBrZXJuT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0dQT1MnOlxuICAgICAgICAgICAgZ3Bvc09mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHAgKz0gMTY7XG4gICAgfVxuXG4gICAgaWYgKGdseWZPZmZzZXQgJiYgbG9jYU9mZnNldCkge1xuICAgICAgICBzaG9ydFZlcnNpb24gPSBpbmRleFRvTG9jRm9ybWF0ID09PSAwO1xuICAgICAgICBsb2NhVGFibGUgPSBsb2NhLnBhcnNlKGRhdGEsIGxvY2FPZmZzZXQsIG51bUdseXBocywgc2hvcnRWZXJzaW9uKTtcbiAgICAgICAgZm9udC5nbHlwaHMgPSBnbHlmLnBhcnNlKGRhdGEsIGdseWZPZmZzZXQsIGxvY2FUYWJsZSwgZm9udCk7XG4gICAgICAgIGhtdHgucGFyc2UoZGF0YSwgaG10eE9mZnNldCwgZm9udC5udW1iZXJPZkhNZXRyaWNzLCBmb250Lm51bUdseXBocywgZm9udC5nbHlwaHMpO1xuICAgICAgICBlbmNvZGluZy5hZGRHbHlwaE5hbWVzKGZvbnQpO1xuICAgIH0gZWxzZSBpZiAoY2ZmT2Zmc2V0KSB7XG4gICAgICAgIGNmZi5wYXJzZShkYXRhLCBjZmZPZmZzZXQsIGZvbnQpO1xuICAgICAgICBlbmNvZGluZy5hZGRHbHlwaE5hbWVzKGZvbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvbnQuc3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChrZXJuT2Zmc2V0KSB7XG4gICAgICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IGtlcm4ucGFyc2UoZGF0YSwga2Vybk9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChncG9zT2Zmc2V0KSB7XG4gICAgICAgICAgICBncG9zLnBhcnNlKGRhdGEsIGdwb3NPZmZzZXQsIGZvbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnQ7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBhIGZpbGVzeXN0ZW0uIFdoZW4gZG9uZSwgY2FsbCB0aGUgY2FsbGJhY2tcbi8vIHdpdGggdHdvIGFyZ3VtZW50cyBgKGVyciwgZm9udClgLiBUaGUgYGVycmAgd2lsbCBiZSBudWxsIG9uIHN1Y2Nlc3MsXG4vLyB0aGUgYGZvbnRgIGlzIGEgRm9udCBvYmplY3QuXG4vL1xuLy8gV2UgdXNlIHRoZSBub2RlLmpzIGNhbGxiYWNrIGNvbnZlbnRpb24gc28gdGhhdFxuLy8gb3BlbnR5cGUuanMgY2FuIGludGVncmF0ZSB3aXRoIGZyYW1ld29ya3MgbGlrZSBhc3luYy5qcy5cbmZ1bmN0aW9uIGxvYWQodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbiAgICB2YXIgbG9hZEZuID0gaXNOb2RlID8gbG9hZEZyb21GaWxlIDogbG9hZEZyb21Vcmw7XG4gICAgbG9hZEZuKHVybCwgZnVuY3Rpb24gKGVyciwgYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbnQgPSBwYXJzZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG4gICAgICAgIGlmICghZm9udC5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygnRm9udCBpcyBub3Qgc3VwcG9ydGVkIChpcyB0aGlzIGEgUG9zdHNjcmlwdCBmb250PyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZm9udCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuRm9udCA9IF9mb250LkZvbnQ7XG5leHBvcnRzLkdseXBoID0gZ2x5cGguR2x5cGg7XG5leHBvcnRzLlBhdGggPSBwYXRoLlBhdGg7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VCdWZmZXI7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuIiwiLy8gUGFyc2luZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIGJ5dGUgZnJvbSB0aGUgRGF0YVZpZXcuXG5leHBvcnRzLmdldEJ5dGUgPSBmdW5jdGlvbiBnZXRCeXRlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbn07XG5cbmV4cG9ydHMuZ2V0Q2FyZDggPSBleHBvcnRzLmdldEJ5dGU7XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmV4cG9ydHMuZ2V0VVNob3J0ID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xufTtcblxuZXhwb3J0cy5nZXRDYXJkMTYgPSBleHBvcnRzLmdldFVTaG9ydDtcblxuLy8gUmV0cmlldmUgYSBzaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRTaG9ydCA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xufTtcblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMzItYml0IGxvbmcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5leHBvcnRzLmdldFVMb25nID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xufTtcblxuLy8gUmV0cmlldmUgYSAzMi1iaXQgc2lnbmVkIGZpeGVkLXBvaW50IG51bWJlciAoMTYuMTYpIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRGaXhlZCA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGRlY2ltYWwsIGZyYWN0aW9uO1xuICAgIGRlY2ltYWwgPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbiAgICBmcmFjdGlvbiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGRlY2ltYWwgKyBmcmFjdGlvbiAvIDY1NTM1O1xufTtcblxuLy8gUmV0cmlldmUgYSA0LWNoYXJhY3RlciB0YWcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUYWdzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRhYmxlcy5cbmV4cG9ydHMuZ2V0VGFnID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICB2YXIgdGFnID0gJycsIGk7XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNDsgaSArPSAxKSB7XG4gICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldEludDgoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGFnO1xufTtcblxuLy8gUmV0cmlldmUgYW4gb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gT2Zmc2V0cyBhcmUgMSB0byA0IGJ5dGVzIGluIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBvZmZTaXplIGFyZ3VtZW50LlxuZXhwb3J0cy5nZXRPZmZzZXQgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCwgb2ZmU2l6ZSkge1xuICAgIHZhciBpLCB2O1xuICAgIHYgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZTaXplOyBpICs9IDEpIHtcbiAgICAgICAgdiA8PD0gODtcbiAgICAgICAgdiArPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG4vLyBSZXRyaWV2ZSBhIG51bWJlciBvZiBieXRlcyBmcm9tIHN0YXJ0IG9mZnNldCB0byB0aGUgZW5kIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbmV4cG9ydHMuZ2V0Qnl0ZXMgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgYnl0ZXMsIGk7XG4gICAgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKGkgPSBzdGFydE9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBsaXN0IG9mIGJ5dGVzIHRvIGEgc3RyaW5nLlxuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgdmFyIHMsIGk7XG4gICAgcyA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn07XG5cbnZhciB0eXBlT2Zmc2V0cyA9IHtcbiAgICBieXRlOiAxLFxuICAgIHVTaG9ydDogMixcbiAgICBzaG9ydDogMixcbiAgICB1TG9uZzogNCxcbiAgICBmaXhlZDogNCxcbiAgICBsb25nRGF0ZVRpbWU6IDgsXG4gICAgdGFnOiA0XG59O1xuXG4vLyBBIHN0YXRlZnVsIHBhcnNlciB0aGF0IGNoYW5nZXMgdGhlIG9mZnNldCB3aGVuZXZlciBhIHZhbHVlIGlzIHJldHJpZXZlZC5cbi8vIFRoZSBkYXRhIGlzIGEgRGF0YVZpZXcuXG5mdW5jdGlvbiBQYXJzZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gMDtcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQ4ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkMTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNJRCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRjJEb3QxNCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpIC8gMTYzODQ7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpeGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRGaXhlZCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2TGlzdCA9XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KSxcbiAgICAgICAgZGF0YVZpZXcgPSB0aGlzLmRhdGEsXG4gICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IGV4cG9ydHMuZ2V0VVNob3J0KGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YSxcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0LFxuICAgICAgICBzdHJpbmcgPSAnJztcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmcoNCk7XG59O1xuXG4vLyBMT05HREFURVRJTUUgaXMgYSA2NC1iaXQgaW50ZWdlci5cbi8vIEphdmFTY3JpcHQgYW5kIHVuaXggdGltZXN0YW1wcyB0cmFkaXRpb25hbGx5IHVzZSAzMiBiaXRzLCBzbyB3ZVxuLy8gb25seSB0YWtlIHRoZSBsYXN0IDMyIGJpdHMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9uZ0RhdGVUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBleHBvcnRzLmdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgNCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA4O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpeGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBleHBvcnRzLmdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHYgLyA2NTUzNjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VWZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1ham9yID0gZXhwb3J0cy5nZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIC8vIEhvdyB0byBpbnRlcnByZXQgdGhlIG1pbm9yIHZlcnNpb24gaXMgdmVyeSB2YWd1ZSBpbiB0aGUgc3BlYy4gMHg1MDAwIGlzIDUsIDB4MTAwMCBpcyAxXG4gICAgLy8gVGhpcyByZXR1cm5zIHRoZSBjb3JyZWN0IG51bWJlciBpZiBtaW5vciA9IDB4TjAwMCB3aGVyZSBOIGlzIDAtOVxuICAgIHZhciBtaW5vciA9IGV4cG9ydHMuZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgMik7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiBtYWpvciArIG1pbm9yIC8gMHgxMDAwIC8gMTA7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAodHlwZSwgYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFtb3VudCA9IDE7XG4gICAgfVxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gdHlwZU9mZnNldHNbdHlwZV0gKiBhbW91bnQ7XG59O1xuXG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbiIsIi8vIEdlb21ldHJpYyBvYmplY3RzXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gQSBiw6l6aWVyIHBhdGggY29udGFpbmluZyBhIHNldCBvZiBwYXRoIGNvbW1hbmRzIHNpbWlsYXIgdG8gYSBTVkcgcGF0aC5cbi8vIFBhdGhzIGNhbiBiZSBkcmF3biBvbiBhIGNvbnRleHQgdXNpbmcgYGRyYXdgLlxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5maWxsID0gJ2JsYWNrJztcbiAgICB0aGlzLnN0cm9rZSA9IG51bGw7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG59XG5cblBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ00nLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdMJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuUGF0aC5wcm90b3R5cGUuY3VydmVUbyA9IFBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkyOiB5MixcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuUGF0aC5wcm90b3R5cGUucXVhZFRvID0gUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uICh4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnUScsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5jbG9zZSA9IFBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnWidcbiAgICB9KTtcbn07XG5cbi8vIEFkZCB0aGUgZ2l2ZW4gcGF0aCBvciBsaXN0IG9mIGNvbW1hbmRzIHRvIHRoZSBjb21tYW5kcyBvZiB0aGlzIHBhdGguXG5QYXRoLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAocGF0aE9yQ29tbWFuZHMpIHtcbiAgICBpZiAocGF0aE9yQ29tbWFuZHMuY29tbWFuZHMpIHtcbiAgICAgICAgcGF0aE9yQ29tbWFuZHMgPSBwYXRoT3JDb21tYW5kcy5jb21tYW5kcztcbiAgICB9XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5jb21tYW5kcywgcGF0aE9yQ29tbWFuZHMpO1xufTtcblxuLy8gRHJhdyB0aGUgcGF0aCB0byBhIDJEIGNvbnRleHQuXG5QYXRoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBpLCBjbWQ7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2U7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG4vLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGRlY2ltYWxQbGFjZXM6IFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlcyAoZGVmYXVsdDogMilcblBhdGgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbiAoZGVjaW1hbFBsYWNlcykge1xuICAgIGRlY2ltYWxQbGFjZXMgPSBkZWNpbWFsUGxhY2VzICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsUGxhY2VzIDogMjtcblxuICAgIGZ1bmN0aW9uIGZsb2F0VG9TdHJpbmcodikge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZCh2KSA9PT0gdikge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgTWF0aC5yb3VuZCh2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWNrVmFsdWVzKCkge1xuICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHYgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzICs9IGZsb2F0VG9TdHJpbmcodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgdmFyIGQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBkICs9ICdDJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBkICs9ICdaJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDtcbn07XG5cbi8vIENvbnZlcnQgdGhlIHBhdGggdG8gYSBTVkcgPHBhdGg+IGVsZW1lbnQsIGFzIGEgc3RyaW5nLlxuLy8gUGFyYW1ldGVyczpcbi8vIC0gZGVjaW1hbFBsYWNlczogVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzIChkZWZhdWx0OiAyKVxuUGF0aC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbiAoZGVjaW1hbFBsYWNlcykge1xuICAgIHZhciBzdmcgPSAnPHBhdGggZD1cIic7XG4gICAgc3ZnICs9IHRoaXMudG9QYXRoRGF0YShkZWNpbWFsUGxhY2VzKTtcbiAgICBzdmcgKz0gJ1wiJztcbiAgICBpZiAodGhpcy5maWxsICYgdGhpcy5maWxsICE9PSAnYmxhY2snKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbGwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCJub25lXCInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ZnICs9ICcgZmlsbD1cIicgKyB0aGlzLmZpbGwgKyAnXCInO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBzdmcgKz0gJyBzdHJva2U9XCInICsgdGhpcy5zdHJva2UgKyAnXCIgc3Ryb2tlLXdpZHRoPVwiJyArIHRoaXMuc3Ryb2tlV2lkdGggKyAnXCInO1xuICAgIH1cbiAgICBzdmcgKz0gJy8+JztcbiAgICByZXR1cm4gc3ZnO1xufTtcblxuZXhwb3J0cy5QYXRoID0gUGF0aDtcbiIsIi8vIFRhYmxlIG1ldGFkYXRhXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpO1xudmFyIGVuY29kZSA9IHJlcXVpcmUoJy4vdHlwZXMnKS5lbmNvZGU7XG52YXIgc2l6ZU9mID0gcmVxdWlyZSgnLi90eXBlcycpLnNpemVPZjtcblxuZnVuY3Rpb24gVGFibGUodGFibGVOYW1lLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlO1xuICAgIH1cbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9uS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25LZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHYgPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5UYWJsZS5wcm90b3R5cGUuc2l6ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnNpemVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdiArPSB2YWx1ZS5zaXplT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZltmaWVsZC50eXBlXTtcbiAgICAgICAgICAgIGNoZWNrLmFzc2VydCh0eXBlb2Ygc2l6ZU9mRnVuY3Rpb24gPT09ICdmdW5jdGlvbicsICdDb3VsZCBub3QgZmluZCBzaXplT2YgZnVuY3Rpb24gZm9yIGZpZWxkJyArIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgdiArPSBzaXplT2ZGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG5UYWJsZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbmNvZGUuVEFCTEUodGhpcyk7XG59O1xuXG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG4iLCIvLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jZmYuaHRtXG4vLyBodHRwOi8vZG93bmxvYWQubWljcm9zb2Z0LmNvbS9kb3dubG9hZC84LzAvMS84MDFhMTkxYy0wMjlkLTRhZjMtOTY0Mi01NTVmNmZlNTE0ZWUvY2ZmLnBkZlxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL3R5cGUyLnBkZlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4uL2VuY29kaW5nJyk7XG52YXIgX2dseXBoID0gcmVxdWlyZSgnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL3BhdGgnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIEN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gdGhhdCBjYW4gYWxzbyBjaGVjayBsaXN0cy5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cbi8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgb2Zmc2V0cywgb2JqZWN0cywgY291bnQsIGVuZE9mZnNldCwgb2Zmc2V0U2l6ZSwgb2JqZWN0T2Zmc2V0LCBwb3MsIGksIHZhbHVlO1xuICAgIG9mZnNldHMgPSBbXTtcbiAgICBvYmplY3RzID0gW107XG4gICAgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcbiAgICAgICAgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKGRhdGEsIG9iamVjdE9mZnNldCArIG9mZnNldHNbaV0sIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSArIDFdKTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7b2JqZWN0czogb2JqZWN0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldH07XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCByZWFsIHZhbHVlLlxuZnVuY3Rpb24gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKSB7XG4gICAgdmFyIHMsIGVvZiwgbG9va3VwLCBiLCBuMSwgbjI7XG4gICAgcyA9ICcnO1xuICAgIGVvZiA9IDE1O1xuICAgIGxvb2t1cCA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICcuJywgJ0UnLCAnRS0nLCBudWxsLCAnLSddO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIG4xID0gYiA+PiA0O1xuICAgICAgICBuMiA9IGIgJiAxNTtcblxuICAgICAgICBpZiAobjEgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBsb29rdXBbbjFdO1xuXG4gICAgICAgIGlmIChuMiA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzICs9IGxvb2t1cFtuMl07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cbmZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG4gICAgdmFyIGIxLCBiMiwgYjMsIGI0O1xuICAgIGlmIChiMCA9PT0gMjgpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgOCB8IGIyO1xuICAgIH1cbiAgICBpZiAoYjAgPT09IDI5KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjMgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGI0ID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgMjQgfCBiMiA8PCAxNiB8IGIzIDw8IDggfCBiNDtcbiAgICB9XG4gICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKGIwID49IDMyICYmIGIwIDw9IDI0Nikge1xuICAgICAgICByZXR1cm4gYjAgLSAxMzk7XG4gICAgfVxuICAgIGlmIChiMCA+PSAyNDcgJiYgYjAgPD0gMjUwKSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIwIC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4O1xuICAgIH1cbiAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiMCAnICsgYjApO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBlbnRyaWVzIHJldHVybmVkIGJ5IGBwYXJzZURpY3RgIHRvIGEgcHJvcGVyIGRpY3Rpb25hcnkuXG4vLyBJZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBvbmUsIGl0IGlzIHVucGFja2VkLlxuZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpIHtcbiAgICB2YXIgbywga2V5LCB2YWx1ZXMsIGksIHZhbHVlO1xuICAgIG8gPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBrZXkgPSBlbnRyaWVzW2ldWzBdO1xuICAgICAgICB2YWx1ZXMgPSBlbnRyaWVzW2ldWzFdO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCAnICsgbyArICcgYWxyZWFkeSBoYXMga2V5ICcgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICB2YXIgcGFyc2VyLCBlbnRyaWVzLCBvcGVyYW5kcywgb3A7XG4gICAgc3RhcnQgPSBzdGFydCAhPT0gdW5kZWZpbmVkID8gc3RhcnQgOiAwO1xuICAgIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGVudHJpZXMgPSBbXTtcbiAgICBvcGVyYW5kcyA9IFtdO1xuICAgIHNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ5dGUgZm9yIGVhY2ggZGljdCBpdGVtIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBvcGVyYXRvciAoa2V5KSBhbmQgb3BlcmFuZCAodmFsdWUpLlxuICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cbiAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG4gICAgICAgICAgICAvLyBUd28tYnl0ZSBvcGVyYXRvcnMgaGF2ZSBhbiBpbml0aWFsIGVzY2FwZSBieXRlIG9mIDEyLlxuICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMucHVzaChbb3AsIG9wZXJhbmRzXSk7XG4gICAgICAgICAgICBvcGVyYW5kcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIG9wZXJhbmRzICh2YWx1ZXMpIGNvbWUgYmVmb3JlIHRoZSBvcGVyYXRvcnMgKGtleXMpLCB3ZSBzdG9yZSBhbGwgb3BlcmFuZHMgaW4gYSBsaXN0XG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSBlbmNvdW50ZXIgYW4gb3BlcmF0b3IuXG4gICAgICAgICAgICBvcGVyYW5kcy5wdXNoKHBhcnNlT3BlcmFuZChwYXJzZXIsIG9wKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vLyBJbnRlcnByZXQgYSBkaWN0aW9uYXJ5IGFuZCByZXR1cm4gYSBuZXcgZGljdGlvbmFyeSB3aXRoIHJlYWRhYmxlIGtleXMgYW5kIHZhbHVlcyBmb3IgbWlzc2luZyBlbnRyaWVzLlxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIGksIG0sIHZhbHVlLCBuZXdEaWN0O1xuICAgIG5ld0RpY3QgPSB7fTtcbiAgICAvLyBCZWNhdXNlIHdlIGFsc28gd2FudCB0byBpbmNsdWRlIG1pc3NpbmcgdmFsdWVzLCB3ZSBzdGFydCBvdXQgZnJvbSB0aGUgbWV0YSBsaXN0XG4gICAgLy8gYW5kIGxvb2t1cCB2YWx1ZXMgaW4gdGhlIGRpY3QuXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbSA9IG1ldGFbaV07XG4gICAgICAgIHZhbHVlID0gZGljdFttLm9wXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RpY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZGVyID0ge307XG4gICAgaGVhZGVyLmZvcm1hdE1ham9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG4gICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuICAgIGhlYWRlci5vZmZzZXRTaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAzKTtcbiAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcbiAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgIHJldHVybiBoZWFkZXI7XG59XG5cbnZhciBUT1BfRElDVF9NRVRBID0gW1xuICAgIHtuYW1lOiAndmVyc2lvbicsIG9wOiAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnY29weXJpZ2h0Jywgb3A6IDEyMDAsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2Z1bGxOYW1lJywgb3A6IDIsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnd2VpZ2h0Jywgb3A6IDQsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIG9wOiAxMjAxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgb3A6IDEyMDMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogLTEwMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCBvcDogMTIwNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA1MH0sXG4gICAge25hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJzdHJpbmdUeXBlJywgb3A6IDEyMDYsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMn0sXG4gICAge25hbWU6ICdmb250TWF0cml4Jywgb3A6IDEyMDcsIHR5cGU6IFsncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnXSwgdmFsdWU6IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJ30sXG4gICAge25hbWU6ICdmb250QkJveCcsIG9wOiA1LCB0eXBlOiBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddLCB2YWx1ZTogWzAsIDAsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3N0cm9rZVdpZHRoJywgb3A6IDEyMDgsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGx9LFxuICAgIHtuYW1lOiAnY2hhcnNldCcsIG9wOiAxNSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2VuY29kaW5nJywgb3A6IDE2LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdwcml2YXRlJywgb3A6IDE4LCB0eXBlOiBbJ251bWJlcicsICdvZmZzZXQnXSwgdmFsdWU6IFswLCAwXX1cbl07XG5cbnZhciBQUklWQVRFX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH1cbl07XG5cbi8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG5mdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0O1xuICAgIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0O1xuICAgIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFBSSVZBVEVfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgcGFyc2VyLCBmb3JtYXQsIGNoYXJzZXQsIGksIHNpZCwgY291bnQ7XG4gICAgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgLy8gVGhlIC5ub3RkZWYgZ2x5cGggaXMgbm90IGluY2x1ZGVkLCBzbyBzdWJ0cmFjdCAxLlxuICAgIG5HbHlwaHMgLT0gMTtcbiAgICBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYXJzZXQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyc2V0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGVuY29kaW5nIGRhdGEuIE9ubHkgb25lIGVuY29kaW5nIGNhbiBiZSBzcGVjaWZpZWQgcGVyIGZvbnQuXG4vLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMiwgXCJFbmNvZGluZ3NcIi5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQsIGNoYXJzZXQpIHtcbiAgICB2YXIgZW5jLCBwYXJzZXIsIGZvcm1hdCwgbkNvZGVzLCBpLCBjb2RlLCBuUmFuZ2VzLCBmaXJzdCwgbkxlZnQsIGo7XG4gICAgZW5jID0ge307XG4gICAgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuQ29kZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29kZSA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBlbmNbY29kZV0gPSBpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGNvZGUgPSAxO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblJhbmdlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBuTGVmdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jLCBjaGFyc2V0KTtcbn1cblxuLy8gVGFrZSBpbiBjaGFyc3RyaW5nIGNvZGUgYW5kIHJldHVybiBhIEdseXBoIG9iamVjdC5cbi8vIFRoZSBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gdGhlIFR5cGUgMiBDaGFyc3RyaW5nIEZvcm1hdFxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFyc3RyMi5odG1cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnN0cmluZyhjb2RlLCBmb250LCBpbmRleCkge1xuICAgIHZhciBwLCBnbHlwaCwgc3RhY2ssIG5TdGVtcywgaGF2ZVdpZHRoLCB3aWR0aCwgeCwgeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCB2O1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgc3RhY2sgPSBbXTtcbiAgICBuU3RlbXMgPSAwO1xuICAgIGhhdmVXaWR0aCA9IGZhbHNlO1xuICAgIHdpZHRoID0gZm9udC5kZWZhdWx0V2lkdGhYO1xuICAgIHggPSB5ID0gMDtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgIHZhciBoYXNXaWR0aEFyZztcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gICAgICAgIGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgICAgICAgaWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgfVxuICAgICAgICBuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSkge1xuICAgICAgICB2YXIgaSwgYjEsIGIyLCBiMywgYjQsIGNvZGVJbmRleCwgc3VickNvZGU7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBoc3RlbVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzogLy8gdnN0ZW1cbiAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIHZtb3ZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTogLy8gcmxpbmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6IC8vIGhsaW5ldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzogLy8gdmxpbmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OiAvLyBycmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcbiAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIGZvbnQuc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5zdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTogLy8gcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAxMjogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNDogLy8gZW5kY2hhclxuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxODogLy8gaHN0ZW1obVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTk6IC8vIGhpbnRtYXNrXG4gICAgICAgICAgICBjYXNlIDIwOiAvLyBjbnRybWFza1xuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBpICs9IChuU3RlbXMgKyA3KSA+PiAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMTogLy8gcm1vdmV0b1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAyICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG4gICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjU6IC8vIHJsaW5lY3VydmVcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY6IC8vIHZ2Y3VydmV0b1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI3OiAvLyBoaGN1cnZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyODogLy8gc2hvcnRpbnRcbiAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSkgPj4gMTYpO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjk6IC8vIGNhbGxnc3ViclxuICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5nc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzA6IC8vIHZoY3VydmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodiA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2IC0gMTM5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgtKHYgLSAyNTEpICogMjU2IC0gYjEgLSAxMDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYjMgPSBjb2RlW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSB8IChiMyA8PCA4KSB8IGI0KSAvIDY1NTM2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZShjb2RlKTtcbiAgICBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLnBhdGggPSBwO1xuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBnbHlwaDtcbn1cblxuLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbi8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgdmFyIGJpYXM7XG4gICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgYmlhcyA9IDEwNztcbiAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgIGJpYXMgPSAxMTMxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICB9XG4gICAgcmV0dXJuIGJpYXM7XG59XG5cbi8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCkge1xuICAgIHZhciBoZWFkZXIsIG5hbWVJbmRleCwgdG9wRGljdEluZGV4LCBzdHJpbmdJbmRleCwgZ2xvYmFsU3VickluZGV4LCB0b3BEaWN0LCBwcml2YXRlRGljdE9mZnNldCwgcHJpdmF0ZURpY3QsXG4gICAgICAgIHN1YnJPZmZzZXQsIHN1YnJJbmRleCwgY2hhclN0cmluZywgY2hhclN0cmluZ3NJbmRleCwgY2hhcnNldCwgaTtcbiAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcbiAgICBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG4gICAgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBoZWFkZXIuZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgIHN0cmluZ0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCB0b3BEaWN0SW5kZXguZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG4gICAgZm9udC5nc3VicnMgPSBnbG9iYWxTdWJySW5kZXgub2JqZWN0cztcbiAgICBmb250LmdzdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5nc3VicnMpO1xuXG4gICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KHRvcERpY3RJbmRleC5vYmplY3RzWzBdKS5idWZmZXIpO1xuICAgIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQudGFibGVzLmNmZi50b3BEaWN0ID0gdG9wRGljdDtcblxuICAgIHByaXZhdGVEaWN0T2Zmc2V0ID0gc3RhcnQgKyB0b3BEaWN0Wydwcml2YXRlJ11bMV07XG4gICAgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVEaWN0T2Zmc2V0LCB0b3BEaWN0Wydwcml2YXRlJ11bMF0sIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgZm9udC5ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblxuICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcbiAgICAgICAgZm9udC5zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LnN1YnJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LnN1YnJzID0gW107XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gMDtcbiAgICB9XG5cbiAgICAvLyBPZmZzZXRzIGluIHRoZSB0b3AgZGljdCBhcmUgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQ0ZGIGRhdGEsIHNvIGFkZCB0aGUgQ0ZGIHN0YXJ0IG9mZnNldC5cbiAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgIGZvbnQubkdseXBocyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0cy5sZW5ndGg7XG5cbiAgICBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyc2V0LCBmb250Lm5HbHlwaHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7IC8vIFN0YW5kYXJkIGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jb2RpbmcuY2ZmU3RhbmRhcmRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7IC8vIEV4cGVydCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IGVuY29kaW5nLkNmZkVuY29kaW5nKGVuY29kaW5nLmNmZkV4cGVydEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCArIHRvcERpY3QuZW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH1cbiAgICAvLyBQcmVmZXIgdGhlIENNQVAgZW5jb2RpbmcgdG8gdGhlIENGRiBlbmNvZGluZy5cbiAgICBmb250LmVuY29kaW5nID0gZm9udC5lbmNvZGluZyB8fCBmb250LmNmZkVuY29kaW5nO1xuXG4gICAgZm9udC5nbHlwaHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgY2hhclN0cmluZyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0c1tpXTtcbiAgICAgICAgZm9udC5nbHlwaHMucHVzaChwYXJzZUNGRkNoYXJzdHJpbmcoY2hhclN0cmluZywgZm9udCwgaSkpO1xuICAgIH1cbn1cblxuXG4vLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgU3RyaW5nIElEIChTSUQpLlxuLy8gVGhlIGxpc3Qgb2Ygc3RyaW5ncyBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzLCBzdHJpbmdzKSB7XG4gICAgdmFyIGksIHNpZDtcbiAgICAvLyBJcyB0aGUgc3RyaW5nIGluIHRoZSBDRkYgc3RhbmRhcmQgc3RyaW5ncz9cbiAgICBpID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBzaWQgPSBpO1xuICAgIH1cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGFscmVhZHkgaW4gdGhlIHN0cmluZyBpbmRleD9cbiAgICBpID0gc3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaSArIGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lkID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aCArIHN0cmluZ3MubGVuZ3RoO1xuICAgICAgICBzdHJpbmdzLnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiBzaWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkZXIoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnSGVhZGVyJywgW1xuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ21pbm9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2hkclNpemUnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVJbmRleChmb250TmFtZXMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnTmFtZSBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICduYW1lcycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0Lm5hbWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250TmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5uYW1lcy5wdXNoKHtuYW1lOiAnbmFtZV8nICsgaSwgdHlwZTogJ05BTUUnLCB2YWx1ZTogZm9udE5hbWVzW2ldfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIHZhciBtID0ge30sIGksIGVudHJ5LCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbnRyeSA9IG1ldGFbaV07XG4gICAgICAgIHZhbHVlID0gYXR0cnNbZW50cnkubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcXVhbHModmFsdWUsIGVudHJ5LnZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVTdHJpbmcodmFsdWUsIHN0cmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVtlbnRyeS5vcF0gPSB7bmFtZTogZW50cnkubmFtZSwgdHlwZTogZW50cnkudHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gVGhlIFRvcCBESUNUIGhvdXNlcyB0aGUgZ2xvYmFsIGZvbnQgYXR0cmlidXRlcy5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ1RvcCBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdUb3AgRElDVCBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICd0b3BEaWN0cycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnRvcERpY3RzID0gW3tuYW1lOiAndG9wRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHRvcERpY3R9XTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnU3RyaW5nIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuc3RyaW5ncy5wdXNoKHtuYW1lOiAnc3RyaW5nXycgKyBpLCB0eXBlOiAnU1RSSU5HJywgdmFsdWU6IHN0cmluZ3NbaV19KTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VHbG9iYWxTdWJySW5kZXgoKSB7XG4gICAgLy8gQ3VycmVudGx5IHdlIGRvbid0IHVzZSBzdWJyb3V0aW5lcy5cbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdHbG9iYWwgU3ViciBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdzdWJycycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ2hhcnNldHMnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE5hbWUgPSBnbHlwaE5hbWVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhTSUQgPSBlbmNvZGVTdHJpbmcoZ2x5cGhOYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnU0lEJywgdmFsdWU6IGdseXBoU0lEfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBnbHlwaFRvT3BzKGdseXBoKSB7XG4gICAgdmFyIG9wcyA9IFtdLCBwYXRoID0gZ2x5cGgucGF0aCwgeCwgeSwgaSwgY21kLCBkeCwgZHksIGR4MSwgZHkxLCBkeDIsIGR5MjtcbiAgICBvcHMucHVzaCh7bmFtZTogJ3dpZHRoJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBnbHlwaC5hZHZhbmNlV2lkdGh9KTtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgZHggPSBjbWQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0geTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybW92ZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDIxfSk7XG4gICAgICAgICAgICB4ID0gY21kLng7XG4gICAgICAgICAgICB5ID0gY21kLnk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgZHggPSBjbWQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0geTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybGluZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDV9KTtcbiAgICAgICAgICAgIHggPSBjbWQueDtcbiAgICAgICAgICAgIHkgPSBjbWQueTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogQWRkIHN1cHBvcnQgZm9yIHF1YWQgY3VydmVzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyaXRpbmcgcXVhZCBjdXJ2ZXMgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgZHgxID0gY21kLngxIC0geDtcbiAgICAgICAgICAgIGR5MSA9IGNtZC55MSAtIHk7XG4gICAgICAgICAgICBkeDIgPSBjbWQueDIgLSBjbWQueDE7XG4gICAgICAgICAgICBkeTIgPSBjbWQueTIgLSBjbWQueTE7XG4gICAgICAgICAgICBkeCA9IGNtZC54IC0gY21kLngyO1xuICAgICAgICAgICAgZHkgPSBjbWQueSAtIGNtZC55MjtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdycmN1cnZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogOH0pO1xuICAgICAgICAgICAgeCA9IGNtZC54O1xuICAgICAgICAgICAgeSA9IGNtZC55O1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIC8vIENvbnRvdXJzIGFyZSBjbG9zZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHMucHVzaCh7bmFtZTogJ2VuZGNoYXInLCB0eXBlOiAnT1AnLCB2YWx1ZTogMTR9KTtcbiAgICByZXR1cm4gb3BzO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ2hhclN0cmluZ3MgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICB2YXIgb3BzID0gZ2x5cGhUb09wcyhnbHlwaCk7XG4gICAgICAgIHQuY2hhclN0cmluZ3MucHVzaCh7bmFtZTogZ2x5cGgubmFtZSwgdHlwZTogJ0NIQVJTVFJJTkcnLCB2YWx1ZTogb3BzfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlUHJpdmF0ZURpY3QoYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnUHJpdmF0ZSBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChQUklWQVRFX0RJQ1RfTUVUQSwgYXR0cnMsIHN0cmluZ3MpO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlUHJpdmF0ZURpY3RJbmRleChwcml2YXRlRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdQcml2YXRlIERJQ1QgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAncHJpdmF0ZURpY3RzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xuICAgIHQucHJpdmF0ZURpY3RzID0gW3tuYW1lOiAncHJpdmF0ZURpY3RfMCcsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBwcml2YXRlRGljdH1dO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlQ0ZGVGFibGUoZ2x5cGhzLCBvcHRpb25zKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ0NGRiAnLCBbXG4gICAgICAgIHtuYW1lOiAnaGVhZGVyJywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAnbmFtZUluZGV4JywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAndG9wRGljdEluZGV4JywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAnc3RyaW5nSW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdnbG9iYWxTdWJySW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdjaGFyc2V0cycsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJTdHJpbmdzSW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdwcml2YXRlRGljdEluZGV4JywgdHlwZTogJ1RBQkxFJ31cbiAgICBdKTtcblxuICAgIC8vIFdlIHVzZSBub24temVybyB2YWx1ZXMgZm9yIHRoZSBvZmZzZXRzIHNvIHRoYXQgdGhlIERJQ1QgZW5jb2RlcyB0aGVtLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIHNpemUgb2YgdGhlIFRvcCBESUNUIHBsYXlzIGEgcm9sZSBpbiBvZmZzZXQgY2FsY3VsYXRpb24sXG4gICAgLy8gYW5kIHRoZSBzaXplIHNob3VsZG4ndCBjaGFuZ2UgYWZ0ZXIgd2UndmUgd3JpdHRlbiBjb3JyZWN0IG9mZnNldHMuXG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgIGZ1bGxOYW1lOiBvcHRpb25zLmZ1bGxOYW1lLFxuICAgICAgICBmYW1pbHlOYW1lOiBvcHRpb25zLmZhbWlseU5hbWUsXG4gICAgICAgIHdlaWdodDogb3B0aW9ucy53ZWlnaHROYW1lLFxuICAgICAgICBjaGFyc2V0OiA5OTksXG4gICAgICAgIGVuY29kaW5nOiAwLFxuICAgICAgICBjaGFyU3RyaW5nczogOTk5LFxuICAgICAgICBwcml2YXRlOiBbMCwgOTk5XVxuICAgIH07XG5cbiAgICB2YXIgcHJpdmF0ZUF0dHJzID0ge307XG5cbiAgICB2YXIgZ2x5cGhOYW1lcyA9IFtdO1xuICAgIC8vIFNraXAgZmlyc3QgZ2x5cGggKC5ub3RkZWYpXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZ2x5cGhOYW1lcy5wdXNoKGdseXBoc1tpXS5uYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5ncyA9IFtdO1xuXG4gICAgdC5oZWFkZXIgPSBtYWtlSGVhZGVyKCk7XG4gICAgdC5uYW1lSW5kZXggPSBtYWtlTmFtZUluZGV4KFtvcHRpb25zLnBvc3RTY3JpcHROYW1lXSk7XG4gICAgdmFyIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuICAgIHQuZ2xvYmFsU3VickluZGV4ID0gbWFrZUdsb2JhbFN1YnJJbmRleCgpO1xuICAgIHQuY2hhcnNldHMgPSBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncyk7XG4gICAgdC5jaGFyU3RyaW5nc0luZGV4ID0gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKTtcbiAgICB2YXIgcHJpdmF0ZURpY3QgPSBtYWtlUHJpdmF0ZURpY3QocHJpdmF0ZUF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnByaXZhdGVEaWN0SW5kZXggPSBtYWtlUHJpdmF0ZURpY3RJbmRleChwcml2YXRlRGljdCk7XG5cbiAgICAvLyBOZWVkcyB0byBjb21lIGF0IHRoZSBlbmQsIHRvIGVuY29kZSBhbGwgY3VzdG9tIHN0cmluZ3MgdXNlZCBpbiB0aGUgZm9udC5cbiAgICB0LnN0cmluZ0luZGV4ID0gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpO1xuXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdC5oZWFkZXIuc2l6ZU9mKCkgK1xuICAgICAgICB0Lm5hbWVJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQudG9wRGljdEluZGV4LnNpemVPZigpICtcbiAgICAgICAgdC5zdHJpbmdJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQuZ2xvYmFsU3VickluZGV4LnNpemVPZigpO1xuICAgIGF0dHJzLmNoYXJzZXQgPSBzdGFydE9mZnNldDtcbiAgICBhdHRycy5lbmNvZGluZyA9IDA7IC8vIFdlIHVzZSB0aGUgQ0ZGIHN0YW5kYXJkIGVuY29kaW5nOyBwcm9wZXIgZW5jb2Rpbmcgd2lsbCBiZSBoYW5kbGVkIGluIGNtYXAuXG4gICAgYXR0cnMuY2hhclN0cmluZ3MgPSBhdHRycy5jaGFyc2V0ICsgdC5jaGFyc2V0cy5zaXplT2YoKTtcbiAgICBhdHRycy5wcml2YXRlWzFdID0gYXR0cnMuY2hhclN0cmluZ3MgKyB0LmNoYXJTdHJpbmdzSW5kZXguc2l6ZU9mKCk7XG5cbiAgICAvLyBSZWNyZWF0ZSB0aGUgVG9wIERJQ1QgSU5ERVggd2l0aCB0aGUgY29ycmVjdCBvZmZzZXRzLlxuICAgIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUNGRlRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUNGRlRhYmxlO1xuIiwiLy8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NtYXAuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgYGNtYXBgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbi8vIFRoZXJlIGFyZSBtYW55IGF2YWlsYWJsZSBmb3JtYXRzLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBXaW5kb3dzIGZvcm1hdCA0LlxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYENtYXBFbmNvZGluZ2Agb2JqZWN0IG9yIG51bGwgaWYgbm8gc3VwcG9ydGVkIGZvcm1hdCBjb3VsZCBiZSBmb3VuZC5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHZlcnNpb24sIG51bVRhYmxlcywgb2Zmc2V0LCBwbGF0Zm9ybUlkLCBlbmNvZGluZ0lkLCBmb3JtYXQsIHNlZ0NvdW50LFxuICAgICAgICBlbmRDb3VudFBhcnNlciwgc3RhcnRDb3VudFBhcnNlciwgaWREZWx0YVBhcnNlciwgaWRSYW5nZU9mZnNldFBhcnNlciwgZ2x5cGhJbmRleE9mZnNldCxcbiAgICAgICAgZW5kQ291bnQsIHN0YXJ0Q291bnQsIGksIGMsIGlkRGVsdGEsIGlkUmFuZ2VPZmZzZXQsIHAsIGdseXBoSW5kZXg7XG4gICAgdmFyIGNtYXAgPSB7fTtcbiAgICBjbWFwLnZlcnNpb24gPSB2ZXJzaW9uID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0KTtcbiAgICBjaGVjay5hcmd1bWVudCh2ZXJzaW9uID09PSAwLCAnY21hcCB0YWJsZSB2ZXJzaW9uIHNob3VsZCBiZSAwLicpO1xuXG4gICAgLy8gVGhlIGNtYXAgdGFibGUgY2FuIGNvbnRhaW4gbWFueSBzdWItdGFibGVzLCBlYWNoIHdpdGggdGhlaXIgb3duIGZvcm1hdC5cbiAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gYSBcInBsYXRmb3JtIDNcIiB0YWJsZS4gVGhpcyBpcyBhIFdpbmRvd3MgZm9ybWF0LlxuICAgIGNtYXAubnVtdGFibGVzID0gbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgb2Zmc2V0ID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHBsYXRmb3JtSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSk7XG4gICAgICAgIGVuY29kaW5nSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDIpO1xuICAgICAgICBpZiAocGxhdGZvcm1JZCA9PT0gMyAmJiAoZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAwKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY21hcCB0YWJsZSBpbiB0aGUgZm9udCB0aGF0IHdlIHN1cHBvcnQsIHNvIHJldHVybiBudWxsLlxuICAgICAgICAvLyBUaGlzIGZvbnQgd2lsbCBiZSBtYXJrZWQgYXMgdW5zdXBwb3J0ZWQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICBjbWFwLmZvcm1hdCA9IGZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChmb3JtYXQgPT09IDQsICdPbmx5IGZvcm1hdCA0IGNtYXAgdGFibGVzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cbiAgICBjbWFwLnNlZ0NvdW50ID0gc2VnQ291bnQgPSBwLnBhcnNlVVNob3J0KCkgPj4gMTtcbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cbiAgICAvLyBUaGUgXCJ1bnJvbGxlZFwiIG1hcHBpbmcgZnJvbSBjaGFyYWN0ZXIgY29kZXMgdG8gZ2x5cGggaW5kaWNlcy5cbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcblxuICAgIGVuZENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE0KTtcbiAgICBzdGFydENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiAyKTtcbiAgICBpZERlbHRhUGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA0KTtcbiAgICBpZFJhbmdlT2Zmc2V0UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA2KTtcbiAgICBnbHlwaEluZGV4T2Zmc2V0ID0gc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogODtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnQ291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgICAgZW5kQ291bnQgPSBlbmRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBzdGFydENvdW50ID0gc3RhcnRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBpZERlbHRhID0gaWREZWx0YVBhcnNlci5wYXJzZVNob3J0KCk7XG4gICAgICAgIGlkUmFuZ2VPZmZzZXQgPSBpZFJhbmdlT2Zmc2V0UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGZvciAoYyA9IHN0YXJ0Q291bnQ7IGMgPD0gZW5kQ291bnQ7IGMgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGlkUmFuZ2VPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgaWRSYW5nZU9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ID0gKGlkUmFuZ2VPZmZzZXRQYXJzZXIub2Zmc2V0ICsgaWRSYW5nZU9mZnNldFBhcnNlci5yZWxhdGl2ZU9mZnNldCAtIDIpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgb2YgdGhlIGlkUmFuZ2VPZmZzZXQsIHdoaWNoIHdpbGwgbW92ZSB1cyBpbnRvIHRoZSBnbHlwaEluZGV4IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gaWRSYW5nZU9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCB0aGUgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSBjdXJyZW50IHNlZ21lbnQsIG11bHRpcGxpZWQgYnkgMiBmb3IgVVNIT1JUcy5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IChjIC0gc3RhcnRDb3VudCkgKiAyO1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgZ2x5cGhJbmRleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChnbHlwaEluZGV4ICsgaWREZWx0YSkgJiAweEZGRkY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGMgKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IGdseXBoSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNtYXA7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQodCwgY29kZSwgZ2x5cGhJbmRleCkge1xuICAgIHQuc2VnbWVudHMucHVzaCh7XG4gICAgICAgIGVuZDogY29kZSxcbiAgICAgICAgc3RhcnQ6IGNvZGUsXG4gICAgICAgIGRlbHRhOiAtKGNvZGUgLSBnbHlwaEluZGV4KSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IDB4RkZGRixcbiAgICAgICAgc3RhcnQ6IDB4RkZGRixcbiAgICAgICAgZGVsdGE6IDEsXG4gICAgICAgIG9mZnNldDogMFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ21hcFRhYmxlKGdseXBocykge1xuICAgIHZhciBpLCBqLCBnbHlwaDtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnY21hcCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAxMn0sXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA0fSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWdDb3VudFgyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZW50cnlTZWxlY3RvcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmFuZ2VTaGlmdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdKTtcblxuICAgIHQuc2VnbWVudHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGgudW5pY29kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFkZFNlZ21lbnQodCwgZ2x5cGgudW5pY29kZXNbal0sIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpO1xuXG4gICAgdmFyIHNlZ0NvdW50O1xuICAgIHNlZ0NvdW50ID0gdC5zZWdtZW50cy5sZW5ndGg7XG4gICAgdC5zZWdDb3VudFgyID0gc2VnQ291bnQgKiAyO1xuICAgIHQuc2VhcmNoUmFuZ2UgPSBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKHNlZ0NvdW50KSAvIE1hdGgubG9nKDIpKSkgKiAyO1xuICAgIHQuZW50cnlTZWxlY3RvciA9IE1hdGgubG9nKHQuc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGgubG9nKDIpO1xuICAgIHQucmFuZ2VTaGlmdCA9IHQuc2VnQ291bnRYMiAtIHQuc2VhcmNoUmFuZ2U7XG5cbiAgICAgLy8gU2V0IHVwIHBhcmFsbGVsIHNlZ21lbnQgYXJyYXlzLlxuICAgIHZhciBlbmRDb3VudHMgPSBbXSxcbiAgICAgICAgc3RhcnRDb3VudHMgPSBbXSxcbiAgICAgICAgaWREZWx0YXMgPSBbXSxcbiAgICAgICAgaWRSYW5nZU9mZnNldHMgPSBbXSxcbiAgICAgICAgZ2x5cGhJZHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdC5zZWdtZW50c1tpXTtcbiAgICAgICAgZW5kQ291bnRzID0gZW5kQ291bnRzLmNvbmNhdCh7bmFtZTogJ2VuZF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuICAgICAgICBzdGFydENvdW50cyA9IHN0YXJ0Q291bnRzLmNvbmNhdCh7bmFtZTogJ3N0YXJ0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcbiAgICAgICAgaWREZWx0YXMgPSBpZERlbHRhcy5jb25jYXQoe25hbWU6ICdpZERlbHRhXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5kZWx0YX0pO1xuICAgICAgICBpZFJhbmdlT2Zmc2V0cyA9IGlkUmFuZ2VPZmZzZXRzLmNvbmNhdCh7bmFtZTogJ2lkUmFuZ2VPZmZzZXRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5vZmZzZXR9KTtcbiAgICAgICAgaWYgKHNlZ21lbnQuZ2x5cGhJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbHlwaElkcyA9IGdseXBoSWRzLmNvbmNhdCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJZH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGVuZENvdW50cyk7XG4gICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3Jlc2VydmVkUGFkJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoc3RhcnRDb3VudHMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkRGVsdGFzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChpZFJhbmdlT2Zmc2V0cyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZ2x5cGhJZHMpO1xuXG4gICAgdC5sZW5ndGggPSAxNCArIC8vIFN1YnRhYmxlIGhlYWRlclxuICAgICAgICBlbmRDb3VudHMubGVuZ3RoICogMiArXG4gICAgICAgIDIgKyAvLyByZXNlcnZlZFBhZFxuICAgICAgICBzdGFydENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgaWREZWx0YXMubGVuZ3RoICogMiArXG4gICAgICAgIGlkUmFuZ2VPZmZzZXRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBnbHlwaElkcy5sZW5ndGggKiAyO1xuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VDbWFwVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlQ21hcFRhYmxlO1xuIiwiLy8gVGhlIGBnbHlmYCB0YWJsZSBkZXNjcmliZXMgdGhlIGdseXBocyBpbiBUcnVlVHlwZSBvdXRsaW5lIGZvcm1hdC5cbi8vIGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9nbHlmLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4uL2NoZWNrJyk7XG52YXIgX2dseXBoID0gcmVxdWlyZSgnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL3BhdGgnKTtcblxuLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgZGF0YSBmb3IgYSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHByZXZpb3VzVmFsdWUsIHNob3J0VmVjdG9yQml0TWFzaywgc2FtZUJpdE1hc2spIHtcbiAgICB2YXIgdjtcbiAgICBpZiAoKGZsYWcgJiBzaG9ydFZlY3RvckJpdE1hc2spID4gMCkge1xuICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZSBpcyAxIGJ5dGUgbG9uZy5cbiAgICAgICAgdiA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgIC8vIFRoZSBgc2FtZWAgYml0IGlzIHJlLXVzZWQgZm9yIHNob3J0IHZhbHVlcyB0byBzaWduaWZ5IHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID09PSAwKSB7XG4gICAgICAgICAgICB2ID0gLXY7XG4gICAgICAgIH1cbiAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG4gICAgICAgIC8vIElmIHRoZSBgc2FtZWAgYml0IGlzIHNldCwgdGhlIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGNvb3JkaW5hdGUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGgoZGF0YSwgc3RhcnQsIGluZGV4LCBmb250KSB7XG4gICAgdmFyIHAsIGdseXBoLCBmbGFnLCBpLCBqLCBmbGFncyxcbiAgICAgICAgZW5kUG9pbnRJbmRpY2VzLCBudW1iZXJPZkNvb3JkaW5hdGVzLCByZXBlYXRDb3VudCwgcG9pbnRzLCBwb2ludCwgcHgsIHB5LFxuICAgICAgICBjb21wb25lbnQsIG1vcmVDb21wb25lbnRzO1xuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC54TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGgueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC55TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPiAwKSB7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICBlbmRQb2ludEluZGljZXMgPSBnbHlwaC5lbmRQb2ludEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoLm51bWJlck9mQ29udG91cnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZW5kUG9pbnRJbmRpY2VzLnB1c2gocC5wYXJzZVVTaG9ydCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICBmbGFncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbGFnID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAvLyBJZiBiaXQgMyBpcyBzZXQsIHdlIHJlcGVhdCB0aGlzIGZsYWcgbiB0aW1lcywgd2hlcmUgbiBpcyB0aGUgbmV4dCBieXRlLlxuICAgICAgICAgICAgaWYgKChmbGFnICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByZXBlYXRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2suYXJndW1lbnQoZmxhZ3MubGVuZ3RoID09PSBudW1iZXJPZkNvb3JkaW5hdGVzLCAnQmFkIGZsYWdzLicpO1xuXG4gICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgICAgICAvLyBYL1kgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBwb2ludCwgZXhjZXB0IGZvciB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggaXMgcmVsYXRpdmUgdG8gMCwwLlxuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29vcmRpbmF0ZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm9uQ3VydmUgPSAhIShmbGFnICYgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lmxhc3RQb2ludE9mQ29udG91ciA9IGVuZFBvaW50SW5kaWNlcy5pbmRleE9mKGkpID49IDA7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB4LCAyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBweSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHksIDQsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID09PSAwKSB7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdseXBoLmlzQ29tcG9zaXRlID0gdHJ1ZTtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIGdseXBoLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgbW9yZUNvbXBvbmVudHMgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobW9yZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXg6IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuICAgICAgICAgICAgICAgICBzY2FsZTEwOiAwLFxuICAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgICBkeTogMFxuICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgd29yZHNcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgYnl0ZXNcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSAyeDIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMTAgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdseXBoO1xufVxuXG4vLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbmV3UG9pbnRzLCBpLCBwdCwgbmV3UHQ7XG4gICAgbmV3UG9pbnRzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgbmV3UHQgPSB7XG4gICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcbiAgICAgICAgICAgIHk6IHRyYW5zZm9ybS5zY2FsZTEwICogcHQueCArIHRyYW5zZm9ybS55U2NhbGUgKiBwdC55ICsgdHJhbnNmb3JtLmR5LFxuICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcbiAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuXG5mdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcbiAgICB2YXIgY29udG91cnMsIGN1cnJlbnRDb250b3VyLCBpLCBwdDtcbiAgICBjb250b3VycyA9IFtdO1xuICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICB2YXIgcCwgY29udG91cnMsIGksIHJlYWxGaXJzdFBvaW50LCBqLCBjb250b3VyLCBwdCwgZmlyc3RQdCxcbiAgICAgICAgcHJldlB0LCBtaWRQdCwgY3VydmVQdCwgbGFzdFB0O1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGNvbnRvdXJzID0gZ2V0Q29udG91cnMocG9pbnRzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29udG91cnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29udG91ciA9IGNvbnRvdXJzW2ldO1xuICAgICAgICBmaXJzdFB0ID0gY29udG91clswXTtcbiAgICAgICAgbGFzdFB0ID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZmlyc3RQdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCB3aWxsIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb3ZlVG8gY29tbWFuZCxcbiAgICAgICAgICAgIC8vIHNvIHNraXAgaXQgaW4gdGhlIGxvb3AuXG4gICAgICAgICAgICByZWFsRmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFzdFB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcG9pbnQgaXMgb2ZmLWN1cnZlIGFuZCB0aGUgbGFzdCBwb2ludCBpcyBvbi1jdXJ2ZSxcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCB0aGUgbGFzdCBwb2ludC5cbiAgICAgICAgICAgICAgICBmaXJzdFB0ID0gbGFzdFB0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgZmlyc3RQdCA9IHsgeDogKGZpcnN0UHQueCArIGxhc3RQdC54KSAvIDIsIHk6IChmaXJzdFB0LnkgKyBsYXN0UHQueSkgLyAyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gZmlyc3RQdDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCBpcyBzeW50aGVzaXplZCwgc28gZG9uJ3Qgc2tpcCB0aGUgcmVhbCBmaXJzdCBwb2ludC5cbiAgICAgICAgICAgIHJlYWxGaXJzdFBvaW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcC5tb3ZlVG8oZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuXG4gICAgICAgIGZvciAoaiA9IHJlYWxGaXJzdFBvaW50ID8gMSA6IDA7IGogPCBjb250b3VyLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBwdCA9IGNvbnRvdXJbal07XG4gICAgICAgICAgICBwcmV2UHQgPSBqID09PSAwID8gZmlyc3RQdCA6IGNvbnRvdXJbaiAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZQdC5vbkN1cnZlICYmIHB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlB0Lm9uQ3VydmUgJiYgIXB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZVB0ID0gcHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmV2UHQub25DdXJ2ZSAmJiAhcHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIG1pZFB0ID0geyB4OiAocHJldlB0LnggKyBwdC54KSAvIDIsIHk6IChwcmV2UHQueSArIHB0LnkpIC8gMiB9O1xuICAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhwcmV2UHQueCwgcHJldlB0LnksIG1pZFB0LngsIG1pZFB0LnkpO1xuICAgICAgICAgICAgICAgIGN1cnZlUHQgPSBwdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXByZXZQdC5vbkN1cnZlICYmIHB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2aW91cyBwb2ludCBvZmYtY3VydmUsIHRoaXMgcG9pbnQgb24tY3VydmUuXG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlUHQueCwgY3VydmVQdC55LCBwdC54LCBwdC55KTtcbiAgICAgICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFB0ICE9PSBsYXN0UHQpIHtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIGxhc3QgYW5kIGZpcnN0IHBvaW50c1xuICAgICAgICAgICAgaWYgKGN1cnZlUHQpIHtcbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3VydmVQdC54LCBjdXJ2ZVB0LnksIGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcC5saW5lVG8oZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMsIGksIGosIG9mZnNldCwgbmV4dE9mZnNldCwgZ2x5cGgsXG4gICAgICAgIGNvbXBvbmVudCwgY29tcG9uZW50R2x5cGgsIHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIGdseXBocyA9IFtdO1xuICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvY2EgdGFibGUgaXMgaW52YWxpZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBuZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChwYXJzZUdseXBoKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBpLCBmb250KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChuZXcgX2dseXBoLkdseXBoKHtmb250OiBmb250LCBpbmRleDogaX0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHbyBvdmVyIHRoZSBnbHlwaHMgYWdhaW4sIHJlc29sdmluZyB0aGUgY29tcG9zaXRlIGdseXBocy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBpZiAoZ2x5cGguaXNDb21wb3NpdGUpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaC5jb21wb25lbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZ2x5cGguY29tcG9uZW50c1tqXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRHbHlwaCA9IGdseXBoc1tjb21wb25lbnQuZ2x5cGhJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEdseXBoLnBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IGdseXBoLnBvaW50cy5jb25jYXQodHJhbnNmb3JtZWRQb2ludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnbHlwaC5wYXRoID0gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VHbHlmVGFibGU7XG4iLCIvLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcblxuLy8gUGFyc2UgU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgdGFibGVzIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzLlxuLy8gVGhlc2UgbGlzdHMgYXJlIHVudXNlZCBieSBub3csIHRoaXMgZnVuY3Rpb24gaXMganVzdCB0aGUgYmFzaXMgZm9yIGEgcmVhbCBwYXJzaW5nLlxuZnVuY3Rpb24gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBuID0gcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGlzdFtwLnBhcnNlVGFnKCldID0geyBvZmZzZXQ6IHAucGFyc2VVU2hvcnQoKSB9O1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gUGFyc2UgYSBjb3ZlcmFnZSB0YWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIEZvcm1hdCAxIGlzIGEgc2ltcGxlIGxpc3Qgb2YgZ2x5cGggaWRzLFxuLy8gRm9ybWF0IDIgaXMgYSBsaXN0IG9mIHJhbmdlcy4gSXQgaXMgZXhwYW5kZWQgaW4gYSBsaXN0IG9mIGdseXBocywgbWF5YmUgbm90IHRoZSBiZXN0IGlkZWEuXG5mdW5jdGlvbiBwYXJzZUNvdmVyYWdlVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgIGNvdW50ID0gIHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwLnBhcnNlVVNob3J0TGlzdChjb3VudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgaSwgYmVnaW4sIGVuZCwgaW5kZXgsIGNvdmVyYWdlID0gW107XG4gICAgICAgIGZvciAoOyBjb3VudC0tOykge1xuICAgICAgICAgICAgYmVnaW4gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBlbmQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBpbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2VbaW5kZXgrK10gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3ZlcmFnZTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgQ2xhc3MgRGVmaW5pdGlvbiBUYWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGdldHMgYSBjbGFzcyB2YWx1ZSBmcm9tIGEgZ2x5cGggSUQuXG5mdW5jdGlvbiBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBGb3JtYXQgMSBzcGVjaWZpZXMgYSByYW5nZSBvZiBjb25zZWN1dGl2ZSBnbHlwaCBpbmRpY2VzLCBvbmUgY2xhc3MgcGVyIGdseXBoIElELlxuICAgICAgICB2YXIgc3RhcnRHbHlwaCA9IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgIGdseXBoQ291bnQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICBjbGFzc2VzID0gcC5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihnbHlwaElEKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlc1tnbHlwaElEIC0gc3RhcnRHbHlwaF0gfHwgMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIC8vIEZvcm1hdCAyIGRlZmluZXMgbXVsdGlwbGUgZ3JvdXBzIG9mIGdseXBoIGluZGljZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHNhbWUgY2xhc3MuXG4gICAgICAgIHZhciByYW5nZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgc3RhcnRHbHlwaHMgPSBbXSxcbiAgICAgICAgICAgIGVuZEdseXBocyA9IFtdLFxuICAgICAgICAgICAgY2xhc3NWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZW5kR2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY2xhc3NWYWx1ZXNbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGdseXBoSUQpIHtcbiAgICAgICAgICAgIHZhciBsLCBjLCByO1xuICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgICByID0gc3RhcnRHbHlwaHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICAgICAgICAgIGMgPSAobCArIHIgKyAxKSA+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaElEIDwgc3RhcnRHbHlwaHNbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IGMgLSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEdseXBoc1tsXSA8PSBnbHlwaElEICYmIGdseXBoSUQgPD0gZW5kR2x5cGhzW2xdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzVmFsdWVzW2xdIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgcGFpciBhZGp1c3RtZW50IHBvc2l0aW9uaW5nIHN1YnRhYmxlLCBmb3JtYXQgMSBvciBmb3JtYXQgMlxuLy8gVGhlIHN1YnRhYmxlIGlzIHJldHVybmVkIGluIHRoZSBmb3JtIG9mIGEgbG9va3VwIGZ1bmN0aW9uLlxuZnVuY3Rpb24gcGFyc2VQYWlyUG9zU3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQsIGNvdmVyYWdlT2Zmc2V0LCBjb3ZlcmFnZSwgdmFsdWVGb3JtYXQxLCB2YWx1ZUZvcm1hdDIsXG4gICAgICAgIHNoYXJlZFBhaXJTZXRzLCBmaXJzdEdseXBoLCBzZWNvbmRHbHlwaCwgdmFsdWUxLCB2YWx1ZTI7XG4gICAgLy8gVGhpcyBwYXJ0IGlzIGNvbW1vbiB0byBmb3JtYXQgMSBhbmQgZm9ybWF0IDIgc3VidGFibGVzXG4gICAgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvdmVyYWdlT2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvdmVyYWdlID0gcGFyc2VDb3ZlcmFnZVRhYmxlKGRhdGEsIHN0YXJ0K2NvdmVyYWdlT2Zmc2V0KTtcbiAgICAvLyB2YWx1ZUZvcm1hdCA0OiBYQWR2YW5jZSBvbmx5LCAxOiBYUGxhY2VtZW50IG9ubHksIDA6IG5vIFZhbHVlUmVjb3JkIGZvciBzZWNvbmQgZ2x5cGhcbiAgICAvLyBPbmx5IHZhbHVlRm9ybWF0MT00IGFuZCB2YWx1ZUZvcm1hdDI9MCBpcyBzdXBwb3J0ZWQuXG4gICAgdmFsdWVGb3JtYXQxID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhbHVlRm9ybWF0MiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAodmFsdWVGb3JtYXQxICE9PSA0IHx8IHZhbHVlRm9ybWF0MiAhPT0gMCkgcmV0dXJuO1xuICAgIHNoYXJlZFBhaXJTZXRzID0ge307XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBQYWlyIFBvc2l0aW9uaW5nIEFkanVzdG1lbnQ6IEZvcm1hdCAxXG4gICAgICAgIHZhciBwYWlyU2V0Q291bnQsIHBhaXJTZXRPZmZzZXRzLCBwYWlyU2V0T2Zmc2V0LCBzaGFyZWRQYWlyU2V0LCBwYWlyVmFsdWVDb3VudCwgcGFpclNldDtcbiAgICAgICAgcGFpclNldENvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwYWlyU2V0ID0gW107XG4gICAgICAgIC8vIEFycmF5IG9mIG9mZnNldHMgdG8gUGFpclNldCB0YWJsZXMtZnJvbSBiZWdpbm5pbmcgb2YgUGFpclBvcyBzdWJ0YWJsZS1vcmRlcmVkIGJ5IENvdmVyYWdlIEluZGV4XG4gICAgICAgIHBhaXJTZXRPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChwYWlyU2V0Q291bnQpO1xuICAgICAgICBmb3IgKGZpcnN0R2x5cGggPSAwOyBmaXJzdEdseXBoIDwgcGFpclNldENvdW50OyBmaXJzdEdseXBoKyspIHtcbiAgICAgICAgICAgIHBhaXJTZXRPZmZzZXQgPSBwYWlyU2V0T2Zmc2V0c1tmaXJzdEdseXBoXTtcbiAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSBzaGFyZWRQYWlyU2V0c1twYWlyU2V0T2Zmc2V0XTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkUGFpclNldCkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcGFpcnNldCB0YWJsZSBpbiBhIHBhaXIgYWRqdXN0bWVudCBzdWJ0YWJsZSBmb3JtYXQgMVxuICAgICAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBwLnJlbGF0aXZlT2Zmc2V0ID0gcGFpclNldE9mZnNldDtcbiAgICAgICAgICAgICAgICBwYWlyVmFsdWVDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgcGFpclZhbHVlQ291bnQtLTspIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kR2x5cGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUZvcm1hdDEpIHZhbHVlMSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVGb3JtYXQyKSB2YWx1ZTIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHZhbHVlMSBpcyB0aGUgWEFkdmFuY2UgYW5kIHZhbHVlMiBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkUGFpclNldFtzZWNvbmRHbHlwaF0gPSB2YWx1ZTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFpclNldFtjb3ZlcmFnZVtmaXJzdEdseXBoXV0gPSBzaGFyZWRQYWlyU2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlycyA9IHBhaXJTZXRbbGVmdEdseXBoXTtcbiAgICAgICAgICAgIGlmIChwYWlycykgcmV0dXJuIHBhaXJzW3JpZ2h0R2x5cGhdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgLy8gUGFpciBQb3NpdGlvbmluZyBBZGp1c3RtZW50OiBGb3JtYXQgMlxuICAgICAgICB2YXIgY2xhc3NEZWYxT2Zmc2V0LCBjbGFzc0RlZjJPZmZzZXQsIGNsYXNzMUNvdW50LCBjbGFzczJDb3VudCwgaSwgaixcbiAgICAgICAgICAgIGdldENsYXNzMSwgZ2V0Q2xhc3MyLCBrZXJuaW5nTWF0cml4LCBrZXJuaW5nUm93LCBjb3ZlcmVkO1xuICAgICAgICBjbGFzc0RlZjFPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNsYXNzRGVmMk9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY2xhc3MxQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNsYXNzMkNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnZXRDbGFzczEgPSBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQrY2xhc3NEZWYxT2Zmc2V0KTtcbiAgICAgICAgZ2V0Q2xhc3MyID0gcGFyc2VDbGFzc0RlZlRhYmxlKGRhdGEsIHN0YXJ0K2NsYXNzRGVmMk9mZnNldCk7XG5cbiAgICAgICAgLy8gUGFyc2Uga2VybmluZyB2YWx1ZXMgYnkgY2xhc3MgcGFpci5cbiAgICAgICAga2VybmluZ01hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xhc3MxQ291bnQ7IGkrKykge1xuICAgICAgICAgICAga2VybmluZ1JvdyA9IGtlcm5pbmdNYXRyaXhbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjbGFzczJDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MSkgdmFsdWUxID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MikgdmFsdWUyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgLy8gc28gdmFsdWUxIGlzIHRoZSBYQWR2YW5jZSBhbmQgdmFsdWUyIGlzIGVtcHR5LlxuICAgICAgICAgICAgICAgIGtlcm5pbmdSb3dbal0gPSB2YWx1ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGNvdmVyYWdlIGxpc3QgdG8gYSBoYXNoXG4gICAgICAgIGNvdmVyZWQgPSB7fTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgY292ZXJhZ2UubGVuZ3RoOyBpKyspIGNvdmVyZWRbY292ZXJhZ2VbaV1dID0gMTtcblxuICAgICAgICAvLyBHZXQgdGhlIGtlcm5pbmcgdmFsdWUgZm9yIGEgc3BlY2lmaWMgZ2x5cGggcGFpci5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkW2xlZnRHbHlwaF0pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGNsYXNzMSA9IGdldENsYXNzMShsZWZ0R2x5cGgpLFxuICAgICAgICAgICAgICAgIGNsYXNzMiA9IGdldENsYXNzMihyaWdodEdseXBoKSxcbiAgICAgICAgICAgICAgICBrZXJuaW5nUm93ID0ga2VybmluZ01hdHJpeFtjbGFzczFdO1xuICAgICAgICAgICAgcmV0dXJuIGtlcm5pbmdSb3cgPyBrZXJuaW5nUm93W2NsYXNzMl0gOiBudWxsO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBMb29rdXBUYWJsZSAocHJlc2VudCBpbiBvZiBHUE9TLCBHU1VCLCBHREVGLCBCQVNFLCBKU1RGIHRhYmxlcykuXG5mdW5jdGlvbiBwYXJzZUxvb2t1cFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGUsIGxvb2t1cFR5cGUsIGxvb2t1cEZsYWcsIHVzZU1hcmtGaWx0ZXJpbmdTZXQsIHN1YlRhYmxlQ291bnQsIHN1YlRhYmxlT2Zmc2V0cywgc3VidGFibGVzLCBpO1xuICAgIGxvb2t1cFR5cGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgbG9va3VwRmxhZyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgc3ViVGFibGVDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBzdWJUYWJsZU9mZnNldHMgPSBwLnBhcnNlT2Zmc2V0MTZMaXN0KHN1YlRhYmxlQ291bnQpO1xuICAgIHRhYmxlID0ge1xuICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICBsb29rdXBGbGFnOiBsb29rdXBGbGFnLFxuICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gcC5wYXJzZVVTaG9ydCgpIDogLTFcbiAgICB9O1xuICAgIC8vIExvb2t1cFR5cGUgMiwgUGFpciBhZGp1c3RtZW50XG4gICAgaWYgKGxvb2t1cFR5cGUgPT09IDIpIHtcbiAgICAgICAgc3VidGFibGVzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdWJUYWJsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN1YnRhYmxlcy5wdXNoKHBhcnNlUGFpclBvc1N1YlRhYmxlKGRhdGEsIHN0YXJ0ICsgc3ViVGFibGVPZmZzZXRzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggZmluZHMgdGhlIGtlcm5pbmcgdmFsdWVzIGluIHRoZSBzdWJ0YWJsZXMuXG4gICAgICAgIHRhYmxlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN1YnRhYmxlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdWJ0YWJsZXNbaV0obGVmdEdseXBoLCByaWdodEdseXBoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gUGFyc2UgdGhlIGBHUE9TYCB0YWJsZSB3aGljaCBjb250YWlucywgYW1vbmcgb3RoZXIgdGhpbmdzLCBrZXJuaW5nIHBhaXJzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9ncG9zLmh0bVxuZnVuY3Rpb24gcGFyc2VHcG9zVGFibGUoZGF0YSwgc3RhcnQsIGZvbnQpIHtcbiAgICB2YXIgcCwgdGFibGVWZXJzaW9uLCBsb29rdXBMaXN0T2Zmc2V0LCBzY3JpcHRMaXN0LCBpLCBmZWF0dXJlTGlzdCwgbG9va3VwQ291bnQsXG4gICAgICAgIGxvb2t1cFRhYmxlT2Zmc2V0cywgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0LCB0YWJsZTtcblxuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB0YWJsZVZlcnNpb24gPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBHUE9TIHRhYmxlIHZlcnNpb24uJyk7XG5cbiAgICAvLyBTY3JpcHRMaXN0IGFuZCBGZWF0dXJlTGlzdCAtIGlnbm9yZWQgZm9yIG5vd1xuICAgIHNjcmlwdExpc3QgPSBwYXJzZVRhZ2dlZExpc3RUYWJsZShkYXRhLCBzdGFydCtwLnBhcnNlVVNob3J0KCkpO1xuICAgIC8vICdrZXJuJyBpcyB0aGUgZmVhdHVyZSB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgZmVhdHVyZUxpc3QgPSBwYXJzZVRhZ2dlZExpc3RUYWJsZShkYXRhLCBzdGFydCtwLnBhcnNlVVNob3J0KCkpO1xuXG4gICAgLy8gTG9va3VwTGlzdFxuICAgIGxvb2t1cExpc3RPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgcC5yZWxhdGl2ZU9mZnNldCA9IGxvb2t1cExpc3RPZmZzZXQ7XG4gICAgbG9va3VwQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgbG9va3VwVGFibGVPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChsb29rdXBDb3VudCk7XG4gICAgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0ID0gc3RhcnQgKyBsb29rdXBMaXN0T2Zmc2V0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBsb29rdXBDb3VudDsgaSsrKSB7XG4gICAgICAgIHRhYmxlID0gcGFyc2VMb29rdXBUYWJsZShkYXRhLCBsb29rdXBMaXN0QWJzb2x1dGVPZmZzZXQgKyBsb29rdXBUYWJsZU9mZnNldHNbaV0pO1xuICAgICAgICBpZiAodGFibGUubG9va3VwVHlwZSA9PT0gMiAmJiAhZm9udC5nZXRHcG9zS2VybmluZ1ZhbHVlKSBmb250LmdldEdwb3NLZXJuaW5nVmFsdWUgPSB0YWJsZS5nZXRLZXJuaW5nVmFsdWU7XG4gICAgfVxufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VHcG9zVGFibGU7XG4iLCIvLyBUaGUgYGhlYWRgIHRhYmxlIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaGVhZC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBoZWFkZXIgYGhlYWRgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhlYWRUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhlYWQuZm9udFJldmlzaW9uID0gTWF0aC5yb3VuZChwLnBhcnNlRml4ZWQoKSAqIDEwMDApIC8gMTAwMDtcbiAgICBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGhlYWQubWFnaWNOdW1iZXIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudChoZWFkLm1hZ2ljTnVtYmVyID09PSAweDVGMEYzQ0Y1LCAnRm9udCBoZWFkZXIgaGFzIHdyb25nIG1hZ2ljIG51bWJlci4nKTtcbiAgICBoZWFkLmZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQudW5pdHNQZXJFbSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmNyZWF0ZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC5tb2RpZmllZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLnhNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLm1hY1N0eWxlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQubG93ZXN0UmVjUFBFTSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmZvbnREaXJlY3Rpb25IaW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5pbmRleFRvTG9jRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7ICAgICAvLyA1MFxuICAgIGhlYWQuZ2x5cGhEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hlYWQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdmb250UmV2aXNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW1BZGp1c3RtZW50JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hZ2ljTnVtYmVyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4NUYwRjNDRjV9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bml0c1BlckVtJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMDAwfSxcbiAgICAgICAge25hbWU6ICdjcmVhdGVkJywgdHlwZTogJ0xPTkdEQVRFVElNRScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtb2RpZmllZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1pbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3hNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneU1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYWNTdHlsZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbG93ZXN0UmVjUFBFTScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZm9udERpcmVjdGlvbkhpbnQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMn0sXG4gICAgICAgIHtuYW1lOiAnaW5kZXhUb0xvY0Zvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdnbHlwaERhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSGVhZFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhlYWRUYWJsZTtcbiIsIi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9oaGVhLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoaGVhID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHJldHVybiBoaGVhO1xufVxuXG5mdW5jdGlvbiBtYWtlSGhlYVRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoaGVhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnYXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZGVzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xpbmVHYXAnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYWR2YW5jZVdpZHRoTWF4JywgdHlwZTogJ1VGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5MZWZ0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluUmlnaHRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4RXh0ZW50JywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSaXNlJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSdW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQxJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDMnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQ0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21ldHJpY0RhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtYmVyT2ZITWV0cmljcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSGhlYVRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhoZWFUYWJsZTtcbiIsIi8vIFRoZSBgaG10eGAgdGFibGUgY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaG10eC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIGBobXR4YCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpIHtcbiAgICB2YXIgcCwgaSwgZ2x5cGgsIGFkdmFuY2VXaWR0aCwgbGVmdFNpZGVCZWFyaW5nO1xuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZvbnQgaXMgbW9ub3NwYWNlZCwgb25seSBvbmUgZW50cnkgaXMgbmVlZGVkLiBUaGlzIGxhc3QgZW50cnkgYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBnbHlwaHMuXG4gICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcbiAgICAgICAgZ2x5cGgubGVmdFNpZGVCZWFyaW5nID0gbGVmdFNpZGVCZWFyaW5nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUhtdHhUYWJsZShnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnaG10eCcsIFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIHZhciBhZHZhbmNlV2lkdGggPSBnbHlwaC5hZHZhbmNlV2lkdGggfHwgMDtcbiAgICAgICAgdmFyIGxlZnRTaWRlQmVhcmluZyA9IGdseXBoLmxlZnRTaWRlQmVhcmluZyB8fCAwO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnYWR2YW5jZVdpZHRoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGFkdmFuY2VXaWR0aH0pO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVmdFNpZGVCZWFyaW5nXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogbGVmdFNpZGVCZWFyaW5nfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VIbXR4VGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlSG10eFRhYmxlO1xuXG5cblxuIiwiLy8gVGhlIGBrZXJuYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuLy8gTm90ZSB0aGF0IHNvbWUgZm9udHMgdXNlIHRoZSBHUE9TIE9wZW5UeXBlIGxheW91dCB0YWJsZSB0byBzcGVjaWZ5IGtlcm5pbmcuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2tlcm4uaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG5cbi8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHBhaXJzLCBwLCB0YWJsZVZlcnNpb24sIHN1YlRhYmxlVmVyc2lvbiwgblBhaXJzLFxuICAgICAgICBpLCBsZWZ0SW5kZXgsIHJpZ2h0SW5kZXgsIHZhbHVlO1xuICAgIHBhaXJzID0ge307XG4gICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDAsICdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBuVGFibGVzLlxuICAgIHAuc2tpcCgndVNob3J0JywgMSk7XG4gICAgc3ViVGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YlRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBzdWJUYWJsZUxlbmd0aCwgc3ViVGFibGVDb3ZlcmFnZVxuICAgIHAuc2tpcCgndVNob3J0JywgMik7XG4gICAgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUtlcm5UYWJsZTtcbiIsIi8vIFRoZSBgbG9jYWAgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbG9jYS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xuXG4vLyBQYXJzZSB0aGUgYGxvY2FgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQsXG4vLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG4vLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuLy8gVGhlIGxvY2EgdGFibGUgaGFzIHR3byB2ZXJzaW9uczogYSBzaG9ydCB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1U2hvcnRzLCBhbmQgYSBsb25nXG4vLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG4vLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG5mdW5jdGlvbiBwYXJzZUxvY2FUYWJsZShkYXRhLCBzdGFydCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pIHtcbiAgICB2YXIgcCwgcGFyc2VGbiwgZ2x5cGhPZmZzZXRzLCBnbHlwaE9mZnNldCwgaTtcbiAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgcGFyc2VGbiA9IHNob3J0VmVyc2lvbiA/IHAucGFyc2VVU2hvcnQgOiBwLnBhcnNlVUxvbmc7XG4gICAgLy8gVGhlcmUgaXMgYW4gZXh0cmEgZW50cnkgYWZ0ZXIgdGhlIGxhc3QgaW5kZXggZWxlbWVudCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIGxhc3QgZ2x5cGguXG4gICAgLy8gVGhhdCdzIHdoeSB3ZSB1c2UgbnVtR2x5cGhzICsgMS5cbiAgICBnbHlwaE9mZnNldHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoT2Zmc2V0ID0gcGFyc2VGbi5jYWxsKHApO1xuICAgICAgICBpZiAoc2hvcnRWZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2hvcnQgdGFibGUgdmVyc2lvbiBzdG9yZXMgdGhlIGFjdHVhbCBvZmZzZXQgZGl2aWRlZCBieSAyLlxuICAgICAgICAgICAgZ2x5cGhPZmZzZXQgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUxvY2FUYWJsZTtcbiIsIi8vIFRoZSBgbWF4cGAgdGFibGUgZXN0YWJsaXNoZXMgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIHRoZSBmb250LlxuLy8gV2UgbmVlZCBpdCBqdXN0IHRvIGdldCB0aGUgbnVtYmVyIG9mIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbWF4cC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIG1heGltdW0gcHJvZmlsZSBgbWF4cGAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZU1heHBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBtYXhwID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBtYXhwLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIG1heHAubnVtR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChtYXhwLnZlcnNpb24gPT09IDEuMCkge1xuICAgICAgICBtYXhwLm1heFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlQ29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Wm9uZXMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4VHdpbGlnaHRQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RvcmFnZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhGdW5jdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4SW5zdHJ1Y3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0YWNrRWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudEVsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudERlcHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4cDtcbn1cblxuZnVuY3Rpb24gbWFrZU1heHBUYWJsZShudW1HbHlwaHMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdtYXhwJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAwNTAwMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtR2x5cGhzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBudW1HbHlwaHN9XG4gICAgXSk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZU1heHBUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VNYXhwVGFibGU7XG4iLCIvLyBUaGUgYG5hbWVgIG5hbWluZyB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbmFtZS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5jb2RlID0gcmVxdWlyZSgnLi4vdHlwZXMnKS5lbmNvZGU7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gTmFtZUlEcyBmb3IgdGhlIG5hbWUgdGFibGUuXG52YXIgbmFtZVRhYmxlTmFtZXMgPSBbXG4gICAgJ2NvcHlyaWdodCcsICAgICAgICAgICAgICAvLyAwXG4gICAgJ2ZvbnRGYW1pbHknLCAgICAgICAgICAgICAvLyAxXG4gICAgJ2ZvbnRTdWJmYW1pbHknLCAgICAgICAgICAvLyAyXG4gICAgJ3VuaXF1ZUlEJywgICAgICAgICAgICAgICAvLyAzXG4gICAgJ2Z1bGxOYW1lJywgICAgICAgICAgICAgICAvLyA0XG4gICAgJ3ZlcnNpb24nLCAgICAgICAgICAgICAgICAvLyA1XG4gICAgJ3Bvc3RTY3JpcHROYW1lJywgICAgICAgICAvLyA2XG4gICAgJ3RyYWRlbWFyaycsICAgICAgICAgICAgICAvLyA3XG4gICAgJ21hbnVmYWN0dXJlcicsICAgICAgICAgICAvLyA4XG4gICAgJ2Rlc2lnbmVyJywgICAgICAgICAgICAgICAvLyA5XG4gICAgJ2Rlc2NyaXB0aW9uJywgICAgICAgICAgICAvLyAxMFxuICAgICdtYW51ZmFjdHVyZXJVUkwnLCAgICAgICAgLy8gMTFcbiAgICAnZGVzaWduZXJVUkwnLCAgICAgICAgICAgIC8vIDEyXG4gICAgJ2xpY2VuY2UnLCAgICAgICAgICAgICAgICAvLyAxM1xuICAgICdsaWNlbmNlVVJMJywgICAgICAgICAgICAgLy8gMTRcbiAgICAncmVzZXJ2ZWQnLCAgICAgICAgICAgICAgIC8vIDE1XG4gICAgJ3ByZWZlcnJlZEZhbWlseScsICAgICAgICAvLyAxNlxuICAgICdwcmVmZXJyZWRTdWJmYW1pbHknLCAgICAgLy8gMTdcbiAgICAnY29tcGF0aWJsZUZ1bGxOYW1lJywgICAgIC8vIDE4XG4gICAgJ3NhbXBsZVRleHQnLCAgICAgICAgICAgICAvLyAxOVxuICAgICdwb3N0U2NyaXB0RmluZEZvbnROYW1lJywgLy8gMjBcbiAgICAnd3dzRmFtaWx5JywgICAgICAgICAgICAgIC8vIDIxXG4gICAgJ3d3c1N1YmZhbWlseScgICAgICAgICAgICAvLyAyMlxuXTtcblxuLy8gUGFyc2UgdGhlIG5hbWluZyBgbmFtZWAgdGFibGVcbi8vIE9ubHkgV2luZG93cyBVbmljb2RlIEVuZ2xpc2ggbmFtZXMgYXJlIHN1cHBvcnRlZC5cbi8vIEZvcm1hdCAxIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBwYXJzZU5hbWVUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBuYW1lID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBuYW1lLmZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgIHN0cmluZ09mZnNldCA9IHAub2Zmc2V0ICsgcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlELCBuYW1lSUQsIHByb3BlcnR5LCBieXRlTGVuZ3RoLFxuICAgICAgICBvZmZzZXQsIHN0ciwgaSwgaiwgY29kZVBvaW50cztcbiAgICB2YXIgdW5rbm93bkNvdW50ID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHBsYXRmb3JtSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGVuY29kaW5nSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGxhbmd1YWdlSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG5hbWVJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcHJvcGVydHkgPSBuYW1lVGFibGVOYW1lc1tuYW1lSURdO1xuICAgICAgICBieXRlTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIC8vIHBsYXRmb3JtSUQgLSBlbmNvZGluZ0lEIC0gbGFuZ3VhZ2VJRCBzdGFuZGFyZCBjb21iaW5hdGlvbnMgOlxuICAgICAgICAvLyAxIC0gMCAtIDAgOiBNYWNpbnRvc2gsIFJvbWFuLCBFbmdsaXNoXG4gICAgICAgIC8vIDMgLSAxIC0gMHg0MDkgOiBXaW5kb3dzLCBVbmljb2RlIEJNUCAoVUNTLTIpLCBlbi1VU1xuICAgICAgICBpZiAocGxhdGZvcm1JRCA9PT0gMyAmJiBlbmNvZGluZ0lEID09PSAxICYmIGxhbmd1YWdlSUQgPT09IDB4NDA5KSB7XG4gICAgICAgICAgICBjb2RlUG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aC8yO1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyssIG9mZnNldCArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50c1tqXSA9IHBhcnNlLmdldFNob3J0KGRhdGEsIHN0cmluZ09mZnNldCtvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG5hbWVbcHJvcGVydHldID0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkNvdW50Kys7XG4gICAgICAgICAgICAgICAgbmFtZVsndW5rbm93bicrdW5rbm93bkNvdW50XSA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGlmIChuYW1lLmZvcm1hdCA9PT0gMSkge1xuICAgICAgICBuYW1lLmxhbmdUYWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lUmVjb3JkKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQsIG5hbWVJRCwgbGVuZ3RoLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdOYW1lUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHBsYXRmb3JtSUR9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGVuY29kaW5nSUR9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmd1YWdlSUR9LFxuICAgICAgICB7bmFtZTogJ25hbWVJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBvZmZzZXR9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIGFkZE1hY2ludG9zaE5hbWVSZWNvcmQodCwgcmVjb3JkSUQsIHMsIG9mZnNldCkge1xuICAgIC8vIE1hY2ludG9zaCwgUm9tYW4sIEVuZ2xpc2hcbiAgICB2YXIgc3RyaW5nQnl0ZXMgPSBlbmNvZGUuU1RSSU5HKHMpO1xuICAgIHQucmVjb3Jkcy5wdXNoKG1ha2VOYW1lUmVjb3JkKDEsIDAsIDAsIHJlY29yZElELCBzdHJpbmdCeXRlcy5sZW5ndGgsIG9mZnNldCkpO1xuICAgIHQuc3RyaW5ncy5wdXNoKHN0cmluZ0J5dGVzKTtcbiAgICBvZmZzZXQgKz0gc3RyaW5nQnl0ZXMubGVuZ3RoO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGFkZFdpbmRvd3NOYW1lUmVjb3JkKHQsIHJlY29yZElELCBzLCBvZmZzZXQpIHtcbiAgICAvLyBXaW5kb3dzLCBVbmljb2RlIEJNUCAoVUNTLTIpLCBVUyBFbmdsaXNoXG4gICAgdmFyIHV0ZjE2Qnl0ZXMgPSBlbmNvZGUuVVRGMTYocyk7XG4gICAgdC5yZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQoMywgMSwgMHgwNDA5LCByZWNvcmRJRCwgdXRmMTZCeXRlcy5sZW5ndGgsIG9mZnNldCkpO1xuICAgIHQuc3RyaW5ncy5wdXNoKHV0ZjE2Qnl0ZXMpO1xuICAgIG9mZnNldCArPSB1dGYxNkJ5dGVzLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVRhYmxlKG9wdGlvbnMpIHtcbiAgICB2YXIgaSwgcztcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnbmFtZScsIFtcbiAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdPZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgdC5yZWNvcmRzID0gW107XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgLy8gQWRkIE1hY2ludG9zaCByZWNvcmRzIGZpcnN0XG4gICAgZm9yIChpID0gMDsgaSA8IG5hbWVUYWJsZU5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChvcHRpb25zW25hbWVUYWJsZU5hbWVzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gb3B0aW9uc1tuYW1lVGFibGVOYW1lc1tpXV07XG4gICAgICAgICAgICBvZmZzZXQgPSBhZGRNYWNpbnRvc2hOYW1lUmVjb3JkKHQsIGksIHMsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlbiBhZGQgV2luZG93cyByZWNvcmRzXG4gICAgZm9yIChpID0gMDsgaSA8IG5hbWVUYWJsZU5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChvcHRpb25zW25hbWVUYWJsZU5hbWVzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gb3B0aW9uc1tuYW1lVGFibGVOYW1lc1tpXV07XG4gICAgICAgICAgICBvZmZzZXQgPSBhZGRXaW5kb3dzTmFtZVJlY29yZCh0LCBpLCBzLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdC5jb3VudCA9IHQucmVjb3Jkcy5sZW5ndGg7XG4gICAgdC5zdHJpbmdPZmZzZXQgPSA2ICsgdC5jb3VudCAqIDEyO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0LnJlY29yZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3JlY29yZF8nICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHQucmVjb3Jkc1tpXX0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdC5zdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdMSVRFUkFMJywgdmFsdWU6IHQuc3RyaW5nc1tpXX0pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlTmFtZVRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZU5hbWVUYWJsZTtcbiIsIi8vIFRoZSBgT1MvMmAgdGFibGUgY29udGFpbnMgbWV0cmljcyByZXF1aXJlZCBpbiBPcGVuVHlwZSBmb250cy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3MyLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgT1MvMiBhbmQgV2luZG93cyBtZXRyaWNzIGBPUy8yYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VPUzJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBvczIgPSB7fSxcbiAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG9zMi52ZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi54QXZnQ2hhcldpZHRoID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2VpZ2h0Q2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2lkdGhDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuZnNUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0U2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0UG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc0ZhbWlseUNsYXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnBhbm9zZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBvczIucGFub3NlW2ldID0gcC5wYXJzZUJ5dGUoKTtcbiAgICB9XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi5hY2hWZW5kSUQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCkpO1xuICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNMYXN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvTGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChvczIudmVyc2lvbiA+PSAxKSB7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIGlmIChvczIudmVyc2lvbiA+PSAyKSB7XG4gICAgICAgIG9zMi5zeEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIuc0NhcEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIudXNEZWZhdWx0Q2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzQnJlYWtDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNNYXhDb250ZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gb3MyO1xufVxuXG5mdW5jdGlvbiBtYWtlT1MyVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ09TLzInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMHgwMDAzfSxcbiAgICAgICAge25hbWU6ICd4QXZnQ2hhcldpZHRoJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2VpZ2h0Q2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2lkdGhDbGFzcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZnNUeXBlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRZT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0U2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0UG9zaXRpb24nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc0ZhbWlseUNsYXNzJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JGYW1pbHlUeXBlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlNlcmlmU3R5bGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiV2VpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlByb3BvcnRpb24nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiQ29udHJhc3QnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiU3Ryb2tlVmFyaWF0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkFybVN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkxldHRlcmZvcm0nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiTWlkbGluZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JYSGVpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTMnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2U0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2FjaFZlbmRJRCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogJ1hYWFgnfSxcbiAgICAgICAge25hbWU6ICdmc1NlbGVjdGlvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNGaXJzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNMYXN0Q2hhckluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0FzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvRGVzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvTGluZUdhcCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpbkFzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5EZXNjZW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsQ29kZVBhZ2VSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc3hIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc0NhcEhlaWdodCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0RlZmF1bHRDaGFyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0JyZWFrQ2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNNYXhDb250ZXh0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VPUzJUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VPUzJUYWJsZTtcbiIsIi8vIFRoZSBgcG9zdGAgdGFibGUgc3RvcmVzIGFkZGl0aW9uYWwgUG9zdFNjcmlwdCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBnbHlwaCBuYW1lcy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvcG9zdC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5jb2RpbmcgPSByZXF1aXJlKCcuLi9lbmNvZGluZycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBQb3N0U2NyaXB0IGBwb3N0YCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VQb3N0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcG9zdCA9IHt9LFxuICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCksXG4gICAgICAgIGksIG5hbWVMZW5ndGg7XG4gICAgcG9zdC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBwb3N0Lml0YWxpY0FuZ2xlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcG9zdC51bmRlcmxpbmVQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QudW5kZXJsaW5lVGhpY2tuZXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC5pc0ZpeGVkUGl0Y2ggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgIGNhc2UgMTpcbiAgICAgICAgcG9zdC5uYW1lcyA9IGVuY29kaW5nLnN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvc3QubmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPj0gZW5jb2Rpbmcuc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuYW1lTGVuZ3RoID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICBwb3N0Lm5hbWVzLnB1c2gocC5wYXJzZVN0cmluZyhuYW1lTGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyLjU6XG4gICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHBvc3Qub2Zmc2V0ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBwb3N0Lm9mZnNldFtpXSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwb3N0O1xufVxuXG5mdW5jdGlvbiBtYWtlUG9zdFRhYmxlKCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3Bvc3QnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDMwMDAwfSxcbiAgICAgICAge25hbWU6ICdpdGFsaWNBbmdsZScsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlNDInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH1cbiAgICBdKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlUG9zdFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZVBvc3RUYWJsZTtcbiIsIi8vIFRoZSBgc2ZudGAgd3JhcHBlciBwcm92aWRlcyBvcmdhbml6YXRpb24gZm9yIHRoZSB0YWJsZXMgaW4gdGhlIGZvbnQuXG4vLyBJdCBpcyB0aGUgdG9wLWxldmVsIGRhdGEgc3RydWN0dXJlIGluIGEgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3RmZi5odG1cbi8vIFJlY29tbWVuZGF0aW9ucyBmb3IgY3JlYXRpbmcgT3BlblR5cGUgRm9udHM6XG4vLyBodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMxNDAvcmVjb20uaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbnZhciBjbWFwID0gcmVxdWlyZSgnLi9jbWFwJyk7XG52YXIgY2ZmID0gcmVxdWlyZSgnLi9jZmYnKTtcbnZhciBoZWFkID0gcmVxdWlyZSgnLi9oZWFkJyk7XG52YXIgaGhlYSA9IHJlcXVpcmUoJy4vaGhlYScpO1xudmFyIGhtdHggPSByZXF1aXJlKCcuL2htdHgnKTtcbnZhciBtYXhwID0gcmVxdWlyZSgnLi9tYXhwJyk7XG52YXIgX25hbWUgPSByZXF1aXJlKCcuL25hbWUnKTtcbnZhciBvczIgPSByZXF1aXJlKCcuL29zMicpO1xudmFyIHBvc3QgPSByZXF1aXJlKCcuL3Bvc3QnKTtcblxuZnVuY3Rpb24gbG9nMih2KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHYpIC8gTWF0aC5sb2coMikgfCAwO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpIHtcbiAgICB3aGlsZSAoYnl0ZXMubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgIH1cbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHN1bSArPSAoYnl0ZXNbaV0gPDwgMjQpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMl0gPDwgOCkgK1xuICAgICAgICAgICAgKGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuICAgIHN1bSAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gbWFrZVRhYmxlUmVjb3JkKHRhZywgY2hlY2tTdW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnVGFibGUgUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3RhZycsIHR5cGU6ICdUQUcnLCB2YWx1ZTogdGFnICE9PSB1bmRlZmluZWQgPyB0YWcgOiAnJ30sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW0nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY2hlY2tTdW0gIT09IHVuZGVmaW5lZCA/IGNoZWNrU3VtIDogMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IG9mZnNldCAhPT0gdW5kZWZpbmVkID8gb2Zmc2V0IDogMH0sXG4gICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogMH1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZVNmbnRUYWJsZSh0YWJsZXMpIHtcbiAgICB2YXIgc2ZudCA9IG5ldyB0YWJsZS5UYWJsZSgnc2ZudCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1RBRycsIHZhbHVlOiAnT1RUTyd9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgc2ZudC50YWJsZXMgPSB0YWJsZXM7XG4gICAgc2ZudC5udW1UYWJsZXMgPSB0YWJsZXMubGVuZ3RoO1xuICAgIHZhciBoaWdoZXN0UG93ZXJPZjIgPSBNYXRoLnBvdygyLCBsb2cyKHNmbnQubnVtVGFibGVzKSk7XG4gICAgc2ZudC5zZWFyY2hSYW5nZSA9IDE2ICogaGlnaGVzdFBvd2VyT2YyO1xuICAgIHNmbnQuZW50cnlTZWxlY3RvciA9IGxvZzIoaGlnaGVzdFBvd2VyT2YyKTtcbiAgICBzZm50LnJhbmdlU2hpZnQgPSBzZm50Lm51bVRhYmxlcyAqIDE2IC0gc2ZudC5zZWFyY2hSYW5nZTtcblxuICAgIHZhciByZWNvcmRGaWVsZHMgPSBbXTtcbiAgICB2YXIgdGFibGVGaWVsZHMgPSBbXTtcblxuICAgIHZhciBvZmZzZXQgPSBzZm50LnNpemVPZigpICsgKG1ha2VUYWJsZVJlY29yZCgpLnNpemVPZigpICogc2ZudC5udW1UYWJsZXMpO1xuICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdCA9IHRhYmxlc1tpXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQodC50YWJsZU5hbWUubGVuZ3RoID09PSA0LCAnVGFibGUgbmFtZScgKyB0LnRhYmxlTmFtZSArICcgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgdmFyIHRhYmxlTGVuZ3RoID0gdC5zaXplT2YoKTtcbiAgICAgICAgdmFyIHRhYmxlUmVjb3JkID0gbWFrZVRhYmxlUmVjb3JkKHQudGFibGVOYW1lLCBjb21wdXRlQ2hlY2tTdW0odC5lbmNvZGUoKSksIG9mZnNldCwgdGFibGVMZW5ndGgpO1xuICAgICAgICByZWNvcmRGaWVsZHMucHVzaCh7bmFtZTogdGFibGVSZWNvcmQudGFnICsgJyBUYWJsZSBSZWNvcmQnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogdGFibGVSZWNvcmR9KTtcbiAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogdC50YWJsZU5hbWUgKyAnIHRhYmxlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHR9KTtcbiAgICAgICAgb2Zmc2V0ICs9IHRhYmxlTGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudCghaXNOYU4ob2Zmc2V0KSwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQuJyk7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFibGUgcmVjb3JkcyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICByZWNvcmRGaWVsZHMuc29ydChmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgICAgIGlmIChyMS52YWx1ZS50YWcgPiByMi52YWx1ZS50YWcpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdChyZWNvcmRGaWVsZHMpO1xuICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHRhYmxlRmllbGRzKTtcbiAgICByZXR1cm4gc2ZudDtcbn1cblxuLy8gR2V0IHRoZSBtZXRyaWNzIGZvciBhIGNoYXJhY3Rlci4gSWYgdGhlIHN0cmluZyBoYXMgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXJcbi8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBtZXRyaWNzIGZvciB0aGUgZmlyc3QgYXZhaWxhYmxlIGNoYXJhY3Rlci5cbi8vIFlvdSBjYW4gcHJvdmlkZSBvcHRpb25hbCBmYWxsYmFjayBtZXRyaWNzIGlmIG5vIGNoYXJhY3RlcnMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIG1ldHJpY3NGb3JDaGFyKGZvbnQsIGNoYXJzLCBub3RGb3VuZE1ldHJpY3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZm9udC5jaGFyVG9HbHlwaEluZGV4KGNoYXJzW2ldKTtcbiAgICAgICAgaWYgKGdseXBoSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdEZvdW5kTWV0cmljcztcbn1cblxuLy8gUmV0dXJuIHRoZSBzbWFsbGVzdCBhbmQgbGFyZ2VzdCB1bmljb2RlIHZhbHVlcyBvZiB0aGUgY2hhcmFjdGVycyBpbiB0aGlzIGZvbnQuXG4vLyBGb3IgbW9zdCBmb250cyB0aGUgc21hbGxlc3QgdmFsdWUgd291bGQgYmUgMjAgKHNwYWNlKS5cbmZ1bmN0aW9uIGNoYXJDb2RlQm91bmRzKGdseXBocykge1xuICAgIHZhciBtaW5Db2RlLCBtYXhDb2RlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgaWYgKGdseXBoLnVuaWNvZGUgPj0gMjApIHtcbiAgICAgICAgICAgIGlmIChtaW5Db2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaW5Db2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGgudW5pY29kZSA8IG1pbkNvZGUpIHtcbiAgICAgICAgICAgICAgICBtaW5Db2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXhDb2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGgudW5pY29kZSA+IG1heENvZGUpIHtcbiAgICAgICAgICAgICAgICBtYXhDb2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21pbkNvZGUsIG1heENvZGVdO1xufVxuXG5mdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdW0gKz0gdnNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdW0gLyB2cy5sZW5ndGg7XG59XG5cbi8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbi8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuZnVuY3Rpb24gZm9udFRvU2ZudFRhYmxlKGZvbnQpIHtcbiAgICB2YXIgeE1pbnMgPSBbXTtcbiAgICB2YXIgeU1pbnMgPSBbXTtcbiAgICB2YXIgeE1heHMgPSBbXTtcbiAgICB2YXIgeU1heHMgPSBbXTtcbiAgICB2YXIgYWR2YW5jZVdpZHRocyA9IFtdO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmdzID0gW107XG4gICAgdmFyIHJpZ2h0U2lkZUJlYXJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tpXTtcbiAgICAgICAgLy8gU2tpcCBub24taW1wb3J0YW50IGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWV0cmljcyA9IGdseXBoLmdldE1ldHJpY3MoKTtcbiAgICAgICAgeE1pbnMucHVzaChtZXRyaWNzLnhNaW4pO1xuICAgICAgICB5TWlucy5wdXNoKG1ldHJpY3MueU1pbik7XG4gICAgICAgIHhNYXhzLnB1c2gobWV0cmljcy54TWF4KTtcbiAgICAgICAgeU1heHMucHVzaChtZXRyaWNzLnlNYXgpO1xuICAgICAgICBsZWZ0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcpO1xuICAgICAgICByaWdodFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyk7XG4gICAgICAgIGFkdmFuY2VXaWR0aHMucHVzaChnbHlwaC5hZHZhbmNlV2lkdGgpO1xuICAgIH1cbiAgICB2YXIgZ2xvYmFscyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeE1pbnMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5TWlucyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhNYXhzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeU1heHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGFkdmFuY2VXaWR0aHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhBdmc6IGF2ZXJhZ2UoYWR2YW5jZVdpZHRocyksXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1heExlZnRTaWRlQmVhcmluZzogTWF0aC5tYXguYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIHJpZ2h0U2lkZUJlYXJpbmdzKVxuICAgIH07XG4gICAgZ2xvYmFscy5hc2NlbmRlciA9IGdsb2JhbHMueU1heDtcbiAgICBnbG9iYWxzLmRlc2NlbmRlciA9IGdsb2JhbHMueU1pbjtcblxuICAgIHZhciBoZWFkVGFibGUgPSBoZWFkLm1ha2Uoe1xuICAgICAgICB1bml0c1BlckVtOiBmb250LnVuaXRzUGVyRW0sXG4gICAgICAgIHhNaW46IGdsb2JhbHMueE1pbixcbiAgICAgICAgeU1pbjogZ2xvYmFscy55TWluLFxuICAgICAgICB4TWF4OiBnbG9iYWxzLnhNYXgsXG4gICAgICAgIHlNYXg6IGdsb2JhbHMueU1heFxuICAgIH0pO1xuXG4gICAgdmFyIGhoZWFUYWJsZSA9IGhoZWEubWFrZSh7XG4gICAgICAgIC8vIEFkZGluZyBhIGxpdHRsZSBoZXJlIG1ha2VzIE9TIFggUXVpY2sgTG9vayBoYXBweVxuICAgICAgICBhc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heCxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pbkxlZnRTaWRlQmVhcmluZyxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5SaWdodFNpZGVCZWFyaW5nLFxuICAgICAgICB4TWF4RXh0ZW50OiBnbG9iYWxzLm1heExlZnRTaWRlQmVhcmluZyArIChnbG9iYWxzLnhNYXggLSBnbG9iYWxzLnhNaW4pLFxuICAgICAgICBudW1iZXJPZkhNZXRyaWNzOiBmb250LmdseXBocy5sZW5ndGhcbiAgICB9KTtcblxuICAgIHZhciBtYXhwVGFibGUgPSBtYXhwLm1ha2UoZm9udC5nbHlwaHMubGVuZ3RoKTtcblxuICAgIHZhciBjb2RlQm91bmRzID0gY2hhckNvZGVCb3VuZHMoZm9udC5nbHlwaHMpO1xuICAgIHZhciBvczJUYWJsZSA9IG9zMi5tYWtlKHtcbiAgICAgICAgeEF2Z0NoYXJXaWR0aDogTWF0aC5yb3VuZChnbG9iYWxzLmFkdmFuY2VXaWR0aEF2ZyksXG4gICAgICAgIHVzV2VpZ2h0Q2xhc3M6IDUwMCwgLy8gTWVkaXVtIEZJWE1FIE1ha2UgdGhpcyBjb25maWd1cmFibGVcbiAgICAgICAgdXNXaWR0aENsYXNzOiA1LCAvLyBNZWRpdW0gKG5vcm1hbCkgRklYTUUgTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBjb2RlQm91bmRzWzBdLFxuICAgICAgICB1c0xhc3RDaGFySW5kZXg6IGNvZGVCb3VuZHNbMV0sXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMTogMHgwMDAwMDAwMSwgLy8gQmFzaWMgTGF0aW5cbiAgICAgICAgLy8gU2VlIGh0dHA6Ly90eXBvcGhpbGUuY29tL25vZGUvMTMwODEgZm9yIG1vcmUgaW5mbyBvbiB2ZXJ0aWNhbCBtZXRyaWNzLlxuICAgICAgICAvLyBXZSBnZXQgbWV0cmljcyBmb3IgdHlwaWNhbCBjaGFyYWN0ZXJzIChzdWNoIGFzIFwieFwiIGZvciB4SGVpZ2h0KS5cbiAgICAgICAgLy8gV2UgcHJvdmlkZSBzb21lIGZhbGxiYWNrIGNoYXJhY3RlcnMgaWYgY2hhcmFjdGVycyBhcmUgdW5hdmFpbGFibGU6IHRoZWlyXG4gICAgICAgIC8vIG9yZGVyaW5nIHdhcyBjaG9zZW4gZXhwZXJpbWVudGFsbHkuXG4gICAgICAgIHNUeXBvQXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIHNUeXBvRGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgc1R5cG9MaW5lR2FwOiAwLFxuICAgICAgICB1c1dpbkFzY2VudDogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgdXNXaW5EZXNjZW50OiAtZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIHVsQ29kZVBhZ2VSYW5nZTE6IDB4MDAwMDAwMDEsIC8vIEJhc2ljIExhdGluXG4gICAgICAgIHN4SGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAneHl2dycsIHt5TWF4OiAwfSkueU1heCxcbiAgICAgICAgc0NhcEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ0hJS0xFRkpNTlRaQkRQUkFHT1FTVVZXWFknLCBnbG9iYWxzKS55TWF4LFxuICAgICAgICB1c0JyZWFrQ2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAgLy8gVXNlIHNwYWNlIGFzIHRoZSBicmVhayBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cbiAgICB9KTtcblxuXG4gICAgdmFyIGhtdHhUYWJsZSA9IGhtdHgubWFrZShmb250LmdseXBocyk7XG4gICAgdmFyIGNtYXBUYWJsZSA9IGNtYXAubWFrZShmb250LmdseXBocyk7XG5cbiAgICB2YXIgZnVsbE5hbWUgPSBmb250LmZhbWlseU5hbWUgKyAnICcgKyBmb250LnN0eWxlTmFtZTtcbiAgICB2YXIgcG9zdFNjcmlwdE5hbWUgPSBmb250LmZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIGZvbnQuc3R5bGVOYW1lO1xuICAgIHZhciBuYW1lVGFibGUgPSBfbmFtZS5tYWtlKHtcbiAgICAgICAgY29weXJpZ2h0OiBmb250LmNvcHlyaWdodCxcbiAgICAgICAgZm9udEZhbWlseTogZm9udC5mYW1pbHlOYW1lLFxuICAgICAgICBmb250U3ViZmFtaWx5OiBmb250LnN0eWxlTmFtZSxcbiAgICAgICAgdW5pcXVlSUQ6IGZvbnQubWFudWZhY3R1cmVyICsgJzonICsgZnVsbE5hbWUsXG4gICAgICAgIGZ1bGxOYW1lOiBmdWxsTmFtZSxcbiAgICAgICAgdmVyc2lvbjogZm9udC52ZXJzaW9uLFxuICAgICAgICBwb3N0U2NyaXB0TmFtZTogcG9zdFNjcmlwdE5hbWUsXG4gICAgICAgIHRyYWRlbWFyazogZm9udC50cmFkZW1hcmssXG4gICAgICAgIG1hbnVmYWN0dXJlcjogZm9udC5tYW51ZmFjdHVyZXIsXG4gICAgICAgIGRlc2lnbmVyOiBmb250LmRlc2lnbmVyLFxuICAgICAgICBkZXNjcmlwdGlvbjogZm9udC5kZXNjcmlwdGlvbixcbiAgICAgICAgbWFudWZhY3R1cmVyVVJMOiBmb250Lm1hbnVmYWN0dXJlclVSTCxcbiAgICAgICAgZGVzaWduZXJVUkw6IGZvbnQuZGVzaWduZXJVUkwsXG4gICAgICAgIGxpY2Vuc2U6IGZvbnQubGljZW5zZSxcbiAgICAgICAgbGljZW5zZVVSTDogZm9udC5saWNlbnNlVVJMLFxuICAgICAgICBwcmVmZXJyZWRGYW1pbHk6IGZvbnQuZmFtaWx5TmFtZSxcbiAgICAgICAgcHJlZmVycmVkU3ViZmFtaWx5OiBmb250LnN0eWxlTmFtZVxuICAgIH0pO1xuICAgIHZhciBwb3N0VGFibGUgPSBwb3N0Lm1ha2UoKTtcbiAgICB2YXIgY2ZmVGFibGUgPSBjZmYubWFrZShmb250LmdseXBocywge1xuICAgICAgICB2ZXJzaW9uOiBmb250LnZlcnNpb24sXG4gICAgICAgIGZ1bGxOYW1lOiBmdWxsTmFtZSxcbiAgICAgICAgZmFtaWx5TmFtZTogZm9udC5mYW1pbHlOYW1lLFxuICAgICAgICB3ZWlnaHROYW1lOiBmb250LnN0eWxlTmFtZSxcbiAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lXG4gICAgfSk7XG4gICAgLy8gT3JkZXIgdGhlIHRhYmxlcyBhY2NvcmRpbmcgdG8gdGhlIHRoZSBPcGVuVHlwZSBzcGVjaWZpY2F0aW9uIDEuNC5cbiAgICB2YXIgdGFibGVzID0gW2hlYWRUYWJsZSwgaGhlYVRhYmxlLCBtYXhwVGFibGUsIG9zMlRhYmxlLCBuYW1lVGFibGUsIGNtYXBUYWJsZSwgcG9zdFRhYmxlLCBjZmZUYWJsZSwgaG10eFRhYmxlXTtcblxuICAgIHZhciBzZm50VGFibGUgPSBtYWtlU2ZudFRhYmxlKHRhYmxlcyk7XG5cbiAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG4gICAgdmFyIGNoZWNrU3VtID0gY29tcHV0ZUNoZWNrU3VtKGJ5dGVzKTtcbiAgICBoZWFkVGFibGUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuXG4gICAgLy8gQnVpbGQgdGhlIGZvbnQgYWdhaW4sIG5vdyB3aXRoIHRoZSBwcm9wZXIgY2hlY2tTdW0uXG4gICAgc2ZudFRhYmxlID0gbWFrZVNmbnRUYWJsZSh0YWJsZXMpO1xuXG4gICAgcmV0dXJuIHNmbnRUYWJsZTtcbn1cblxuZXhwb3J0cy5jb21wdXRlQ2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW07XG5leHBvcnRzLm1ha2UgPSBtYWtlU2ZudFRhYmxlO1xuZXhwb3J0cy5mb250VG9UYWJsZSA9IGZvbnRUb1NmbnRUYWJsZTtcbiIsIi8vIERhdGEgdHlwZXMgdXNlZCBpbiB0aGUgT3BlblR5cGUgZm9udCBmaWxlLlxuLy8gQWxsIE9wZW5UeXBlIGZvbnRzIHVzZSBNb3Rvcm9sYS1zdHlsZSBieXRlIG9yZGVyaW5nIChCaWcgRW5kaWFuKVxuXG4vKiBnbG9iYWwgV2Vha01hcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcblxudmFyIExJTUlUMTYgPSAzMjc2ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMTYtYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyXjE1XG52YXIgTElNSVQzMiA9IDIxNDc0ODM2NDg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDMyLWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMiBeIDMxXG5cbnZhciBkZWNvZGUgPSB7fTtcbnZhciBlbmNvZGUgPSB7fTtcbnZhciBzaXplT2YgPSB7fTtcblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnN0YW50KHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xufVxuXG4vLyBPcGVuVHlwZSBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBDb252ZXJ0IGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDEgYnl0ZS5cbmVuY29kZS5CWVRFID0gZnVuY3Rpb24gKHYpIHtcbiAgICBjaGVjay5hcmd1bWVudCh2ID49IDAgJiYgdiA8PSAyNTUsICdCeXRlIHZhbHVlIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nKTtcbiAgICByZXR1cm4gW3ZdO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG5lbmNvZGUuQ0hBUiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCldO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkNIQVJBUlJBWSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYi5wdXNoKHYuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICAgIHJldHVybiBiO1xufTtcblxuc2l6ZU9mLkNIQVJBUlJBWSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5VU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCBzaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMiBieXRlcy5cbmVuY29kZS5TSE9SVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMTYpe1xuICAgICAgICB2ID0gLSAoIDIgKiBMSU1JVDE2IC0gdik7XG4gICAgfVxuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLy8gQ29udmVydCBhIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAzIGJ5dGVzLlxuZW5jb2RlLlVJTlQyNCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFsodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5VSU5UMjQgPSBjb25zdGFudCgzKTtcblxuLy8gQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuZW5jb2RlLlVMT05HID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLlVMT05HID0gY29uc3RhbnQoNCk7XG5cbi8vIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbmVuY29kZS5MT05HID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMzIpe1xuICAgICAgICB2ID0gLSAoIDIgKiBMSU1JVDMyIC0gdik7XG4gICAgfVxuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuTE9ORyA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuRklYRUQgPSBlbmNvZGUuVUxPTkc7XG5zaXplT2YuRklYRUQgPSBzaXplT2YuVUxPTkc7XG5cbmVuY29kZS5GV09SRCA9IGVuY29kZS5TSE9SVDtcbnNpemVPZi5GV09SRCA9IHNpemVPZi5TSE9SVDtcblxuZW5jb2RlLlVGV09SRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuVUZXT1JEID0gc2l6ZU9mLlVTSE9SVDtcblxuXG4vLyBGSVhNRSBJbXBsZW1lbnQgTE9OR0RBVEVUSU1FXG5lbmNvZGUuTE9OR0RBVEVUSU1FID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG59O1xuXG5zaXplT2YuTE9OR0RBVEVUSU1FID0gY29uc3RhbnQoOCk7XG5cbi8vIENvbnZlcnQgYSA0LWNoYXIgdGFnIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuZW5jb2RlLlRBRyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IDQsICdUYWcgc2hvdWxkIGJlIGV4YWN0bHkgNCBBU0NJSSBjaGFyYWN0ZXJzLicpO1xuICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDMpXTtcbn07XG5cbnNpemVPZi5UQUcgPSBjb25zdGFudCg0KTtcblxuLy8gQ0ZGIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZW5jb2RlLkNhcmQ4ID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuQ2FyZDggPSBzaXplT2YuQllURTtcblxuZW5jb2RlLkNhcmQxNiA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuQ2FyZDE2ID0gc2l6ZU9mLlVTSE9SVDtcblxuZW5jb2RlLk9mZlNpemUgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PZmZTaXplID0gc2l6ZU9mLkJZVEU7XG5cbmVuY29kZS5TSUQgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLlNJRCA9IHNpemVPZi5VU0hPUlQ7XG5cbi8vIENvbnZlcnQgYSBudW1lcmljIG9wZXJhbmQgb3IgY2hhcnN0cmluZyBudW1iZXIgdG8gYSB2YXJpYWJsZS1zaXplIGxpc3Qgb2YgYnl0ZXMuXG5lbmNvZGUuTlVNQkVSID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAodiA+PSAtMTA3ICYmIHYgPD0gMTA3KSB7XG4gICAgICAgIHJldHVybiBbdiArIDEzOV07XG4gICAgfSBlbHNlIGlmICh2ID49IDEwOCAmJiB2IDw9IDExMzEgKSB7XG4gICAgICAgIHYgPSB2IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjQ3LCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0xMTMxICYmIHYgPD0gLTEwOCkge1xuICAgICAgICB2ID0gLXYgLSAxMDg7XG4gICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNTEsIHYgJiAweEZGXTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gLTMyNzY4ICYmIHYgPD0gMzI3NjcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIxNih2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5jb2RlLk5VTUJFUjMyKHYpO1xuICAgIH1cbn07XG5cbnNpemVPZi5OVU1CRVIgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBlbmNvZGUuTlVNQkVSKHYpLmxlbmd0aDtcbn07XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLTMyNzY4IGFuZCArMzI3NjcgdG8gYSB0aHJlZS1ieXRlIHZhbHVlLlxuLy8gVGhpcyBlbnN1cmVzIHdlIGFsd2F5cyB1c2UgdGhyZWUgYnl0ZXMsIGJ1dCBpcyBub3QgdGhlIG1vc3QgY29tcGFjdCBmb3JtYXQuXG5lbmNvZGUuTlVNQkVSMTYgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBbMjgsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLk5VTUJFUjE2ID0gY29uc3RhbnQoMik7XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZm91ci1ieXRlIHZhbHVlLlxuLy8gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB5b3UgYWx3YXlzIHVzZSBmb3VyIGJ5dGVzLFxuLy8gYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuZW5jb2RlLk5VTUJFUjMyID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gWzI5LCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5OVU1CRVIzMiA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8vIENvbnZlcnQgYSBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIFVURjE2IGJ5dGVzLlxuZW5jb2RlLlVURjE2ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBiLnB1c2goMCk7XG4gICAgICAgIGIucHVzaCh2LmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn07XG5cbnNpemVPZi5VVEYxNiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoICogMjtcbn07XG5cbi8vIENvbnZlcnQgYSBsaXN0IG9mIHZhbHVlcyB0byBhIENGRiBJTkRFWCBzdHJ1Y3R1cmUuXG4vLyBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cbmVuY29kZS5JTkRFWCA9IGZ1bmN0aW9uIChsKSB7XG4gICAgdmFyIG9mZlNpemUsIG9mZnNldCwgb2Zmc2V0cywgb2Zmc2V0RW5jb2RlciwgZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQsIGRhdGEsXG4gICAgICAgIGRhdGFTaXplLCBpLCB2O1xuICAgIC8vIEJlY2F1c2Ugd2UgaGF2ZSB0byBrbm93IHdoaWNoIGRhdGEgdHlwZSB0byB1c2UgdG8gZW5jb2RlIHRoZSBvZmZzZXRzLFxuICAgIC8vIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgdmFsdWVzIHR3aWNlOiBvbmNlIHRvIGVuY29kZSB0aGUgZGF0YSBhbmRcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG9mZmV0cywgdGhlbiBhZ2FpbiB0byBlbmNvZGUgdGhlIG9mZnNldHMgdXNpbmcgdGhlIGZpdHRpbmcgZGF0YSB0eXBlLlxuICAgIG9mZnNldCA9IDE7IC8vIEZpcnN0IG9mZnNldCBpcyBhbHdheXMgMS5cbiAgICBvZmZzZXRzID0gW29mZnNldF07XG4gICAgZGF0YSA9IFtdO1xuICAgIGRhdGFTaXplID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2ID0gZW5jb2RlLk9CSkVDVChsW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YSwgdik7XG4gICAgICAgIGRhdGFTaXplICs9IHYubGVuZ3RoO1xuICAgICAgICBvZmZzZXQgKz0gdi5sZW5ndGg7XG4gICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIGVuY29kZWRPZmZzZXRzID0gW107XG4gICAgb2ZmU2l6ZSA9ICgxICsgTWF0aC5mbG9vcihNYXRoLmxvZyhkYXRhU2l6ZSkvTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuICAgIG9mZnNldEVuY29kZXIgPSBbdW5kZWZpbmVkLCBlbmNvZGUuQllURSwgZW5jb2RlLlVTSE9SVCwgZW5jb2RlLlVJTlQyNCwgZW5jb2RlLlVMT05HXVtvZmZTaXplXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbmNvZGVkT2Zmc2V0ID0gb2Zmc2V0RW5jb2RlcihvZmZzZXRzW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdChlbmNvZGUuQ2FyZDE2KGwubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5PZmZTaXplKG9mZlNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZE9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbn07XG5cbnNpemVPZi5JTkRFWCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5JTkRFWCh2KS5sZW5ndGg7XG59O1xuXG4vLyBDb252ZXJ0IGFuIG9iamVjdCB0byBhIENGRiBESUNUIHN0cnVjdHVyZS5cbi8vIFRoZSBrZXlzIHNob3VsZCBiZSBudW1lcmljLlxuLy8gVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG5lbmNvZGUuRElDVCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgdmFyIGQgPSBbXSxcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG0pLFxuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gT2JqZWN0LmtleXMoKSByZXR1cm4gc3RyaW5nIGtleXMsIGJ1dCBvdXIga2V5cyBhcmUgYWx3YXlzIG51bWVyaWMuXG4gICAgICAgIHZhciBrID0gcGFyc2VJbnQoa2V5c1tpXSwgMCk7XG4gICAgICAgIHZhciB2ID0gbVtrXTtcbiAgICAgICAgLy8gVmFsdWUgY29tZXMgYmVmb3JlIHRoZSBrZXkuXG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2LnZhbHVlLCB2LnR5cGUpKTtcbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQVRPUihrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG5zaXplT2YuRElDVCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIGVuY29kZS5ESUNUKG0pLmxlbmd0aDtcbn07XG5cbmVuY29kZS5PUEVSQVRPUiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHYgPCAxMjAwKSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMiwgdiAtIDEyMDBdO1xuICAgIH1cbn07XG5cbmVuY29kZS5PUEVSQU5EID0gZnVuY3Rpb24gKHYsIHR5cGUpIHtcbiAgICB2YXIgZCwgaTtcbiAgICBkID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSB0eXBlLmxlbmd0aCwgJ05vdCBlbm91Z2ggYXJndW1lbnRzIGdpdmVuIGZvciB0eXBlJyArIHR5cGUpO1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHZbaV0sIHR5cGVbaV0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAvLyBXZSBtYWtlIGl0IGVhc3kgZm9yIG91cnNlbHZlcyBhbmQgYWx3YXlzIGVuY29kZSBvZmZzZXRzIGFzXG4gICAgICAgICAgICAvLyA0IGJ5dGVzLiBUaGlzIG1ha2VzIG9mZnNldCBjYWxjdWxhdGlvbiBmb3IgdGhlIHRvcCBkaWN0IGVhc2llci5cbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSMzIodikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRklYTUUgQWRkIHN1cHBvcnQgZm9yIGJvb2xlYW5zXG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59O1xuXG5lbmNvZGUuT1AgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PUCA9IHNpemVPZi5CWVRFO1xuXG4vLyBtZW1vaXplIGNoYXJzdHJpbmcgZW5jb2RpbmcgdXNpbmcgV2Vha01hcCBpZiBhdmFpbGFibGVcbnZhciB3bW0gPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xuLy8gQ29udmVydCBhIGxpc3Qgb2YgQ2hhclN0cmluZyBvcGVyYXRpb25zIHRvIGJ5dGVzLlxuZW5jb2RlLkNIQVJTVFJJTkcgPSBmdW5jdGlvbiAob3BzKSB7XG4gICAgaWYgKCB3bW0gJiYgd21tLmhhcyggb3BzICkgKSB7XG4gICAgICAgIHJldHVybiB3bW0uZ2V0KCBvcHMgKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IFtdLFxuICAgICAgICBsZW5ndGggPSBvcHMubGVuZ3RoLFxuICAgICAgICBvcCxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBvcCA9IG9wc1tpXTtcbiAgICAgICAgZCA9IGQuY29uY2F0KCBlbmNvZGVbb3AudHlwZV0ob3AudmFsdWUpICk7XG4gICAgfVxuXG4gICAgaWYgKCB3bW0gKSB7XG4gICAgICAgIHdtbS5zZXQoIG9wcywgZCApO1xuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuc2l6ZU9mLkNIQVJTVFJJTkcgPSBmdW5jdGlvbiAob3BzKSB7XG4gICAgcmV0dXJuIGVuY29kZS5DSEFSU1RSSU5HKG9wcykubGVuZ3RoO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gQ29udmVydCBhbiBvYmplY3QgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlIHRvIGJ5dGVzLlxuZW5jb2RlLk9CSkVDVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbdi50eXBlXTtcbiAgICBjaGVjay5hcmd1bWVudChlbmNvZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcbiAgICByZXR1cm4gZW5jb2RpbmdGdW5jdGlvbih2LnZhbHVlKTtcbn07XG5cbi8vIENvbnZlcnQgYSB0YWJsZSBvYmplY3QgdG8gYnl0ZXMuXG4vLyBBIHRhYmxlIGNvbnRhaW5zIGEgbGlzdCBvZiBmaWVsZHMgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgKG5hbWUsIHR5cGUgYW5kIGRlZmF1bHQgdmFsdWUpLlxuLy8gVGhlIHRhYmxlIGl0c2VsZiBoYXMgdGhlIGZpZWxkIHZhbHVlcyBzZXQgYXMgYXR0cmlidXRlcy5cbmVuY29kZS5UQUJMRSA9IGZ1bmN0aW9uICh0YWJsZSkge1xuICAgIHZhciBkID0gW10sXG4gICAgICAgIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGgsXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuICAgICAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVtmaWVsZC50eXBlXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gZW5jb2RpbmdGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIGQgPSBkLmNvbmNhdChieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBkO1xufTtcblxuLy8gTWVyZ2UgaW4gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkxJVEVSQUwgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2O1xufTtcblxuc2l6ZU9mLkxJVEVSQUwgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2Lmxlbmd0aDtcbn07XG5cblxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuc2l6ZU9mID0gc2l6ZU9mO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qIVxuICogUGFwZXIuanMgdjAuOS4yMSAtIFRoZSBTd2lzcyBBcm15IEtuaWZlIG9mIFZlY3RvciBHcmFwaGljcyBTY3JpcHRpbmcuXG4gKiBodHRwOi8vcGFwZXJqcy5vcmcvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExIC0gMjAxNCwgSnVlcmcgTGVobmkgJiBKb25hdGhhbiBQdWNrZXlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vICYgaHR0cDovL2pvbmF0aGFucHVja2V5LmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEYXRlOiBXZWQgRGVjIDMgMTQ6NDc6MDUgMjAxNCArMDEwMFxuICpcbiAqKipcbiAqXG4gKiBTdHJhcHMuanMgLSBDbGFzcyBpbmhlcml0YW5jZSBsaWJyYXJ5IHdpdGggc3VwcG9ydCBmb3IgYmVhbi1zdHlsZSBhY2Nlc3NvcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYgLSAyMDEzIEp1ZXJnIExlaG5pXG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKioqXG4gKlxuICogQWNvcm4uanNcbiAqIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYWNvcm4vXG4gKlxuICogQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdCxcbiAqIGNyZWF0ZWQgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4gKlxuICovXG5cbnZhciBwYXBlciA9IG5ldyBmdW5jdGlvbih1bmRlZmluZWQpIHtcblxuXHRcdCAgdmFyIG5vQ2FudmFzID1cblx0XHRcdCAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnIHx8XG5cdFx0XHQgICggdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgKTtcblxudmFyIEJhc2UgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBoaWRkZW4gPSAvXihzdGF0aWNzfGVudW1lcmFibGV8YmVhbnN8cHJlc2VydmUpJC8sXG5cblx0XHRmb3JFYWNoID0gW10uZm9yRWFjaCB8fCBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdGZvckluID0gZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB0aGlzKVxuXHRcdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24ocHJvdG8pIHtcblx0XHRcdHJldHVybiB7IF9fcHJvdG9fXzogcHJvdG8gfTtcblx0XHR9LFxuXG5cdFx0ZGVzY3JpYmUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHx8IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuXHRcdFx0dmFyIGdldCA9IG9iai5fX2xvb2t1cEdldHRlcl9fICYmIG9iai5fX2xvb2t1cEdldHRlcl9fKG5hbWUpO1xuXHRcdFx0cmV0dXJuIGdldFxuXHRcdFx0XHRcdD8geyBnZXQ6IGdldCwgc2V0OiBvYmouX19sb29rdXBTZXR0ZXJfXyhuYW1lKSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9XG5cdFx0XHRcdFx0OiBvYmouaGFzT3duUHJvcGVydHkobmFtZSlcblx0XHRcdFx0XHRcdD8geyB2YWx1ZTogb2JqW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH1cblx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXG5cdFx0X2RlZmluZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbihvYmosIG5hbWUsIGRlc2MpIHtcblx0XHRcdGlmICgoZGVzYy5nZXQgfHwgZGVzYy5zZXQpICYmIG9iai5fX2RlZmluZUdldHRlcl9fKSB7XG5cdFx0XHRcdGlmIChkZXNjLmdldClcblx0XHRcdFx0XHRvYmouX19kZWZpbmVHZXR0ZXJfXyhuYW1lLCBkZXNjLmdldCk7XG5cdFx0XHRcdGlmIChkZXNjLnNldClcblx0XHRcdFx0XHRvYmouX19kZWZpbmVTZXR0ZXJfXyhuYW1lLCBkZXNjLnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvYmpbbmFtZV0gPSBkZXNjLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0ZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBkZXNjKSB7XG5cdFx0XHRkZWxldGUgb2JqW25hbWVdO1xuXHRcdFx0cmV0dXJuIF9kZWZpbmUob2JqLCBuYW1lLCBkZXNjKTtcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIGluamVjdChkZXN0LCBzcmMsIGVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSkge1xuXHRcdHZhciBiZWFuc05hbWVzID0ge307XG5cblx0XHRmdW5jdGlvbiBmaWVsZChuYW1lLCB2YWwpIHtcblx0XHRcdHZhbCA9IHZhbCB8fCAodmFsID0gZGVzY3JpYmUoc3JjLCBuYW1lKSlcblx0XHRcdFx0XHQmJiAodmFsLmdldCA/IHZhbCA6IHZhbC52YWx1ZSk7XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnIycpXG5cdFx0XHRcdHZhbCA9IGRlc3RbdmFsLnN1YnN0cmluZygxKV0gfHwgdmFsO1xuXHRcdFx0dmFyIGlzRnVuYyA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG5cdFx0XHRcdHJlcyA9IHZhbCxcblx0XHRcdFx0cHJldiA9IHByZXNlcnZlIHx8IGlzRnVuY1xuXHRcdFx0XHRcdFx0PyAodmFsICYmIHZhbC5nZXQgPyBuYW1lIGluIGRlc3QgOiBkZXN0W25hbWVdKVxuXHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHRiZWFuO1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZSB8fCAhcHJldikge1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIHByZXYpXG5cdFx0XHRcdFx0dmFsLmJhc2UgPSBwcmV2O1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIGJlYW5zICE9PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgKGJlYW4gPSBuYW1lLm1hdGNoKC9eKFtnc11ldHxpcykoKFtBLVpdKSguKikpJC8pKSlcblx0XHRcdFx0XHRiZWFuc05hbWVzW2JlYW5bM10udG9Mb3dlckNhc2UoKSArIGJlYW5bNF1dID0gYmVhblsyXTtcblx0XHRcdFx0aWYgKCFyZXMgfHwgaXNGdW5jIHx8ICFyZXMuZ2V0IHx8IHR5cGVvZiByZXMuZ2V0ICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHR8fCAhQmFzZS5pc1BsYWluT2JqZWN0KHJlcykpXG5cdFx0XHRcdFx0cmVzID0geyB2YWx1ZTogcmVzLCB3cml0YWJsZTogdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoKGRlc2NyaWJlKGRlc3QsIG5hbWUpXG5cdFx0XHRcdFx0XHR8fCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KS5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHRyZXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXMuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmaW5lKGRlc3QsIG5hbWUsIHJlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzcmMpIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG5cdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIWhpZGRlbi50ZXN0KG5hbWUpKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBiZWFuc05hbWVzKSB7XG5cdFx0XHRcdHZhciBwYXJ0ID0gYmVhbnNOYW1lc1tuYW1lXSxcblx0XHRcdFx0XHRzZXQgPSBkZXN0WydzZXQnICsgcGFydF0sXG5cdFx0XHRcdFx0Z2V0ID0gZGVzdFsnZ2V0JyArIHBhcnRdIHx8IHNldCAmJiBkZXN0WydpcycgKyBwYXJ0XTtcblx0XHRcdFx0aWYgKGdldCAmJiAoYmVhbnMgPT09IHRydWUgfHwgZ2V0Lmxlbmd0aCA9PT0gMCkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXN0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIGJpbmQpIHtcblx0XHRpZiAob2JqKVxuXHRcdFx0KCdsZW5ndGgnIGluIG9iaiAmJiAhb2JqLmdldExlbmd0aFxuXHRcdFx0XHRcdCYmIHR5cGVvZiBvYmoubGVuZ3RoID09PSAnbnVtYmVyJ1xuXHRcdFx0XHQ/IGZvckVhY2hcblx0XHRcdFx0OiBmb3JJbikuY2FsbChvYmosIGl0ZXIsIGJpbmQgPSBiaW5kIHx8IG9iaik7XG5cdFx0cmV0dXJuIGJpbmQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQob2JqLCBwcm9wcywgZXhjbHVkZSkge1xuXHRcdGZvciAodmFyIGtleSBpbiBwcm9wcylcblx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICghZXhjbHVkZSB8fCAhZXhjbHVkZVtrZXldKSlcblx0XHRcdFx0b2JqW2tleV0gPSBwcm9wc1trZXldO1xuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXHRyZXR1cm4gaW5qZWN0KGZ1bmN0aW9uIEJhc2UoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2V0KHRoaXMsIGFyZ3VtZW50c1tpXSk7XG5cdH0sIHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uKHNyYykge1xuXHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHR2YXIgc3RhdGljcyA9IHNyYy5zdGF0aWNzID09PSB0cnVlID8gc3JjIDogc3JjLnN0YXRpY3MsXG5cdFx0XHRcdFx0YmVhbnMgPSBzcmMuYmVhbnMsXG5cdFx0XHRcdFx0cHJlc2VydmUgPSBzcmMucHJlc2VydmU7XG5cdFx0XHRcdGlmIChzdGF0aWNzICE9PSBzcmMpXG5cdFx0XHRcdFx0aW5qZWN0KHRoaXMucHJvdG90eXBlLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0XHRpbmplY3QodGhpcywgc3RhdGljcywgdHJ1ZSwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5pbmplY3QoYXJndW1lbnRzW2ldKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGJhc2UgPSB0aGlzLFxuXHRcdFx0XHRjdG9yO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY3RvciA9IGFyZ3VtZW50c1tpXS5pbml0aWFsaXplKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y3RvciA9IGN0b3IgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHRjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRjdG9yLmJhc2UgPSBiYXNlO1xuXHRcdFx0ZGVmaW5lKGN0b3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLFxuXHRcdFx0XHRcdHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cdFx0XHRpbmplY3QoY3RvciwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuaW5qZWN0LmFwcGx5KGN0b3IsIGFyZ3VtZW50cykgOiBjdG9yO1xuXHRcdH1cblx0fSwgdHJ1ZSkuaW5qZWN0KHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGlmIChzcmMpXG5cdFx0XHRcdFx0aW5qZWN0KHRoaXMsIHNyYywgc3JjLmVudW1lcmFibGUsIHNyYy5iZWFucywgc3JjLnByZXNlcnZlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlcyA9IGNyZWF0ZSh0aGlzKTtcblx0XHRcdHJldHVybiByZXMuaW5qZWN0LmFwcGx5KHJlcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0ZWFjaDogZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0cmV0dXJuIGVhY2godGhpcywgaXRlciwgYmluZCk7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRcdHJldHVybiBzZXQodGhpcywgcHJvcHMpO1xuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdGVhY2g6IGVhY2gsXG5cdFx0XHRjcmVhdGU6IGNyZWF0ZSxcblx0XHRcdGRlZmluZTogZGVmaW5lLFxuXHRcdFx0ZGVzY3JpYmU6IGRlc2NyaWJlLFxuXHRcdFx0c2V0OiBzZXQsXG5cblx0XHRcdGNsb25lOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0cmV0dXJuIHNldChuZXcgb2JqLmNvbnN0cnVjdG9yKCksIG9iaik7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0dmFyIGN0b3IgPSBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3I7XG5cdFx0XHRcdHJldHVybiBjdG9yICYmIChjdG9yID09PSBPYmplY3QgfHwgY3RvciA9PT0gQmFzZVxuXHRcdFx0XHRcdFx0fHwgY3Rvci5uYW1lID09PSAnT2JqZWN0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRwaWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGlmIChhcmd1bWVudHNbaV0gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHJldHVybiBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJylcblx0bW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG5pZiAoIUFycmF5LmlzQXJyYXkpIHtcblx0QXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0fTtcbn1cblxuaWYgKCFub0NhbnZhcyAmJiAhZG9jdW1lbnQuaGVhZCkge1xuXHRkb2N1bWVudC5oZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbn1cblxuQmFzZS5pbmplY3Qoe1xuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkICE9IG51bGxcblx0XHRcdD8gICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZVxuXHRcdFx0XHQ/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIlxuXHRcdFx0XHQ6ICcgQCcgKyB0aGlzLl9pZClcblx0XHRcdDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICghL15fLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHQ/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0Z2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xhc3MgfHwgJyc7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24ocHJvcHMsIGV4Y2x1ZGUsIGRvbnRDaGVjaykge1xuXHRcdGlmIChwcm9wcyAmJiAoZG9udENoZWNrIHx8IEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcykpKSB7XG5cdFx0XHR2YXIgb3JpZyA9IHByb3BzLl9maWx0ZXJpbmcgfHwgcHJvcHM7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb3JpZykge1xuXHRcdFx0XHRpZiAob3JpZy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoZXhjbHVkZSAmJiBleGNsdWRlW2tleV0pKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXG5cdFx0ZXhwb3J0czoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuXHRcdFx0XHRuYW1lID0gcmVzLnByb3RvdHlwZS5fY2xhc3M7XG5cdFx0XHRpZiAobmFtZSAmJiAhQmFzZS5leHBvcnRzW25hbWVdKVxuXHRcdFx0XHRCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcblx0XHRcdGZ1bmN0aW9uIGNoZWNrS2V5cyhvMSwgbzIpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvMSlcblx0XHRcdFx0XHRpZiAobzEuaGFzT3duUHJvcGVydHkoaSkgJiYgIW8yLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChvYmoxID09PSBvYmoyKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGlmIChvYmoxICYmIG9iajEuZXF1YWxzKVxuXHRcdFx0XHRyZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG5cdFx0XHRpZiAob2JqMiAmJiBvYmoyLmVxdWFscylcblx0XHRcdFx0cmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuXHRcdFx0XHRpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBvYmoxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmICghQmFzZS5lcXVhbHMob2JqMVtpXSwgb2JqMltpXSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAob2JqMSAmJiB0eXBlb2Ygb2JqMSA9PT0gJ29iamVjdCdcblx0XHRcdFx0XHQmJiBvYmoyICYmIHR5cGVvZiBvYmoyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRpZiAoIWNoZWNrS2V5cyhvYmoxLCBvYmoyKSB8fCAhY2hlY2tLZXlzKG9iajIsIG9iajEpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvYmoxKSB7XG5cdFx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSlcblx0XHRcdFx0XHRcdFx0JiYgIUJhc2UuZXF1YWxzKG9iajFbaV0sIG9iajJbaV0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRyZWFkOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKSB7XG5cdFx0XHRpZiAodGhpcyA9PT0gQmFzZSkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnBlZWsobGlzdCwgc3RhcnQpO1xuXHRcdFx0XHRsaXN0Ll9faW5kZXgrKztcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGUsXG5cdFx0XHRcdHJlYWRJbmRleCA9IHByb3RvLl9yZWFkSW5kZXgsXG5cdFx0XHRcdGluZGV4ID0gc3RhcnQgfHwgcmVhZEluZGV4ICYmIGxpc3QuX19pbmRleCB8fCAwO1xuXHRcdFx0aWYgKCFsZW5ndGgpXG5cdFx0XHRcdGxlbmd0aCA9IGxpc3QubGVuZ3RoIC0gaW5kZXg7XG5cdFx0XHR2YXIgb2JqID0gbGlzdFtpbmRleF07XG5cdFx0XHRpZiAob2JqIGluc3RhbmNlb2YgdGhpc1xuXHRcdFx0XHR8fCBvcHRpb25zICYmIG9wdGlvbnMucmVhZE51bGwgJiYgb2JqID09IG51bGwgJiYgbGVuZ3RoIDw9IDEpIHtcblx0XHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0XHRsaXN0Ll9faW5kZXggPSBpbmRleCArIDE7XG5cdFx0XHRcdHJldHVybiBvYmogJiYgb3B0aW9ucyAmJiBvcHRpb25zLmNsb25lID8gb2JqLmNsb25lKCkgOiBvYmo7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSBCYXNlLmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRpZiAocmVhZEluZGV4KVxuXHRcdFx0XHRvYmouX19yZWFkID0gdHJ1ZTtcblx0XHRcdG9iaiA9IG9iai5pbml0aWFsaXplLmFwcGx5KG9iaiwgaW5kZXggPiAwIHx8IGxlbmd0aCA8IGxpc3QubGVuZ3RoXG5cdFx0XHRcdD8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaW5kZXgsIGluZGV4ICsgbGVuZ3RoKVxuXHRcdFx0XHQ6IGxpc3QpIHx8IG9iajtcblx0XHRcdGlmIChyZWFkSW5kZXgpIHtcblx0XHRcdFx0bGlzdC5fX2luZGV4ID0gaW5kZXggKyBvYmouX19yZWFkO1xuXHRcdFx0XHRvYmouX19yZWFkID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0cGVlazogZnVuY3Rpb24obGlzdCwgc3RhcnQpIHtcblx0XHRcdHJldHVybiBsaXN0W2xpc3QuX19pbmRleCA9IHN0YXJ0IHx8IGxpc3QuX19pbmRleCB8fCAwXTtcblx0XHR9LFxuXG5cdFx0cmVtYWluOiBmdW5jdGlvbihsaXN0KSB7XG5cdFx0XHRyZXR1cm4gbGlzdC5sZW5ndGggLSAobGlzdC5fX2luZGV4IHx8IDApO1xuXHRcdH0sXG5cblx0XHRyZWFkQWxsOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHJlcyA9IFtdLFxuXHRcdFx0XHRlbnRyeTtcblx0XHRcdGZvciAodmFyIGkgPSBzdGFydCB8fCAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cmVzLnB1c2goQXJyYXkuaXNBcnJheShlbnRyeSA9IGxpc3RbaV0pXG5cdFx0XHRcdFx0XHQ/IHRoaXMucmVhZChlbnRyeSwgMCwgb3B0aW9ucylcblx0XHRcdFx0XHRcdDogdGhpcy5yZWFkKGxpc3QsIGksIG9wdGlvbnMsIDEpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdHJlYWROYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKSxcblx0XHRcdFx0aGFzT2JqZWN0ID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcblx0XHRcdGlmIChoYXNPYmplY3QpIHtcblx0XHRcdFx0dmFyIGZpbHRlcmVkID0gbGlzdC5fZmlsdGVyZWQ7XG5cdFx0XHRcdGlmICghZmlsdGVyZWQpIHtcblx0XHRcdFx0XHRmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkID0gQmFzZS5jcmVhdGUobGlzdFswXSk7XG5cdFx0XHRcdFx0ZmlsdGVyZWQuX2ZpbHRlcmluZyA9IGxpc3RbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlsdGVyZWRbbmFtZV0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkKGhhc09iamVjdCA/IFt2YWx1ZV0gOiBsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKTtcblx0XHR9LFxuXG5cdFx0Z2V0TmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRcdHZhciBhcmcgPSBsaXN0WzBdO1xuXHRcdFx0aWYgKGxpc3QuX2hhc09iamVjdCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRsaXN0Ll9oYXNPYmplY3QgPSBsaXN0Lmxlbmd0aCA9PT0gMSAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKTtcblx0XHRcdGlmIChsaXN0Ll9oYXNPYmplY3QpXG5cdFx0XHRcdHJldHVybiBuYW1lID8gYXJnW25hbWVdIDogbGlzdC5fZmlsdGVyZWQgfHwgYXJnO1xuXHRcdH0sXG5cblx0XHRoYXNOYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuICEhdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKTtcblx0XHR9LFxuXG5cdFx0aXNQbGFpblZhbHVlOiBmdW5jdGlvbihvYmosIGFzU3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopXG5cdFx0XHRcdFx0fHwgYXNTdHJpbmcgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG5cdFx0fSxcblxuXHRcdHNlcmlhbGl6ZTogZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0dmFyIHJvb3QgPSAhZGljdGlvbmFyeSxcblx0XHRcdFx0cmVzO1xuXHRcdFx0aWYgKHJvb3QpIHtcblx0XHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdFx0ZGljdGlvbmFyeSA9IHtcblx0XHRcdFx0XHRsZW5ndGg6IDAsXG5cdFx0XHRcdFx0ZGVmaW5pdGlvbnM6IHt9LFxuXHRcdFx0XHRcdHJlZmVyZW5jZXM6IHt9LFxuXHRcdFx0XHRcdGFkZDogZnVuY3Rpb24oaXRlbSwgY3JlYXRlKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSAnIycgKyBpdGVtLl9pZCxcblx0XHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXTtcblx0XHRcdFx0XHRcdGlmICghcmVmKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoKys7XG5cdFx0XHRcdFx0XHRcdHZhciByZXMgPSBjcmVhdGUuY2FsbChpdGVtKSxcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gaXRlbS5fY2xhc3M7XG5cdFx0XHRcdFx0XHRcdGlmIChuYW1lICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5kZWZpbml0aW9uc1tpZF0gPSByZXM7XG5cdFx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF0gPSBbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAob2JqICYmIG9iai5fc2VyaWFsaXplKSB7XG5cdFx0XHRcdHJlcyA9IG9iai5fc2VyaWFsaXplKG9wdGlvbnMsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR2YXIgbmFtZSA9IG9iai5fY2xhc3M7XG5cdFx0XHRcdGlmIChuYW1lICYmICFjb21wYWN0ICYmICFyZXMuX2NvbXBhY3QgJiYgcmVzWzBdICE9PSBuYW1lKVxuXHRcdFx0XHRcdHJlcy51bnNoaWZ0KG5hbWUpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsXG5cdFx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0XHRpZiAoY29tcGFjdClcblx0XHRcdFx0XHRyZXMuX2NvbXBhY3QgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSkge1xuXHRcdFx0XHRyZXMgPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvYmopXG5cdFx0XHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0XHRcdHJlc1tpXSA9IEJhc2Uuc2VyaWFsaXplKG9ialtpXSwgb3B0aW9ucywgY29tcGFjdCxcblx0XHRcdFx0XHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cmVzID0gb3B0aW9ucy5mb3JtYXR0ZXIubnVtYmVyKG9iaiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzID0gb2JqO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJvb3QgJiYgZGljdGlvbmFyeS5sZW5ndGggPiAwXG5cdFx0XHRcdFx0PyBbWydkaWN0aW9uYXJ5JywgZGljdGlvbmFyeS5kZWZpbml0aW9uc10sIHJlc11cblx0XHRcdFx0XHQ6IHJlcztcblx0XHR9LFxuXG5cdFx0ZGVzZXJpYWxpemU6IGZ1bmN0aW9uKGpzb24sIGNyZWF0ZSwgX2RhdGEpIHtcblx0XHRcdHZhciByZXMgPSBqc29uO1xuXHRcdFx0X2RhdGEgPSBfZGF0YSB8fCB7fTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG5cdFx0XHRcdHZhciB0eXBlID0ganNvblswXSxcblx0XHRcdFx0XHRpc0RpY3Rpb25hcnkgPSB0eXBlID09PSAnZGljdGlvbmFyeSc7XG5cdFx0XHRcdGlmICghaXNEaWN0aW9uYXJ5KSB7XG5cdFx0XHRcdFx0aWYgKF9kYXRhLmRpY3Rpb25hcnkgJiYganNvbi5sZW5ndGggPT0gMSAmJiAvXiMvLnRlc3QodHlwZSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcblx0XHRcdFx0XHR0eXBlID0gQmFzZS5leHBvcnRzW3R5cGVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gdHlwZSA/IDEgOiAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVzLnB1c2goQmFzZS5kZXNlcmlhbGl6ZShqc29uW2ldLCBjcmVhdGUsIF9kYXRhKSk7XG5cdFx0XHRcdGlmIChpc0RpY3Rpb25hcnkpIHtcblx0XHRcdFx0XHRfZGF0YS5kaWN0aW9uYXJ5ID0gcmVzWzBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUpIHtcblx0XHRcdFx0XHR2YXIgYXJncyA9IHJlcztcblx0XHRcdFx0XHRpZiAoY3JlYXRlKSB7XG5cdFx0XHRcdFx0XHRyZXMgPSBjcmVhdGUodHlwZSwgYXJncyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlcyA9IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKTtcblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkocmVzLCBhcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGpzb24pKSB7XG5cdFx0XHRcdHJlcyA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4ganNvbilcblx0XHRcdFx0XHRyZXNba2V5XSA9IEJhc2UuZGVzZXJpYWxpemUoanNvbltrZXldLCBjcmVhdGUsIF9kYXRhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGpzb24gPSBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA9PT0gZmFsc2Vcblx0XHRcdFx0XHQ/IGpzb25cblx0XHRcdFx0XHQ6IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXHRcdH0sXG5cblx0XHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiBCYXNlLmRlc2VyaWFsaXplKFxuXHRcdFx0XHRcdHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHR5cGUsIGFyZ3MpIHtcblx0XHRcdFx0XHRcdHZhciBvYmogPSB0YXJnZXQgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB0eXBlXG5cdFx0XHRcdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHQ6IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKSxcblx0XHRcdFx0XHRcdFx0aXNUYXJnZXQgPSBvYmogPT09IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtXG5cdFx0XHRcdFx0XHRcdFx0JiYgKGlzVGFyZ2V0IHx8ICEob2JqIGluc3RhbmNlb2YgTGF5ZXIpKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKVxuXHRcdFx0XHRcdFx0XHRcdGFyZy5pbnNlcnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRcdFx0XHRcdGlmIChpc1RhcmdldClcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNwbGljZTogZnVuY3Rpb24obGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcblx0XHRcdHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG5cdFx0XHRcdGFwcGVuZCA9IGluZGV4ID09PSB1bmRlZmluZWQ7XG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IGxpc3QubGVuZ3RoIDogaW5kZXg7XG5cdFx0XHRpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aClcblx0XHRcdFx0aW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG5cdFx0XHRcdGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG5cdFx0XHRcdGlmIChpdGVtcylcblx0XHRcdFx0XHRhcmdzLnB1c2guYXBwbHkoYXJncywgaXRlbXMpO1xuXHRcdFx0XHR2YXIgcmVtb3ZlZCA9IGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlbW92ZWRbaV0uX2luZGV4ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRsaXN0W2ldLl9pbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y2FtZWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKGFsbCwgY2hyKSB7XG5cdFx0XHRcdHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRoeXBoZW5hdGU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBFbWl0dGVyID0ge1xuXHRvbjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub24oa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZXZlbnRUeXBlc1t0eXBlXTtcblx0XHRcdGlmIChlbnRyeSkge1xuXHRcdFx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdFx0XHRcdGhhbmRsZXJzID0gaGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyc1t0eXBlXSB8fCBbXTtcblx0XHRcdFx0aWYgKGhhbmRsZXJzLmluZGV4T2YoZnVuYykgPT09IC0xKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jKTtcblx0XHRcdFx0XHRpZiAoZW50cnkuaW5zdGFsbCAmJiBoYW5kbGVycy5sZW5ndGggPT0gMSlcblx0XHRcdFx0XHRcdGVudHJ5Lmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvZmY6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9mZihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdLFxuXHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdLFxuXHRcdFx0aW5kZXg7XG5cdFx0aWYgKGVudHJ5ICYmIGhhbmRsZXJzKSB7XG5cdFx0XHRpZiAoIWZ1bmMgfHwgKGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihmdW5jKSkgIT09IC0xXG5cdFx0XHRcdFx0JiYgaGFuZGxlcnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGlmIChlbnRyeS51bmluc3RhbGwpXG5cdFx0XHRcdFx0ZW50cnkudW5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0XHR9IGVsc2UgaWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvbmNlOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0cmV0dXJuIHRoaXMub24odHlwZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm9mZih0eXBlLCBmdW5jKTtcblx0XHR9KTtcblx0fSxcblxuXHRlbWl0OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0aWYgKCFoYW5kbGVycylcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGhhbmRsZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpID09PSBmYWxzZVxuXHRcdFx0XHRcdCYmIGV2ZW50ICYmIGV2ZW50LnN0b3ApIHtcblx0XHRcdFx0ZXZlbnQuc3RvcCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0cmVzcG9uZHM6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRyZXR1cm4gISEodGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSk7XG5cdH0sXG5cblx0YXR0YWNoOiAnI29uJyxcblx0ZGV0YWNoOiAnI29mZicsXG5cdGZpcmU6ICcjZW1pdCcsXG5cblx0X2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uKGluc3RhbGwpIHtcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MsXG5cdFx0XHRrZXkgPSBpbnN0YWxsID8gJ2luc3RhbGwnIDogJ3VuaW5zdGFsbCc7XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiBoYW5kbGVycykge1xuXHRcdFx0aWYgKGhhbmRsZXJzW3R5cGVdLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZXZlbnRUeXBlc1t0eXBlXSxcblx0XHRcdFx0XHRmdW5jID0gZW50cnlba2V5XTtcblx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbiBpbmplY3Qoc3JjKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gc3JjLl9ldmVudHM7XG5cdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdHZhciB0eXBlcyA9IHt9O1xuXHRcdFx0XHRCYXNlLmVhY2goZXZlbnRzLCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdFx0XHRcdFx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyxcblx0XHRcdFx0XHRcdG5hbWUgPSBpc1N0cmluZyA/IGVudHJ5IDoga2V5LFxuXHRcdFx0XHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0XHRcdHR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHR5cGVzW3R5cGVdID0gaXNTdHJpbmcgPyB7fSA6IGVudHJ5O1xuXHRcdFx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdFx0XHRcdHNyY1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHNyY1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24oZnVuYykge1xuXHRcdFx0XHRcdFx0dmFyIHByZXYgPSB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKHByZXYpXG5cdFx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIHByZXYpO1xuXHRcdFx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0XHRcdHRoaXMub24odHlwZSwgZnVuYyk7XG5cdFx0XHRcdFx0XHR0aGlzW25hbWVdID0gZnVuYztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c3JjLl9ldmVudFR5cGVzID0gdHlwZXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5qZWN0LmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBQYXBlclNjb3BlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXBlclNjb3BlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXBlclNjb3BlKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnNldHRpbmdzID0gbmV3IEJhc2Uoe1xuXHRcdFx0YXBwbHlNYXRyaXg6IHRydWUsXG5cdFx0XHRoYW5kbGVTaXplOiA0LFxuXHRcdFx0aGl0VG9sZXJhbmNlOiAwXG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLnByb2plY3RzID0gW107XG5cdFx0dGhpcy50b29scyA9IFtdO1xuXHRcdHRoaXMucGFsZXR0ZXMgPSBbXTtcblx0XHR0aGlzLl9pZCA9IFBhcGVyU2NvcGUuX2lkKys7XG5cdFx0UGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG5cdFx0aWYgKCBub0NhbnZhcyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLnN1cHBvcnQpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0cHJvdG8uc3VwcG9ydCA9IHtcblx0XHRcdFx0bmF0aXZlRGFzaDogJ3NldExpbmVEYXNoJyBpbiBjdHggfHwgJ21vekRhc2gnIGluIGN0eCxcblx0XHRcdFx0bmF0aXZlQmxlbmRNb2RlczogQmxlbmRNb2RlLm5hdGl2ZU1vZGVzXG5cdFx0XHR9O1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5icm93c2VyKSB7XG5cdFx0XHR2YXIgYnJvd3NlciA9IHByb3RvLmJyb3dzZXIgPSB7fTtcblx0XHRcdG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFxuXHRcdFx0XHQvKG9wZXJhfGNocm9tZXxzYWZhcml8d2Via2l0fGZpcmVmb3h8bXNpZXx0cmlkZW50KVxcLz9cXHMqKFsuXFxkXSspKD86Lip2ZXJzaW9uXFwvKFsuXFxkXSspKT8oPzouKnJ2XFw6KFsuXFxkXSspKT8vZyxcblx0XHRcdFx0ZnVuY3Rpb24oYWxsLCBuLCB2MSwgdjIsIHJ2KSB7XG5cdFx0XHRcdFx0aWYgKCFicm93c2VyLmNocm9tZSkge1xuXHRcdFx0XHRcdFx0dmFyIHYgPSBuID09PSAnb3BlcmEnID8gdjIgOiB2MTtcblx0XHRcdFx0XHRcdGlmIChuID09PSAndHJpZGVudCcpIHtcblx0XHRcdFx0XHRcdFx0diA9IHJ2O1xuXHRcdFx0XHRcdFx0XHRuID0gJ21zaWUnO1xuXHRcdFx0XHRcdFx0fcKgXG5cdFx0XHRcdFx0XHRicm93c2VyLnZlcnNpb24gPSB2O1xuXHRcdFx0XHRcdFx0YnJvd3Nlci52ZXJzaW9uTnVtYmVyID0gcGFyc2VGbG9hdCh2KTtcblx0XHRcdFx0XHRcdGJyb3dzZXIubmFtZSA9IG47XG5cdFx0XHRcdFx0XHRicm93c2VyW25dID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0XHRpZiAoYnJvd3Nlci5jaHJvbWUpXG5cdFx0XHRcdGRlbGV0ZSBicm93c2VyLndlYmtpdDtcblx0XHR9XG5cdH0sXG5cblx0dmVyc2lvbjogJzAuOS4yMScsXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdCAmJiB0aGlzLnByb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdGdldFBhcGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRleGVjdXRlOiBmdW5jdGlvbihjb2RlLCB1cmwsIG9wdGlvbnMpIHtcblx0XHRwYXBlci5QYXBlclNjcmlwdC5leGVjdXRlKGNvZGUsIHRoaXMsIHVybCwgb3B0aW9ucyk7XG5cdFx0Vmlldy51cGRhdGVGb2N1cygpO1xuXHR9LFxuXG5cdGluc3RhbGw6IGZ1bmN0aW9uKHNjb3BlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdEJhc2UuZWFjaChbJ3Byb2plY3QnLCAndmlldycsICd0b29sJ10sIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0QmFzZS5kZWZpbmUoc2NvcGUsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoYXRba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMpXG5cdFx0XHRpZiAoIS9eXy8udGVzdChrZXkpICYmIHRoaXNba2V5XSlcblx0XHRcdFx0c2NvcGVba2V5XSA9IHRoaXNba2V5XTtcblx0fSxcblxuXHRzZXR1cDogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnByb2plY3QgPSBuZXcgUHJvamVjdChlbGVtZW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5wcm9qZWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMucHJvamVjdHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMudG9vbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnRvb2xzW2ldLnJlbW92ZSgpO1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnBhbGV0dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5wYWxldHRlc1tpXS5yZW1vdmUoKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0XHRkZWxldGUgUGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXTtcblx0fSxcblxuXHRzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlKG5hbWUpIHtcblx0XHRcdG5hbWUgKz0gJ0F0dHJpYnV0ZSc7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWwsIGF0dHIpIHtcblx0XHRcdFx0cmV0dXJuIGVsW25hbWVdKGF0dHIpIHx8IGVsW25hbWVdKCdkYXRhLXBhcGVyLScgKyBhdHRyKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdF9zY29wZXM6IHt9LFxuXHRcdFx0X2lkOiAwLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zY29wZXNbaWRdIHx8IG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnZ2V0JyksXG5cdFx0XHRoYXNBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnaGFzJylcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIFBhcGVyU2NvcGVJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGFjdGl2YXRlKSB7XG5cdFx0dGhpcy5fc2NvcGUgPSBwYXBlcjtcblx0XHR0aGlzLl9pbmRleCA9IHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLnB1c2godGhpcykgLSAxO1xuXHRcdGlmIChhY3RpdmF0ZSB8fCAhdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSlcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9zY29wZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgcHJldiA9IHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV07XG5cdFx0aWYgKHByZXYgJiYgcHJldiAhPT0gdGhpcylcblx0XHRcdHByZXYuZW1pdCgnZGVhY3RpdmF0ZScpO1xuXHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSB0aGlzO1xuXHRcdHRoaXMuZW1pdCgnYWN0aXZhdGUnLCBwcmV2KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0FjdGl2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT09IHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5faW5kZXggPT0gbnVsbClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRCYXNlLnNwbGljZSh0aGlzLl9zY29wZVt0aGlzLl9saXN0XSwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdGlmICh0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09IHRoaXMpXG5cdFx0XHR0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gbnVsbDtcblx0XHR0aGlzLl9zY29wZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG52YXIgRm9ybWF0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblx0XHR0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCA1O1xuXHRcdHRoaXMubXVsdGlwbGllciA9IE1hdGgucG93KDEwLCB0aGlzLnByZWNpc2lvbik7XG5cdH0sXG5cblx0bnVtYmVyOiBmdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiB0aGlzLm11bHRpcGxpZXIpIC8gdGhpcy5tdWx0aXBsaWVyO1xuXHR9LFxuXG5cdHBhaXI6IGZ1bmN0aW9uKHZhbDEsIHZhbDIsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwxKSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbDIpO1xuXHR9LFxuXG5cdHBvaW50OiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwueCkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwueSk7XG5cdH0sXG5cblx0c2l6ZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsLndpZHRoKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMubnVtYmVyKHZhbC5oZWlnaHQpO1xuXHR9LFxuXG5cdHJlY3RhbmdsZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludCh2YWwsIHNlcGFyYXRvcikgKyAoc2VwYXJhdG9yIHx8ICcsJylcblx0XHRcdFx0KyB0aGlzLnNpemUodmFsLCBzZXBhcmF0b3IpO1xuXHR9XG59KTtcblxuRm9ybWF0dGVyLmluc3RhbmNlID0gbmV3IEZvcm1hdHRlcigpO1xuXG52YXIgTnVtZXJpY2FsID0gbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBhYnNjaXNzYXMgPSBbXG5cdFx0WyAgMC41NzczNTAyNjkxODk2MjU3NjQ1MDkxNDg4XSxcblx0XHRbMCwwLjc3NDU5NjY2OTI0MTQ4MzM3NzAzNTg1MzFdLFxuXHRcdFsgIDAuMzM5OTgxMDQzNTg0ODU2MjY0ODAyNjY1OCwwLjg2MTEzNjMxMTU5NDA1MjU3NTIyMzk0NjVdLFxuXHRcdFswLDAuNTM4NDY5MzEwMTA1NjgzMDkxMDM2MzE0NCwwLjkwNjE3OTg0NTkzODY2Mzk5Mjc5NzYyNjldLFxuXHRcdFsgIDAuMjM4NjE5MTg2MDgzMTk2OTA4NjMwNTAxNywwLjY2MTIwOTM4NjQ2NjI2NDUxMzY2MTM5OTYsMC45MzI0Njk1MTQyMDMxNTIwMjc4MTIzMDE2XSxcblx0XHRbMCwwLjQwNTg0NTE1MTM3NzM5NzE2NjkwNjYwNjQsMC43NDE1MzExODU1OTkzOTQ0Mzk4NjM4NjQ4LDAuOTQ5MTA3OTEyMzQyNzU4NTI0NTI2MTg5N10sXG5cdFx0WyAgMC4xODM0MzQ2NDI0OTU2NDk4MDQ5Mzk0NzYxLDAuNTI1NTMyNDA5OTE2MzI4OTg1ODE3NzM5MCwwLjc5NjY2NjQ3NzQxMzYyNjczOTU5MTU1MzksMC45NjAyODk4NTY0OTc1MzYyMzE2ODM1NjA5XSxcblx0XHRbMCwwLjMyNDI1MzQyMzQwMzgwODkyOTAzODUzODAsMC42MTMzNzE0MzI3MDA1OTAzOTczMDg3MDIwLDAuODM2MDMxMTA3MzI2NjM1Nzk0Mjk5NDI5OCwwLjk2ODE2MDIzOTUwNzYyNjA4OTgzNTU3NjJdLFxuXHRcdFsgIDAuMTQ4ODc0MzM4OTgxNjMxMjEwODg0ODI2MCwwLjQzMzM5NTM5NDEyOTI0NzE5MDc5OTI2NTksMC42Nzk0MDk1NjgyOTkwMjQ0MDYyMzQzMjc0LDAuODY1MDYzMzY2Njg4OTg0NTEwNzMyMDk2NywwLjk3MzkwNjUyODUxNzE3MTcyMDA3Nzk2NDBdLFxuXHRcdFswLDAuMjY5NTQzMTU1OTUyMzQ0OTcyMzMxNTMyMCwwLjUxOTA5NjEyOTIwNjgxMTgxNTkyNTcyNTcsMC43MzAxNTIwMDU1NzQwNDkzMjQwOTM0MTYzLDAuODg3MDYyNTk5NzY4MDk1Mjk5MDc1MTU3OCwwLjk3ODIyODY1ODE0NjA1Njk5MjgwMzkzODBdLFxuXHRcdFsgIDAuMTI1MjMzNDA4NTExNDY4OTE1NDcyNDQxNCwwLjM2NzgzMTQ5ODk5ODE4MDE5Mzc1MjY5MTUsMC41ODczMTc5NTQyODY2MTc0NDcyOTY3MDI0LDAuNzY5OTAyNjc0MTk0MzA0Njg3MDM2ODkzOCwwLjkwNDExNzI1NjM3MDQ3NDg1NjY3ODQ2NTksMC45ODE1NjA2MzQyNDY3MTkyNTA2OTA1NDkxXSxcblx0XHRbMCwwLjIzMDQ1ODMxNTk1NTEzNDc5NDA2NTUyODEsMC40NDg0OTI3NTEwMzY0NDY4NTI4Nzc5MTI5LDAuNjQyMzQ5MzM5NDQwMzQwMjIwNjQzOTg0NiwwLjgwMTU3ODA5MDczMzMwOTkxMjc5NDIwNjUsMC45MTc1OTgzOTkyMjI5Nzc5NjUyMDY1NDc4LDAuOTg0MTgzMDU0NzE4NTg4MTQ5NDcyODI5NF0sXG5cdFx0WyAgMC4xMDgwNTQ5NDg3MDczNDM2NjIwNjYyNDQ3LDAuMzE5MTEyMzY4OTI3ODg5NzYwNDM1NjcxOCwwLjUxNTI0ODYzNjM1ODE1NDA5MTk2NTI5MDcsMC42ODcyOTI5MDQ4MTE2ODU0NzAxNDgwMTk4LDAuODI3MjAxMzE1MDY5NzY0OTkzMTg5Nzk0NywwLjkyODQzNDg4MzY2MzU3MzUxNzMzNjM5MTEsMC45ODYyODM4MDg2OTY4MTIzMzg4NDE1OTczXSxcblx0XHRbMCwwLjIwMTE5NDA5Mzk5NzQzNDUyMjMwMDYyODMsMC4zOTQxNTEzNDcwNzc1NjMzNjk4OTcyMDc0LDAuNTcwOTcyMTcyNjA4NTM4ODQ3NTM3MjI2NywwLjcyNDQxNzczMTM2MDE3MDA0NzQxNjE4NjEsMC44NDgyMDY1ODM0MTA0MjcyMTYyMDA2NDgzLDAuOTM3MjczMzkyNDAwNzA1OTA0MzA3NzU4OSwwLjk4Nzk5MjUxODAyMDQ4NTQyODQ4OTU2NTddLFxuXHRcdFsgIDAuMDk1MDEyNTA5ODM3NjM3NDQwMTg1MzE5MywwLjI4MTYwMzU1MDc3OTI1ODkxMzIzMDQ2MDUsMC40NTgwMTY3Nzc2NTcyMjczODYzNDI0MTk0LDAuNjE3ODc2MjQ0NDAyNjQzNzQ4NDQ2NjcxOCwwLjc1NTQwNDQwODM1NTAwMzAzMzg5NTEwMTIsMC44NjU2MzEyMDIzODc4MzE3NDM4ODA0Njc5LDAuOTQ0NTc1MDIzMDczMjMyNTc2MDc3OTg4NCwwLjk4OTQwMDkzNDk5MTY0OTkzMjU5NjE1NDJdXG5cdF07XG5cblx0dmFyIHdlaWdodHMgPSBbXG5cdFx0WzFdLFxuXHRcdFswLjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC41NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU2XSxcblx0XHRbMC42NTIxNDUxNTQ4NjI1NDYxNDI2MjY5MzYxLDAuMzQ3ODU0ODQ1MTM3NDUzODU3MzczMDYzOV0sXG5cdFx0WzAuNTY4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjQ3ODYyODY3MDQ5OTM2NjQ2ODA0MTI5MTUsMC4yMzY5MjY4ODUwNTYxODkwODc1MTQyNjQwXSxcblx0XHRbMC40Njc5MTM5MzQ1NzI2OTEwNDczODk4NzAzLDAuMzYwNzYxNTczMDQ4MTM4NjA3NTY5ODMzNSwwLjE3MTMyNDQ5MjM3OTE3MDM0NTA0MDI5NjFdLFxuXHRcdFswLjQxNzk1OTE4MzY3MzQ2OTM4Nzc1NTEwMjAsMC4zODE4MzAwNTA1MDUxMTg5NDQ5NTAzNjk4LDAuMjc5NzA1MzkxNDg5Mjc2NjY3OTAxNDY3OCwwLjEyOTQ4NDk2NjE2ODg2OTY5MzI3MDYxMTRdLFxuXHRcdFswLjM2MjY4Mzc4MzM3ODM2MTk4Mjk2NTE1MDQsMC4zMTM3MDY2NDU4Nzc4ODcyODczMzc5NjIyLDAuMjIyMzgxMDM0NDUzMzc0NDcwNTQ0MzU2MCwwLjEwMTIyODUzNjI5MDM3NjI1OTE1MjUzMTRdLFxuXHRcdFswLjMzMDIzOTM1NTAwMTI1OTc2MzE2NDUyNTEsMC4zMTIzNDcwNzcwNDAwMDI4NDAwNjg2MzA0LDAuMjYwNjEwNjk2NDAyOTM1NDYyMzE4NzQyOSwwLjE4MDY0ODE2MDY5NDg1NzQwNDA1ODQ3MjAsMC4wODEyNzQzODgzNjE1NzQ0MTE5NzE4OTIyXSxcblx0XHRbMC4yOTU1MjQyMjQ3MTQ3NTI4NzAxNzM4OTMwLDAuMjY5MjY2NzE5MzA5OTk2MzU1MDkxMjI2OSwwLjIxOTA4NjM2MjUxNTk4MjA0Mzk5NTUzNDksMC4xNDk0NTEzNDkxNTA1ODA1OTMxNDU3NzYzLDAuMDY2NjcxMzQ0MzA4Njg4MTM3NTkzNTY4OF0sXG5cdFx0WzAuMjcyOTI1MDg2Nzc3OTAwNjMwNzE0NDgzNSwwLjI2MjgwNDU0NDUxMDI0NjY2MjE4MDY4ODksMC4yMzMxOTM3NjQ1OTE5OTA0Nzk5MTg1MjM3LDAuMTg2MjkwMjEwOTI3NzM0MjUxNDI2MDk3NiwwLjEyNTU4MDM2OTQ2NDkwNDYyNDYzNDY5NDMsMC4wNTU2Njg1NjcxMTYxNzM2NjY0ODI3NTM3XSxcblx0XHRbMC4yNDkxNDcwNDU4MTM0MDI3ODUwMDA1NjI0LDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5OSwwLjIwMzE2NzQyNjcyMzA2NTkyMTc0OTA2NDUsMC4xNjAwNzgzMjg1NDMzNDYyMjYzMzQ2NTI1LDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NywwLjA0NzE3NTMzNjM4NjUxMTgyNzE5NDYxNjBdLFxuXHRcdFswLjIzMjU1MTU1MzIzMDg3MzkxMDE5NDU4OTUsMC4yMjYyODMxODAyNjI4OTcyMzg0MTIwOTAyLDAuMjA3ODE2MDQ3NTM2ODg4NTAyMzEyNTIzMiwwLjE3ODE0NTk4MDc2MTk0NTczODI4MDA0NjcsMC4xMzg4NzM1MTAyMTk3ODcyMzg0NjM2MDE4LDAuMDkyMTIxNDk5ODM3NzI4NDQ3OTE0NDIxOCwwLjA0MDQ4NDAwNDc2NTMxNTg3OTUyMDAyMTZdLFxuXHRcdFswLjIxNTI2Mzg1MzQ2MzE1Nzc5MDE5NTg3NjQsMC4yMDUxOTg0NjM3MjEyOTU2MDM5NjU5MjQxLDAuMTg1NTM4Mzk3NDc3OTM3ODEzNzQxNzE2NiwwLjE1NzIwMzE2NzE1ODE5MzUzNDU2OTYwMTksMC4xMjE1MTg1NzA2ODc5MDMxODQ2ODk0MTQ4LDAuMDgwMTU4MDg3MTU5NzYwMjA5ODA1NjMzMywwLjAzNTExOTQ2MDMzMTc1MTg2MzAzMTgzMjldLFxuXHRcdFswLjIwMjU3ODI0MTkyNTU2MTI3Mjg4MDYyMDIsMC4xOTg0MzE0ODUzMjcxMTE1NzY0NTYxMTgzLDAuMTg2MTYxMDAwMDE1NTYyMjExMDI2ODAwNiwwLjE2NjI2OTIwNTgxNjk5MzkzMzU1MzIwMDksMC4xMzk1NzA2Nzc5MjYxNTQzMTQ0NDc4MDQ4LDAuMTA3MTU5MjIwNDY3MTcxOTM1MDExODY5NSwwLjA3MDM2NjA0NzQ4ODEwODEyNDcwOTI2NzQsMC4wMzA3NTMyNDE5OTYxMTcyNjgzNTQ2Mjg0XSxcblx0XHRbMC4xODk0NTA2MTA0NTUwNjg0OTYyODUzOTY3LDAuMTgyNjAzNDE1MDQ0OTIzNTg4ODY2NzYzNywwLjE2OTE1NjUxOTM5NTAwMjUzODE4OTMxMjEsMC4xNDk1OTU5ODg4MTY1NzY3MzIwODE1MDE3LDAuMTI0NjI4OTcxMjU1NTMzODcyMDUyNDc2MywwLjA5NTE1ODUxMTY4MjQ5Mjc4NDgwOTkyNTEsMC4wNjIyNTM1MjM5Mzg2NDc4OTI4NjI4NDM4LDAuMDI3MTUyNDU5NDExNzU0MDk0ODUxNzgwNl1cblx0XTtcblxuXHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0c3FydCA9IE1hdGguc3FydCxcblx0XHRwb3cgPSBNYXRoLnBvdyxcblx0XHRjb3MgPSBNYXRoLmNvcyxcblx0XHRQSSA9IE1hdGguUEksXG5cdFx0VE9MRVJBTkNFID0gMTBlLTYsXG5cdFx0RVBTSUxPTiA9IDEwZS0xMjtcblxuXHRmdW5jdGlvbiBzZXR1cFJvb3RzKHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdHZhciB1bmJvdW5kID0gbWluID09PSB1bmRlZmluZWQsXG5cdFx0XHRtaW5FID0gbWluIC0gRVBTSUxPTixcblx0XHRcdG1heEUgPSBtYXggKyBFUFNJTE9OLFxuXHRcdFx0Y291bnQgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbihyb290KSB7XG5cdFx0XHRpZiAodW5ib3VuZCB8fCByb290ID4gbWluRSAmJiByb290IDwgbWF4RSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSByb290IDwgbWluID8gbWluIDogcm9vdCA+IG1heCA/IG1heCA6IHJvb3Q7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0VE9MRVJBTkNFOiBUT0xFUkFOQ0UsXG5cdFx0RVBTSUxPTjogRVBTSUxPTixcblx0XHRLQVBQQTogNCAqIChzcXJ0KDIpIC0gMSkgLyAzLFxuXG5cdFx0aXNaZXJvOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHJldHVybiBhYnModmFsKSA8PSBFUFNJTE9OO1xuXHRcdH0sXG5cblx0XHRpbnRlZ3JhdGU6IGZ1bmN0aW9uKGYsIGEsIGIsIG4pIHtcblx0XHRcdHZhciB4ID0gYWJzY2lzc2FzW24gLSAyXSxcblx0XHRcdFx0dyA9IHdlaWdodHNbbiAtIDJdLFxuXHRcdFx0XHRBID0gKGIgLSBhKSAqIDAuNSxcblx0XHRcdFx0QiA9IEEgKyBhLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bSA9IChuICsgMSkgPj4gMSxcblx0XHRcdFx0c3VtID0gbiAmIDEgPyB3W2krK10gKiBmKEIpIDogMDtcblx0XHRcdHdoaWxlIChpIDwgbSkge1xuXHRcdFx0XHR2YXIgQXggPSBBICogeFtpXTtcblx0XHRcdFx0c3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEEgKiBzdW07XG5cdFx0fSxcblxuXHRcdGZpbmRSb290OiBmdW5jdGlvbihmLCBkZiwgeCwgYSwgYiwgbiwgdG9sZXJhbmNlKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgZnggPSBmKHgpLFxuXHRcdFx0XHRcdGR4ID0gZnggLyBkZih4KSxcblx0XHRcdFx0XHRueCA9IHggLSBkeDtcblx0XHRcdFx0aWYgKGFicyhkeCkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0cmV0dXJuIG54O1xuXHRcdFx0XHRpZiAoZnggPiAwKSB7XG5cdFx0XHRcdFx0YiA9IHg7XG5cdFx0XHRcdFx0eCA9IG54IDw9IGEgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHg7XG5cdFx0XHRcdFx0eCA9IG54ID49IGIgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB4O1xuXHRcdH0sXG5cblx0XHRzb2x2ZVF1YWRyYXRpYzogZnVuY3Rpb24oYSwgYiwgYywgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgYWRkID0gc2V0dXBSb290cyhyb290cywgbWluLCBtYXgpO1xuXG5cdFx0XHRpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRpZiAoYWJzKGIpID49IEVQU0lMT04pXG5cdFx0XHRcdFx0cmV0dXJuIGFkZCgtYyAvIGIpO1xuXHRcdFx0XHRyZXR1cm4gYWJzKGMpIDwgRVBTSUxPTiA/IC0xIDogMDtcblx0XHRcdH1cblx0XHRcdHZhciBwID0gYiAvICgyICogYSk7XG5cdFx0XHR2YXIgcSA9IGMgLyBhO1xuXHRcdFx0dmFyIHAyID0gcCAqIHA7XG5cdFx0XHRpZiAocDIgPCBxIC0gRVBTSUxPTilcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR2YXIgcyA9IHAyID4gcSA/IHNxcnQocDIgLSBxKSA6IDAsXG5cdFx0XHRcdGNvdW50ID0gYWRkKHMgLSBwKTtcblx0XHRcdGlmIChzID4gMClcblx0XHRcdFx0Y291bnQgPSBhZGQoLXMgLSBwKTtcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9LFxuXG5cdFx0c29sdmVDdWJpYzogZnVuY3Rpb24oYSwgYiwgYywgZCwgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHRpZiAoYWJzKGEpIDwgRVBTSUxPTilcblx0XHRcdFx0cmV0dXJuIE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhiLCBjLCBkLCByb290cywgbWluLCBtYXgpO1xuXG5cdFx0XHRiIC89IGE7XG5cdFx0XHRjIC89IGE7XG5cdFx0XHRkIC89IGE7XG5cdFx0XHR2YXIgYWRkID0gc2V0dXBSb290cyhyb290cywgbWluLCBtYXgpLFxuXHRcdFx0XHRiYiA9IGIgKiBiLFxuXHRcdFx0XHRwID0gKGJiIC0gMyAqIGMpIC8gOSxcblx0XHRcdFx0cSA9ICgyICogYmIgKiBiIC0gOSAqIGIgKiBjICsgMjcgKiBkKSAvIDU0LFxuXHRcdFx0XHRwcHAgPSBwICogcCAqIHAsXG5cdFx0XHRcdEQgPSBxICogcSAtIHBwcDtcblx0XHRcdGIgLz0gMztcblx0XHRcdGlmIChhYnMoRCkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGlmIChhYnMocSkgPCBFUFNJTE9OKVxuXHRcdFx0XHRcdHJldHVybiBhZGQoLWIpO1xuXHRcdFx0XHR2YXIgc3FwID0gc3FydChwKSxcblx0XHRcdFx0XHRzbnEgPSBxID4gMCA/IDEgOiAtMTtcblx0XHRcdFx0YWRkKC1zbnEgKiAyICogc3FwIC0gYik7XG5cdFx0XHRcdHJldHVybiBhZGQoc25xICogc3FwIC0gYik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoRCA8IDApIHtcblx0XHRcdFx0dmFyIHNxcCA9IHNxcnQocCksXG5cdFx0XHRcdFx0cGhpID0gTWF0aC5hY29zKHEgLyAoc3FwICogc3FwICogc3FwKSkgLyAzLFxuXHRcdFx0XHRcdHQgPSAtMiAqIHNxcCxcblx0XHRcdFx0XHRvID0gMiAqIFBJIC8gMztcblx0XHRcdFx0YWRkKHQgKiBjb3MocGhpKSAtIGIpO1xuXHRcdFx0XHRhZGQodCAqIGNvcyhwaGkgKyBvKSAtIGIpO1xuXHRcdFx0XHRyZXR1cm4gYWRkKHQgKiBjb3MocGhpIC0gbykgLSBiKTtcblx0XHRcdH1cblx0XHRcdHZhciBBID0gKHEgPiAwID8gLTEgOiAxKSAqIHBvdyhhYnMocSkgKyBzcXJ0KEQpLCAxIC8gMyk7XG5cdFx0XHRyZXR1cm4gYWRkKEEgKyBwIC8gQSAtIGIpO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBQb2ludCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnQnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc1kgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gaGFzWSA/IGFyZzEgOiBhcmcwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGhhc1kgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMueCA9IHRoaXMueSA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLnk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAud2lkdGggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5hbmdsZSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0XHR0aGlzLnNldEFuZ2xlKGFyZzAuYW5nbGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gMDtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdHRoaXMuX19yZWFkID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSAxO1xuXHRcdH1cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiB0aGlzID09PSBwb2ludCB8fCBwb2ludFxuXHRcdFx0XHQmJiAodGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueVxuXHRcdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkocG9pbnQpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLnggPT09IHBvaW50WzBdICYmIHRoaXMueSA9PT0gcG9pbnRbMV0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpICsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSwgZi5udW1iZXIodGhpcy55KV07XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHRpZiAodGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGFuZ2xlID0gdGhpcy5fYW5nbGUgfHwgMDtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNjYWxlID0gbGVuZ3RoIC8gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHNjYWxlKSlcblx0XHRcdFx0dGhpcy5nZXRBbmdsZSgpO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdHRoaXMueCAqIHNjYWxlLFxuXHRcdFx0XHR0aGlzLnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cdGdldEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBbmdsZUluUmFkaWFucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRzZXRBbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLnNldEFuZ2xlSW5SYWRpYW5zLmNhbGwodGhpcywgYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcblx0fSxcblxuXHRnZXRBbmdsZUluRGVncmVlczogJyNnZXRBbmdsZScsXG5cdHNldEFuZ2xlSW5EZWdyZWVzOiAnI3NldEFuZ2xlJyxcblxuXHRnZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5fYW5nbGUgfHwgMFxuXHRcdFx0XHRcdDogdGhpcy5fYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRkaXYgPSB0aGlzLmdldExlbmd0aCgpICogcG9pbnQuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhkaXYpKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IHRoaXMuZG90KHBvaW50KSAvIGRpdjtcblx0XHRcdFx0cmV0dXJuIE1hdGguYWNvcyhhIDwgLTEgPyAtMSA6IGEgPiAxID8gMSA6IGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuXHRcdGlmICghdGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0TWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuXHRcdFx0XHRNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFF1YWRyYW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ID49IDAgPyB0aGlzLnkgPj0gMCA/IDEgOiA0IDogdGhpcy55ID49IDAgPyAyIDogMztcblx0fVxufSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0RGlyZWN0ZWRBbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBNYXRoLmF0YW4yKHRoaXMuY3Jvc3MocG9pbnQpLCB0aGlzLmRvdChwb2ludCkpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LnggLSB0aGlzLngsXG5cdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMueSxcblx0XHRcdGQgPSB4ICogeCArIHkgKiB5LFxuXHRcdFx0c3F1YXJlZCA9IEJhc2UucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBzcXVhcmVkID8gZCA6IE1hdGguc3FydChkKTtcblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZClcblx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldExlbmd0aCgpLFxuXHRcdFx0c2NhbGUgPSBjdXJyZW50ICE9PSAwID8gbGVuZ3RoIC8gY3VycmVudCA6IDAsXG5cdFx0XHRwb2ludCA9IG5ldyBQb2ludCh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUpO1xuXHRcdGlmIChzY2FsZSA+PSAwKVxuXHRcdFx0cG9pbnQuX2FuZ2xlID0gdGhpcy5fYW5nbGU7XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIGNlbnRlcikge1xuXHRcdGlmIChhbmdsZSA9PT0gMClcblx0XHRcdHJldHVybiB0aGlzLmNsb25lKCk7XG5cdFx0YW5nbGUgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIHBvaW50ID0gY2VudGVyID8gdGhpcy5zdWJ0cmFjdChjZW50ZXIpIDogdGhpcyxcblx0XHRcdHMgPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHBvaW50ID0gbmV3IFBvaW50KFxuXHRcdFx0cG9pbnQueCAqIGMgLSBwb2ludC55ICogcyxcblx0XHRcdHBvaW50LnggKiBzICsgcG9pbnQueSAqIGNcblx0XHQpO1xuXHRcdHJldHVybiBjZW50ZXIgPyBwb2ludC5hZGQoY2VudGVyKSA6IHBvaW50O1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcykgOiB0aGlzO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgcG9pbnQueCwgdGhpcy55ICsgcG9pbnQueSk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHBvaW50LngsIHRoaXMueSAtIHBvaW50LnkpO1xuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICUgcG9pbnQueCwgdGhpcy55ICUgcG9pbnQueSk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KC10aGlzLngsIC10aGlzLnkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzKTtcblx0fSxcblxuXHRpc0Nsb3NlOiBmdW5jdGlvbihwb2ludCwgdG9sZXJhbmNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UocG9pbnQpIDwgdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGlzQ29saW5lYXI6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuY3Jvc3MocG9pbnQpKSA8IDAuMDAwMDE7XG5cdH0sXG5cblx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLmFicyh0aGlzLmRvdChwb2ludCkpIDwgMC4wMDAwMTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLnkpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy54KSB8fCBpc05hTih0aGlzLnkpO1xuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC54ICsgdGhpcy55ICogcG9pbnQueTtcblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC55IC0gdGhpcy55ICogcG9pbnQueDtcblx0fSxcblxuXHRwcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHBvaW50LmlzWmVybygpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KDAsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2NhbGUgPSB0aGlzLmRvdChwb2ludCkgLyBwb2ludC5kb3QocG9pbnQpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0cG9pbnQueCAqIHNjYWxlLFxuXHRcdFx0XHRwb2ludC55ICogc2NhbGVcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5taW4ocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5taW4ocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb2ludDEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBvaW50MiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdE1hdGgubWF4KHBvaW50MS54LCBwb2ludDIueCksXG5cdFx0XHRcdE1hdGgubWF4KHBvaW50MS55LCBwb2ludDIueSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgb3AgPSBNYXRoW25hbWVdO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChvcCh0aGlzLngpLCBvcCh0aGlzLnkpKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KHgsIHksIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgU2l6ZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2l6ZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZShhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBoYXNIZWlnaHQgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLndpZHRoID0gYXJnMDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gaGFzSGVpZ2h0ID8gYXJnMSA6IGFyZzA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gaGFzSGVpZ2h0ID8gMiA6IDE7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC5sZW5ndGggPiAxID8gYXJnMFsxXSA6IGFyZzBbMF07XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAud2lkdGggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC53aWR0aDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzAueDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLnk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0dGhpcy5fX3JlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IDE7XG5cdFx0fVxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHRyZXR1cm4gc2l6ZSA9PT0gdGhpcyB8fCBzaXplICYmICh0aGlzLndpZHRoID09PSBzaXplLndpZHRoXG5cdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplLmhlaWdodFxuXHRcdFx0XHR8fCBBcnJheS5pc0FycmF5KHNpemUpICYmIHRoaXMud2lkdGggPT09IHNpemVbMF1cblx0XHRcdFx0XHQmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZVsxXSkgfHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpICsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCArIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICsgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC0gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLSBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKiBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAqIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtb2R1bG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggJSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAlIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZSgtdGhpcy53aWR0aCwgLXRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMud2lkdGgpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy53aWR0aCkgfHwgaXNOYU4odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgb3AgPSBNYXRoW25hbWVdO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKG9wKHRoaXMud2lkdGgpLCBvcCh0aGlzLmhlaWdodCkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFNpemUgPSBTaXplLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUod2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oZWlnaHQ7XG5cdH0sXG5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBSZWN0YW5nbGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1JlY3RhbmdsZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcblx0XHRcdHJlYWQgPSAwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dGhpcy54ID0gYXJnMDtcblx0XHRcdHRoaXMueSA9IGFyZzE7XG5cdFx0XHR0aGlzLndpZHRoID0gYXJnMjtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMztcblx0XHRcdHJlYWQgPSA0O1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwWzFdO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMFsyXTtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwWzNdO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9PSB1bmRlZmluZWQgfHwgYXJnMC53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAueCB8fCAwO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLnkgfHwgMDtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzAud2lkdGggfHwgMDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmhlaWdodCB8fCAwO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5mcm9tID09PSB1bmRlZmluZWQgJiYgYXJnMC50byA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMueCA9IHRoaXMueSA9IHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRcdHRoaXMuX3NldChhcmcwKTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghcmVhZCkge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0bmV4dCA9IEJhc2UucGVlayhhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHRcdHRoaXMueSA9IHBvaW50Lnk7XG5cdFx0XHRpZiAobmV4dCAmJiBuZXh0LnggIT09IHVuZGVmaW5lZCB8fCBCYXNlLmhhc05hbWVkKGFyZ3VtZW50cywgJ3RvJykpIHtcblx0XHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJyk7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB0by54IC0gcG9pbnQueDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSB0by55IC0gcG9pbnQueTtcblx0XHRcdFx0aWYgKHRoaXMud2lkdGggPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy54ID0gdG8ueDtcblx0XHRcdFx0XHR0aGlzLndpZHRoID0gLXRoaXMud2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuaGVpZ2h0IDwgMCkge1xuXHRcdFx0XHRcdHRoaXMueSA9IHRvLnk7XG5cdFx0XHRcdFx0dGhpcy5oZWlnaHQgPSAtdGhpcy5oZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0cmVhZCA9IGFyZ3VtZW50cy5fX2luZGV4O1xuXHRcdH1cblx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgcnQgPSBCYXNlLmlzUGxhaW5WYWx1ZShyZWN0KVxuXHRcdFx0XHQ/IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0OiByZWN0O1xuXHRcdHJldHVybiBydCA9PT0gdGhpc1xuXHRcdFx0XHR8fCBydCAmJiB0aGlzLnggPT09IHJ0LnggJiYgdGhpcy55ID09PSBydC55XG5cdFx0XHRcdFx0JiYgdGhpcy53aWR0aCA9PT0gcnQud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHJ0LmhlaWdodFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpXG5cdFx0XHRcdCsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSlcblx0XHRcdFx0KyAnLCB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpXG5cdFx0XHRcdCsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMueSksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFNpemUgOiBMaW5rZWRTaXplO1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9maXhYKVxuXHRcdFx0dGhpcy54ICs9ICh0aGlzLndpZHRoIC0gc2l6ZS53aWR0aCkgKiB0aGlzLl9maXhYO1xuXHRcdGlmICh0aGlzLl9maXhZKVxuXHRcdFx0dGhpcy55ICs9ICh0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KSAqIHRoaXMuX2ZpeFk7XG5cdFx0dGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHR0aGlzLl9maXhXID0gMTtcblx0XHR0aGlzLl9maXhIID0gMTtcblx0fSxcblxuXHRnZXRMZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54O1xuXHR9LFxuXG5cdHNldExlZnQ6IGZ1bmN0aW9uKGxlZnQpIHtcblx0XHRpZiAoIXRoaXMuX2ZpeFcpXG5cdFx0XHR0aGlzLndpZHRoIC09IGxlZnQgLSB0aGlzLng7XG5cdFx0dGhpcy54ID0gbGVmdDtcblx0XHR0aGlzLl9maXhYID0gMDtcblx0fSxcblxuXHRnZXRUb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnk7XG5cdH0sXG5cblx0c2V0VG9wOiBmdW5jdGlvbih0b3ApIHtcblx0XHRpZiAoIXRoaXMuX2ZpeEgpXG5cdFx0XHR0aGlzLmhlaWdodCAtPSB0b3AgLSB0aGlzLnk7XG5cdFx0dGhpcy55ID0gdG9wO1xuXHRcdHRoaXMuX2ZpeFkgPSAwO1xuXHR9LFxuXG5cdGdldFJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcblx0fSxcblxuXHRzZXRSaWdodDogZnVuY3Rpb24ocmlnaHQpIHtcblx0XHRpZiAodGhpcy5fZml4WCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2ZpeFggIT09IDEpXG5cdFx0XHR0aGlzLl9maXhXID0gMDtcblx0XHRpZiAodGhpcy5fZml4Vylcblx0XHRcdHRoaXMueCA9IHJpZ2h0IC0gdGhpcy53aWR0aDtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLndpZHRoID0gcmlnaHQgLSB0aGlzLng7XG5cdFx0dGhpcy5fZml4WCA9IDE7XG5cdH0sXG5cblx0Z2V0Qm90dG9tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0c2V0Qm90dG9tOiBmdW5jdGlvbihib3R0b20pIHtcblx0XHRpZiAodGhpcy5fZml4WSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2ZpeFkgIT09IDEpXG5cdFx0XHR0aGlzLl9maXhIID0gMDtcblx0XHRpZiAodGhpcy5fZml4SClcblx0XHRcdHRoaXMueSA9IGJvdHRvbSAtIHRoaXMuaGVpZ2h0O1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuaGVpZ2h0ID0gYm90dG9tIC0gdGhpcy55O1xuXHRcdHRoaXMuX2ZpeFkgPSAxO1xuXHR9LFxuXG5cdGdldENlbnRlclg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoICogMC41O1xuXHR9LFxuXG5cdHNldENlbnRlclg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLnggPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcblx0XHR0aGlzLl9maXhYID0gMC41O1xuXHR9LFxuXG5cdGdldENlbnRlclk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodCAqIDAuNTtcblx0fSxcblxuXHRzZXRDZW50ZXJZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy55ID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXHRcdHRoaXMuX2ZpeFkgPSAwLjU7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMuZ2V0Q2VudGVyWCgpLCB0aGlzLmdldENlbnRlclkoKSwgdGhpcywgJ3NldENlbnRlcicpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWChwb2ludC54KTtcblx0XHR0aGlzLnNldENlbnRlclkocG9pbnQueSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMDtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oYXJnKSB7XG5cdFx0cmV0dXJuIGFyZyAmJiBhcmcud2lkdGggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHR8fCAoQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKS5sZW5ndGggPT0gNFxuXHRcdFx0XHQ/IHRoaXMuX2NvbnRhaW5zUmVjdGFuZ2xlKFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykpXG5cdFx0XHRcdDogdGhpcy5fY29udGFpbnNQb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueVxuXHRcdFx0XHQmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRfY29udGFpbnNSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeCA9IHJlY3QueCxcblx0XHRcdHkgPSByZWN0Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggKyByZWN0LndpZHRoIDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSArIHJlY3QuaGVpZ2h0IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gcmVjdC54ICsgcmVjdC53aWR0aCA+IHRoaXMueFxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+IHRoaXMueVxuXHRcdFx0XHQmJiByZWN0LnggPCB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHJlY3QueSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdHRvdWNoZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gcmVjdC54ICsgcmVjdC53aWR0aCA+PSB0aGlzLnhcblx0XHRcdFx0JiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHJlY3QueCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHJlY3QueSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3QueSksXG5cdFx0XHR4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuXHRcdFx0eTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0dW5pdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3QueSksXG5cdFx0XHR4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuXHRcdFx0eTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0aW5jbHVkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciB4MSA9IE1hdGgubWluKHRoaXMueCwgcG9pbnQueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcG9pbnQueSksXG5cdFx0XHR4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHBvaW50LngpLFxuXHRcdFx0eTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcG9pbnQueSk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRleHBhbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbW91bnQgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGhvciA9IGFtb3VudC53aWR0aCxcblx0XHRcdHZlciA9IGFtb3VudC5oZWlnaHQ7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gaG9yIC8gMiwgdGhpcy55IC0gdmVyIC8gMixcblx0XHRcdFx0dGhpcy53aWR0aCArIGhvciwgdGhpcy5oZWlnaHQgKyB2ZXIpO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbihob3IsIHZlcikge1xuXHRcdHJldHVybiB0aGlzLmV4cGFuZCh0aGlzLndpZHRoICogaG9yIC0gdGhpcy53aWR0aCxcblx0XHRcdFx0dGhpcy5oZWlnaHQgKiAodmVyID09PSB1bmRlZmluZWQgPyBob3IgOiB2ZXIpIC0gdGhpcy5oZWlnaHQpO1xuXHR9XG59LCBCYXNlLmVhY2goW1xuXHRcdFsnVG9wJywgJ0xlZnQnXSwgWydUb3AnLCAnUmlnaHQnXSxcblx0XHRbJ0JvdHRvbScsICdMZWZ0J10sIFsnQm90dG9tJywgJ1JpZ2h0J10sXG5cdFx0WydMZWZ0JywgJ0NlbnRlciddLCBbJ1RvcCcsICdDZW50ZXInXSxcblx0XHRbJ1JpZ2h0JywgJ0NlbnRlciddLCBbJ0JvdHRvbScsICdDZW50ZXInXVxuXHRdLFxuXHRmdW5jdGlvbihwYXJ0cywgaW5kZXgpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzLmpvaW4oJycpO1xuXHRcdHZhciB4Rmlyc3QgPSAvXltSTF0vLnRlc3QocGFydCk7XG5cdFx0aWYgKGluZGV4ID49IDQpXG5cdFx0XHRwYXJ0c1sxXSArPSB4Rmlyc3QgPyAnWScgOiAnWCc7XG5cdFx0dmFyIHggPSBwYXJ0c1t4Rmlyc3QgPyAwIDogMV0sXG5cdFx0XHR5ID0gcGFydHNbeEZpcnN0ID8gMSA6IDBdLFxuXHRcdFx0Z2V0WCA9ICdnZXQnICsgeCxcblx0XHRcdGdldFkgPSAnZ2V0JyArIHksXG5cdFx0XHRzZXRYID0gJ3NldCcgKyB4LFxuXHRcdFx0c2V0WSA9ICdzZXQnICsgeSxcblx0XHRcdGdldCA9ICdnZXQnICsgcGFydCxcblx0XHRcdHNldCA9ICdzZXQnICsgcGFydDtcblx0XHR0aGlzW2dldF0gPSBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRcdHJldHVybiBuZXcgY3Rvcih0aGlzW2dldFhdKCksIHRoaXNbZ2V0WV0oKSwgdGhpcywgc2V0KTtcblx0XHR9O1xuXHRcdHRoaXNbc2V0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpc1tzZXRYXShwb2ludC54KTtcblx0XHRcdHRoaXNbc2V0WV0ocG9pbnQueSk7XG5cdFx0fTtcblx0fSwge1xuXHRcdGJlYW5zOiB0cnVlXG5cdH1cbikpO1xuXG52YXIgTGlua2VkUmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBwcm90byA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG5cblx0cmV0dXJuIEJhc2UuZWFjaChbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KTtcblx0XHR2YXIgaW50ZXJuYWwgPSAnXycgKyBrZXk7XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tpbnRlcm5hbF07XG5cdFx0fTtcblxuXHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzW2ludGVybmFsXSA9IHZhbHVlO1xuXHRcdFx0aWYgKCF0aGlzLl9kb250Tm90aWZ5KVxuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdH07XG5cdH0sIEJhc2UuZWFjaChbJ1BvaW50JywgJ1NpemUnLCAnQ2VudGVyJyxcblx0XHRcdCdMZWZ0JywgJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnQ2VudGVyWCcsICdDZW50ZXJZJyxcblx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0J0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlciddLFxuXHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIG5hbWUgPSAnc2V0JyArIGtleTtcblx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IHRydWU7XG5cdFx0XHRcdHByb3RvW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMuX2RvbnROb3RpZnkgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9vd25lci5fYm91bmRzU2VsZWN0ZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0XHRcdGlmIChvd25lci5zZXRTZWxlY3RlZCkge1xuXHRcdFx0XHRcdG93bmVyLl9ib3VuZHNTZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0XHRcdG93bmVyLnNldFNlbGVjdGVkKHNlbGVjdGVkIHx8IG93bmVyLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA+IDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0KTtcbn0pO1xuXG52YXIgTWF0cml4ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdNYXRyaXgnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIE1hdHJpeChhcmcpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0b2sgPSB0cnVlO1xuXHRcdGlmIChjb3VudCA9PT0gNikge1xuXHRcdFx0dGhpcy5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoYXJnIGluc3RhbmNlb2YgTWF0cml4KSB7XG5cdFx0XHRcdHRoaXMuc2V0KGFyZy5fYSwgYXJnLl9jLCBhcmcuX2IsIGFyZy5fZCwgYXJnLl90eCwgYXJnLl90eSk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9rID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghb2spXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihhLCBjLCBiLCBkLCB0eCwgdHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IGE7XG5cdFx0dGhpcy5fYyA9IGM7XG5cdFx0dGhpcy5fYiA9IGI7XG5cdFx0dGhpcy5fZCA9IGQ7XG5cdFx0dGhpcy5fdHggPSB0eDtcblx0XHR0aGlzLl90eSA9IHR5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmdldFZhbHVlcygpLCBvcHRpb25zKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0aWYgKG93bmVyKSB7XG5cdFx0XHRpZiAob3duZXIuX2FwcGx5TWF0cml4KSB7XG5cdFx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG93bmVyLl9jaGFuZ2VkKDkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCxcblx0XHRcdFx0dGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKG14KSB7XG5cdFx0cmV0dXJuIG14ID09PSB0aGlzIHx8IG14ICYmIHRoaXMuX2EgPT09IG14Ll9hICYmIHRoaXMuX2IgPT09IG14Ll9iXG5cdFx0XHRcdCYmIHRoaXMuX2MgPT09IG14Ll9jICYmIHRoaXMuX2QgPT09IG14Ll9kXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSBteC5fdHggJiYgdGhpcy5fdHkgPT09IG14Ll90eVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICdbWycgKyBbZi5udW1iZXIodGhpcy5fYSksIGYubnVtYmVyKHRoaXMuX2IpLFxuXHRcdFx0XHRcdGYubnVtYmVyKHRoaXMuX3R4KV0uam9pbignLCAnKSArICddLCBbJ1xuXHRcdFx0XHQrIFtmLm51bWJlcih0aGlzLl9jKSwgZi5udW1iZXIodGhpcy5fZCksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHkpXS5qb2luKCcsICcpICsgJ11dJztcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gdGhpcy5fZCA9IDE7XG5cdFx0dGhpcy5fYyA9IHRoaXMuX2IgPSB0aGlzLl90eCA9IHRoaXMuX3R5ID0gMDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFwcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHR0aGlzLl90eCArPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iO1xuXHRcdHRoaXMuX3R5ICs9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2NhbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR0aGlzLl9hICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYyAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2IgKj0gc2NhbGUueTtcblx0XHR0aGlzLl9kICo9IHNjYWxlLnk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0YW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpLFxuXHRcdFx0eCA9IGNlbnRlci54LFxuXHRcdFx0eSA9IGNlbnRlci55LFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0dHggPSB4IC0geCAqIGNvcyArIHkgKiBzaW4sXG5cdFx0XHR0eSA9IHkgLSB4ICogc2luIC0geSAqIGNvcyxcblx0XHRcdGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kO1xuXHRcdHRoaXMuX2EgPSBjb3MgKiBhICsgc2luICogYjtcblx0XHR0aGlzLl9iID0gLXNpbiAqIGEgKyBjb3MgKiBiO1xuXHRcdHRoaXMuX2MgPSBjb3MgKiBjICsgc2luICogZDtcblx0XHR0aGlzLl9kID0gLXNpbiAqIGMgKyBjb3MgKiBkO1xuXHRcdHRoaXMuX3R4ICs9IHR4ICogYSArIHR5ICogYjtcblx0XHR0aGlzLl90eSArPSB0eCAqIGMgKyB0eSAqIGQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNoZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2hlYXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRjID0gdGhpcy5fYztcblx0XHR0aGlzLl9hICs9IHNoZWFyLnkgKiB0aGlzLl9iO1xuXHRcdHRoaXMuX2MgKz0gc2hlYXIueSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fYiArPSBzaGVhci54ICogYTtcblx0XHR0aGlzLl9kICs9IHNoZWFyLnggKiBjO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRza2V3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2tldyA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0dG9SYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdHNoZWFyID0gbmV3IFBvaW50KE1hdGgudGFuKHNrZXcueCAqIHRvUmFkaWFucyksXG5cdFx0XHRcdE1hdGgudGFuKHNrZXcueSAqIHRvUmFkaWFucykpO1xuXHRcdHJldHVybiB0aGlzLnNoZWFyKHNoZWFyLCBjZW50ZXIpO1xuXHR9LFxuXG5cdGNvbmNhdGVuYXRlOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0YjIgPSBteC5fYixcblx0XHRcdGMyID0gbXguX2MsXG5cdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0dHkyID0gbXguX3R5O1xuXHRcdHRoaXMuX2EgPSBhMiAqIGExICsgYzIgKiBiMTtcblx0XHR0aGlzLl9iID0gYjIgKiBhMSArIGQyICogYjE7XG5cdFx0dGhpcy5fYyA9IGEyICogYzEgKyBjMiAqIGQxO1xuXHRcdHRoaXMuX2QgPSBiMiAqIGMxICsgZDIgKiBkMTtcblx0XHR0aGlzLl90eCArPSB0eDIgKiBhMSArIHR5MiAqIGIxO1xuXHRcdHRoaXMuX3R5ICs9IHR4MiAqIGMxICsgdHkyICogZDE7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHByZUNvbmNhdGVuYXRlOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHR0eDEgPSB0aGlzLl90eCxcblx0XHRcdHR5MSA9IHRoaXMuX3R5LFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGIyICogYzE7XG5cdFx0dGhpcy5fYiA9IGEyICogYjEgKyBiMiAqIGQxO1xuXHRcdHRoaXMuX2MgPSBjMiAqIGExICsgZDIgKiBjMTtcblx0XHR0aGlzLl9kID0gYzIgKiBiMSArIGQyICogZDE7XG5cdFx0dGhpcy5fdHggPSBhMiAqIHR4MSArIGIyICogdHkxICsgdHgyO1xuXHRcdHRoaXMuX3R5ID0gYzIgKiB0eDEgKyBkMiAqIHR5MSArIHR5Mjtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2hhaW46IGZ1bmN0aW9uKG14KSB7XG5cdFx0dmFyIGExID0gdGhpcy5fYSxcblx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdGQxID0gdGhpcy5fZCxcblx0XHRcdHR4MSA9IHRoaXMuX3R4LFxuXHRcdFx0dHkxID0gdGhpcy5fdHksXG5cdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0YjIgPSBteC5fYixcblx0XHRcdGMyID0gbXguX2MsXG5cdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0dHkyID0gbXguX3R5O1xuXHRcdHJldHVybiBuZXcgTWF0cml4KFxuXHRcdFx0XHRhMiAqIGExICsgYzIgKiBiMSxcblx0XHRcdFx0YTIgKiBjMSArIGMyICogZDEsXG5cdFx0XHRcdGIyICogYTEgKyBkMiAqIGIxLFxuXHRcdFx0XHRiMiAqIGMxICsgZDIgKiBkMSxcblx0XHRcdFx0dHgxICsgdHgyICogYTEgKyB0eTIgKiBiMSxcblx0XHRcdFx0dHkxICsgdHgyICogYzEgKyB0eTIgKiBkMSk7XG5cdH0sXG5cblx0aXNJZGVudGl0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2EgPT09IDEgJiYgdGhpcy5fYyA9PT0gMCAmJiB0aGlzLl9iID09PSAwICYmIHRoaXMuX2QgPT09IDFcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IDAgJiYgdGhpcy5fdHkgPT09IDA7XG5cdH0sXG5cblx0b3JOdWxsSWZJZGVudGl0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpID8gbnVsbCA6IHRoaXM7XG5cdH0sXG5cblx0aXNJbnZlcnRpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHR9LFxuXG5cdGlzU2luZ3VsYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKCBzcmMsIGRzdCwgY291bnQpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDNcblx0XHRcdD8gdGhpcy5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhzcmMsIGRzdCwgY291bnQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdHJldHVybiBkZXN0LnNldChcblx0XHRcdHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2IgKyB0aGlzLl90eCxcblx0XHRcdHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eSxcblx0XHRcdF9kb250Tm90aWZ5XG5cdFx0KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKHNyYywgZHN0LCBjb3VudCkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGogPSAwLFxuXHRcdFx0bWF4ID0gMiAqIGNvdW50O1xuXHRcdHdoaWxlIChpIDwgbWF4KSB7XG5cdFx0XHR2YXIgeCA9IHNyY1tpKytdLFxuXHRcdFx0XHR5ID0gc3JjW2krK107XG5cdFx0XHRkc3RbaisrXSA9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2IgKyB0aGlzLl90eDtcblx0XHRcdGRzdFtqKytdID0geCAqIHRoaXMuX2MgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5O1xuXHRcdH1cblx0XHRyZXR1cm4gZHN0O1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db3JuZXJzOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHgxID0gcmVjdC54LFxuXHRcdFx0eTEgPSByZWN0LnksXG5cdFx0XHR4MiA9IHgxICsgcmVjdC53aWR0aCxcblx0XHRcdHkyID0geTEgKyByZWN0LmhlaWdodCxcblx0XHRcdGNvb3JkcyA9IFsgeDEsIHkxLCB4MiwgeTEsIHgyLCB5MiwgeDEsIHkyIF07XG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCA0KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQm91bmRzOiBmdW5jdGlvbihib3VuZHMsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGNvb3JkcyA9IHRoaXMuX3RyYW5zZm9ybUNvcm5lcnMoYm91bmRzKSxcblx0XHRcdG1pbiA9IGNvb3Jkcy5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IGNvb3Jkcy5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAyOyBpIDwgODsgaSsrKSB7XG5cdFx0XHR2YXIgdmFsID0gY29vcmRzW2ldLFxuXHRcdFx0XHRqID0gaSAmIDE7XG5cdFx0XHRpZiAodmFsIDwgbWluW2pdKVxuXHRcdFx0XHRtaW5bal0gPSB2YWw7XG5cdFx0XHRlbHNlIGlmICh2YWwgPiBtYXhbal0pXG5cdFx0XHRcdG1heFtqXSA9IHZhbDtcblx0XHR9XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBSZWN0YW5nbGUoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdLFxuXHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdH0sXG5cblx0aW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfZ2V0RGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9hICogdGhpcy5fZCAtIHRoaXMuX2IgKiB0aGlzLl9jO1xuXHRcdHJldHVybiBpc0Zpbml0ZShkZXQpICYmICFOdW1lcmljYWwuaXNaZXJvKGRldClcblx0XHRcdFx0JiYgaXNGaW5pdGUodGhpcy5fdHgpICYmIGlzRmluaXRlKHRoaXMuX3R5KVxuXHRcdFx0XHQ/IGRldCA6IG51bGw7XG5cdH0sXG5cblx0X2ludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHRcdGlmICghZGV0KVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy5fdHgsXG5cdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMuX3R5O1xuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUG9pbnQoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQoXG5cdFx0XHQoeCAqIHRoaXMuX2QgLSB5ICogdGhpcy5fYikgLyBkZXQsXG5cdFx0XHQoeSAqIHRoaXMuX2EgLSB4ICogdGhpcy5fYykgLyBkZXQsXG5cdFx0XHRfZG9udE5vdGlmeVxuXHRcdCk7XG5cdH0sXG5cblx0ZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYSA9IHRoaXMuX2EsIGIgPSB0aGlzLl9iLCBjID0gdGhpcy5fYywgZCA9IHRoaXMuX2Q7XG5cdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oYSAqIGQgLSBiICogYykpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG5cdFx0YSAvPSBzY2FsZVg7XG5cdFx0YiAvPSBzY2FsZVg7XG5cblx0XHR2YXIgc2hlYXIgPSBhICogYyArIGIgKiBkO1xuXHRcdGMgLT0gYSAqIHNoZWFyO1xuXHRcdGQgLT0gYiAqIHNoZWFyO1xuXG5cdFx0dmFyIHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcblx0XHRjIC89IHNjYWxlWTtcblx0XHRkIC89IHNjYWxlWTtcblx0XHRzaGVhciAvPSBzY2FsZVk7XG5cblx0XHRpZiAoYSAqIGQgPCBiICogYykge1xuXHRcdFx0YSA9IC1hO1xuXHRcdFx0YiA9IC1iO1xuXHRcdFx0c2hlYXIgPSAtc2hlYXI7XG5cdFx0XHRzY2FsZVggPSAtc2NhbGVYO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzY2FsaW5nOiBuZXcgUG9pbnQoc2NhbGVYLCBzY2FsZVkpLFxuXHRcdFx0cm90YXRpb246IC1NYXRoLmF0YW4yKGIsIGEpICogMTgwIC8gTWF0aC5QSSxcblx0XHRcdHNoZWFyaW5nOiBzaGVhclxuXHRcdH07XG5cdH0sXG5cblx0Z2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gWyB0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLCB0aGlzLl90eCwgdGhpcy5fdHkgXTtcblx0fSxcblxuXHRnZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGdldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kZWNvbXBvc2UoKSB8fCB7fSkuc2NhbGluZztcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRlY29tcG9zZSgpIHx8IHt9KS5yb3RhdGlvbjtcblx0fSxcblxuXHRpbnZlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2dldERldGVybWluYW50KCk7XG5cdFx0cmV0dXJuIGRldCAmJiBuZXcgTWF0cml4KFxuXHRcdFx0XHR0aGlzLl9kIC8gZGV0LFxuXHRcdFx0XHQtdGhpcy5fYyAvIGRldCxcblx0XHRcdFx0LXRoaXMuX2IgLyBkZXQsXG5cdFx0XHRcdHRoaXMuX2EgLyBkZXQsXG5cdFx0XHRcdCh0aGlzLl9iICogdGhpcy5fdHkgLSB0aGlzLl9kICogdGhpcy5fdHgpIC8gZGV0LFxuXHRcdFx0XHQodGhpcy5fYyAqIHRoaXMuX3R4IC0gdGhpcy5fYSAqIHRoaXMuX3R5KSAvIGRldCk7XG5cdH0sXG5cblx0c2hpZnRsZXNzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLCAwLCAwKTtcblx0fSxcblxuXHRhcHBseVRvQ29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LnRyYW5zZm9ybSh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLCB0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9XG59LCBCYXNlLmVhY2goWydhJywgJ2MnLCAnYicsICdkJywgJ3R4JywgJ3R5J10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0cHJvcCA9ICdfJyArIG5hbWU7XG5cdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzW3Byb3BdO1xuXHR9O1xuXHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXNbcHJvcF0gPSB2YWx1ZTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGluZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGluZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTGluZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG5cdFx0dmFyIGFzVmVjdG9yID0gZmFsc2U7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwO1xuXHRcdFx0dGhpcy5fcHkgPSBhcmcxO1xuXHRcdFx0dGhpcy5fdnggPSBhcmcyO1xuXHRcdFx0dGhpcy5fdnkgPSBhcmczO1xuXHRcdFx0YXNWZWN0b3IgPSBhcmc0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9weCA9IGFyZzAueDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMC55O1xuXHRcdFx0dGhpcy5fdnggPSBhcmcxLng7XG5cdFx0XHR0aGlzLl92eSA9IGFyZzEueTtcblx0XHRcdGFzVmVjdG9yID0gYXJnMjtcblx0XHR9XG5cdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0dGhpcy5fdnggLT0gdGhpcy5fcHg7XG5cdFx0XHR0aGlzLl92eSAtPSB0aGlzLl9weTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fcHgsIHRoaXMuX3B5KTtcblx0fSxcblxuXHRnZXRWZWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fdngsIHRoaXMuX3Z5KTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFZlY3RvcigpLmdldExlbmd0aCgpO1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24obGluZSwgaXNJbmZpbml0ZSkge1xuXHRcdHJldHVybiBMaW5lLmludGVyc2VjdChcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdGxpbmUuX3B4LCBsaW5lLl9weSwgbGluZS5fdngsIGxpbmUuX3Z5LFxuXHRcdFx0XHR0cnVlLCBpc0luZmluaXRlKTtcblx0fSxcblxuXHRnZXRTaWRlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBMaW5lLmdldFNpZGUoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRwb2ludC54LCBwb2ludC55LCB0cnVlKTtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnMoTGluZS5nZXRTaWduZWREaXN0YW5jZShcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUpKTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbihhcHgsIGFweSwgYXZ4LCBhdnksIGJweCwgYnB5LCBidngsIGJ2eSwgYXNWZWN0b3IsXG5cdFx0XHRcdGlzSW5maW5pdGUpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0YXZ4IC09IGFweDtcblx0XHRcdFx0YXZ5IC09IGFweTtcblx0XHRcdFx0YnZ4IC09IGJweDtcblx0XHRcdFx0YnZ5IC09IGJweTtcblx0XHRcdH1cblx0XHRcdHZhciBjcm9zcyA9IGF2eCAqIGJ2eSAtIGF2eSAqIGJ2eDtcblx0XHRcdGlmICghTnVtZXJpY2FsLmlzWmVybyhjcm9zcykpIHtcblx0XHRcdFx0dmFyIGR4ID0gYXB4IC0gYnB4LFxuXHRcdFx0XHRcdGR5ID0gYXB5IC0gYnB5LFxuXHRcdFx0XHRcdHRhID0gKGJ2eCAqIGR5IC0gYnZ5ICogZHgpIC8gY3Jvc3MsXG5cdFx0XHRcdFx0dGIgPSAoYXZ4ICogZHkgLSBhdnkgKiBkeCkgLyBjcm9zcztcblx0XHRcdFx0aWYgKGlzSW5maW5pdGUgfHwgMCA8PSB0YSAmJiB0YSA8PSAxICYmIDAgPD0gdGIgJiYgdGIgPD0gMSlcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0XHRcdGFweCArIHRhICogYXZ4LFxuXHRcdFx0XHRcdFx0XHRcdGFweSArIHRhICogYXZ5KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0U2lkZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHZ4IC09IHB4O1xuXHRcdFx0XHR2eSAtPSBweTtcblx0XHRcdH1cblx0XHRcdHZhciB2MnggPSB4IC0gcHgsXG5cdFx0XHRcdHYyeSA9IHkgLSBweSxcblx0XHRcdFx0Y2N3ID0gdjJ4ICogdnkgLSB2MnkgKiB2eDtcblx0XHRcdGlmIChjY3cgPT09IDApIHtcblx0XHRcdFx0Y2N3ID0gdjJ4ICogdnggKyB2MnkgKiB2eTtcblx0XHRcdFx0aWYgKGNjdyA+IDApIHtcblx0XHRcdFx0XHR2MnggLT0gdng7XG5cdFx0XHRcdFx0djJ5IC09IHZ5O1xuXHRcdFx0XHRcdGNjdyA9IHYyeCAqIHZ4ICsgdjJ5ICogdnk7XG5cdFx0XHRcdFx0aWYgKGNjdyA8IDApXG5cdFx0XHRcdFx0XHRjY3cgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2N3IDwgMCA/IC0xIDogY2N3ID4gMCA/IDEgOiAwO1xuXHRcdH0sXG5cblx0XHRnZXRTaWduZWREaXN0YW5jZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHZ4IC09IHB4O1xuXHRcdFx0XHR2eSAtPSBweTtcblx0XHRcdH1cblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHZ4KSlcblx0XHRcdFx0cmV0dXJuIHggLSBweDtcblx0XHRcdHZhciBtID0gdnkgLyB2eCxcblx0XHRcdFx0YiA9IHB5IC0gbSAqIHB4O1xuXHRcdFx0cmV0dXJuICh5IC0gKG0gKiB4KSAtIGIpIC8gTWF0aC5zcXJ0KG0gKiBtICsgMSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFByb2plY3QgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQcm9qZWN0Jyxcblx0X2xpc3Q6ICdwcm9qZWN0cycsXG5cdF9yZWZlcmVuY2U6ICdwcm9qZWN0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQcm9qZWN0KGVsZW1lbnQpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdHRoaXMubGF5ZXJzID0gW107XG5cdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcblx0XHR0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcyxcblx0XHRcdFx0ZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuXHRcdHRoaXMuX3NlbGVjdGVkSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmxheWVycywgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMubGF5ZXJzW2ldLnJlbW92ZSgpO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxheWVycy5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0aWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0aGlzLl92aWV3KVxuXHRcdFx0dGhpcy5fdmlldy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlldztcblx0fSxcblxuXHRnZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG5cdH0sXG5cblx0c2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZS5pbml0aWFsaXplKHN0eWxlKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcblx0fSxcblxuXHRnZXRBY3RpdmVMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcih7IHByb2plY3Q6IHRoaXMgfSk7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fc2VsZWN0ZWRJdGVtcykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHRcdGlmIChpdGVtLmlzSW5zZXJ0ZWQoKSlcblx0XHRcdFx0aXRlbXMucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdGFkZENoaWxkOiBmdW5jdGlvbihjaGlsZCkge1xuXHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIExheWVyKSB7XG5cdFx0XHRCYXNlLnNwbGljZSh0aGlzLmxheWVycywgW2NoaWxkXSk7XG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZUxheWVyKVxuXHRcdFx0XHR0aGlzLl9hY3RpdmVMYXllciA9IGNoaWxkO1xuXHRcdH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBJdGVtKSB7XG5cdFx0XHQodGhpcy5fYWN0aXZlTGF5ZXJcblx0XHRcdFx0fHwgdGhpcy5hZGRDaGlsZChuZXcgTGF5ZXIoSXRlbS5OT19JTlNFUlQpKSkuYWRkQ2hpbGQoY2hpbGQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBjaGlsZDtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRpZiAoaXRlbS5fc2VsZWN0ZWQpIHtcblx0XHRcdGlmIChzZWxlY3RlZEl0ZW1zW2lkXSAhPT0gaXRlbSkge1xuXHRcdFx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCsrO1xuXHRcdFx0XHRzZWxlY3RlZEl0ZW1zW2lkXSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzZWxlY3RlZEl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQtLTtcblx0XHRcdGRlbGV0ZSBzZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0c2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZGVzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRmb3IgKHZhciBpIGluIHNlbGVjdGVkSXRlbXMpXG5cdFx0XHRzZWxlY3RlZEl0ZW1zW2ldLnNldEZ1bGx5U2VsZWN0ZWQoZmFsc2UpO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdG9wdGlvbnMgPSBIaXRSZXN1bHQuZ2V0T3B0aW9ucyhCYXNlLnJlYWQoYXJndW1lbnRzKSk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcmVzID0gdGhpcy5sYXllcnNbaV0uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHJlcykgcmV0dXJuIHJlcztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoLCBudWxsLCBudWxsLCB0cnVlKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5fYWN0aXZlTGF5ZXI7XG5cdFx0cmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCBsYXllciAmJiBsYXllci5pc0VtcHR5KCkgJiYgbGF5ZXIpO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBwaXhlbFJhdGlvKSB7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbisrO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dmFyIHBhcmFtID0gbmV3IEJhc2Uoe1xuXHRcdFx0b2Zmc2V0OiBuZXcgUG9pbnQoMCwgMCksXG5cdFx0XHRwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuXHRcdFx0dmlld01hdHJpeDogbWF0cml4LmlzSWRlbnRpdHkoKSA/IG51bGwgOiBtYXRyaXgsXG5cdFx0XHRtYXRyaWNlczogW25ldyBNYXRyaXgoKV0sXG5cdFx0XHR1cGRhdGVNYXRyaXg6IHRydWVcblx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGF5ZXJzID0gdGhpcy5sYXllcnMsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblxuXHRcdGlmICh0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA+IDApIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc3Ryb2tlV2lkdGggPSAxO1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcyxcblx0XHRcdFx0c2l6ZSA9IHRoaXMuX3Njb3BlLnNldHRpbmdzLmhhbmRsZVNpemUsXG5cdFx0XHRcdHZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uO1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gaXRlbXMpXG5cdFx0XHRcdGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU3ltYm9sID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTeW1ib2wnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbChpdGVtLCBkb250Q2VudGVyKSB7XG5cdFx0dGhpcy5faWQgPSBTeW1ib2wuX2lkID0gKFN5bWJvbC5faWQgfHwgMCkgKyAxO1xuXHRcdHRoaXMucHJvamVjdCA9IHBhcGVyLnByb2plY3Q7XG5cdFx0dGhpcy5wcm9qZWN0LnN5bWJvbHMucHVzaCh0aGlzKTtcblx0XHRpZiAoaXRlbSlcblx0XHRcdHRoaXMuc2V0RGVmaW5pdGlvbihpdGVtLCBkb250Q2VudGVyKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jbGFzcywgdGhpcy5fZGVmaW5pdGlvbl0sXG5cdFx0XHRcdFx0b3B0aW9ucywgZmFsc2UsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdHRoaXMucHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRnZXREZWZpbml0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcblx0fSxcblxuXHRzZXREZWZpbml0aW9uOiBmdW5jdGlvbihpdGVtLCBfZG9udENlbnRlcikge1xuXHRcdGlmIChpdGVtLl9wYXJlbnRTeW1ib2wpXG5cdFx0XHRpdGVtID0gaXRlbS5jbG9uZSgpO1xuXHRcdGlmICh0aGlzLl9kZWZpbml0aW9uKVxuXHRcdFx0dGhpcy5fZGVmaW5pdGlvbi5fcGFyZW50U3ltYm9sID0gbnVsbDtcblx0XHR0aGlzLl9kZWZpbml0aW9uID0gaXRlbTtcblx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdGl0ZW0uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuXHRcdGlmICghX2RvbnRDZW50ZXIpXG5cdFx0XHRpdGVtLnNldFBvc2l0aW9uKG5ldyBQb2ludCgpKTtcblx0XHRpdGVtLl9wYXJlbnRTeW1ib2wgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0cGxhY2U6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIG5ldyBQbGFjZWRTeW1ib2wodGhpcywgcG9zaXRpb24pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbCh0aGlzLl9kZWZpbml0aW9uLmNsb25lKGZhbHNlKSk7XG5cdH1cbn0pO1xuXG52YXIgSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblx0c3RhdGljczoge1xuXHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHNyYykge1xuXHRcdFx0aWYgKHNyYy5fc2VyaWFsaXplRmllbGRzKVxuXHRcdFx0XHRzcmMuX3NlcmlhbGl6ZUZpZWxkcyA9IG5ldyBCYXNlKFxuXHRcdFx0XHRcdFx0dGhpcy5wcm90b3R5cGUuX3NlcmlhbGl6ZUZpZWxkcywgc3JjLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdFx0cmV0dXJuIGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdE5PX0lOU0VSVDogeyBpbnNlcnQ6IGZhbHNlIH1cblx0fSxcblxuXHRfY2xhc3M6ICdJdGVtJyxcblx0X2FwcGx5TWF0cml4OiB0cnVlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IHRydWUsXG5cdF9ib3VuZHNTZWxlY3RlZDogZmFsc2UsXG5cdF9zZWxlY3RDaGlsZHJlbjogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRuYW1lOiBudWxsLFxuXHRcdGFwcGx5TWF0cml4OiBudWxsLFxuXHRcdG1hdHJpeDogbmV3IE1hdHJpeCgpLFxuXHRcdHBpdm90OiBudWxsLFxuXHRcdGxvY2tlZDogZmFsc2UsXG5cdFx0dmlzaWJsZTogdHJ1ZSxcblx0XHRibGVuZE1vZGU6ICdub3JtYWwnLFxuXHRcdG9wYWNpdHk6IDEsXG5cdFx0Z3VpZGU6IGZhbHNlLFxuXHRcdHNlbGVjdGVkOiBmYWxzZSxcblx0XHRjbGlwTWFzazogZmFsc2UsXG5cdFx0ZGF0YToge31cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBJdGVtKCkge1xuXHR9LFxuXG5cdF9pbml0aWFsaXplOiBmdW5jdGlvbihwcm9wcywgcG9pbnQpIHtcblx0XHR2YXIgaGFzUHJvcHMgPSBwcm9wcyAmJiBCYXNlLmlzUGxhaW5PYmplY3QocHJvcHMpLFxuXHRcdFx0aW50ZXJuYWwgPSBoYXNQcm9wcyAmJiBwcm9wcy5pbnRlcm5hbCA9PT0gdHJ1ZSxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdHByb2plY3QgPSBoYXNQcm9wcyAmJiBwcm9wcy5wcm9qZWN0IHx8IHBhcGVyLnByb2plY3Q7XG5cdFx0aWYgKCFpbnRlcm5hbClcblx0XHRcdHRoaXMuX2lkID0gSXRlbS5faWQgPSAoSXRlbS5faWQgfHwgMCkgKyAxO1xuXHRcdHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgcGFwZXIuc2V0dGluZ3MuYXBwbHlNYXRyaXg7XG5cdFx0aWYgKHBvaW50KVxuXHRcdFx0bWF0cml4LnRyYW5zbGF0ZShwb2ludCk7XG5cdFx0bWF0cml4Ll9vd25lciA9IHRoaXM7XG5cdFx0dGhpcy5fc3R5bGUgPSBuZXcgU3R5bGUocHJvamVjdC5fY3VycmVudFN0eWxlLCB0aGlzLCBwcm9qZWN0KTtcblx0XHRpZiAoIXRoaXMuX3Byb2plY3QpIHtcblx0XHRcdGlmIChpbnRlcm5hbCB8fCBoYXNQcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX3NldFByb2plY3QocHJvamVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGhhc1Byb3BzICYmIHByb3BzLnBhcmVudCkge1xuXHRcdFx0XHR0aGlzLnNldFBhcmVudChwcm9wcy5wYXJlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0KHByb2plY3QuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcigpKS5hZGRDaGlsZCh0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGhhc1Byb3BzICYmIHByb3BzICE9PSBJdGVtLk5PX0lOU0VSVClcblx0XHRcdHRoaXMuX3NldChwcm9wcywgeyBpbnNlcnQ6IHRydWUsIHBhcmVudDogdHJ1ZSB9LCB0cnVlKTtcblx0XHRyZXR1cm4gaGFzUHJvcHM7XG5cdH0sXG5cblx0X2V2ZW50czogbmV3IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG1vdXNlRmxhZ3MgPSB7XG5cdFx0XHRtb3VzZWRvd246IHtcblx0XHRcdFx0bW91c2Vkb3duOiAxLFxuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0XHRkb3VibGVjbGljazogMVxuXHRcdFx0fSxcblx0XHRcdG1vdXNldXA6IHtcblx0XHRcdFx0bW91c2V1cDogMSxcblx0XHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0XHRjbGljazogMSxcblx0XHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHRcdH0sXG5cdFx0XHRtb3VzZW1vdmU6IHtcblx0XHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0XHRtb3VzZW1vdmU6IDEsXG5cdFx0XHRcdG1vdXNlZW50ZXI6IDEsXG5cdFx0XHRcdG1vdXNlbGVhdmU6IDFcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIG1vdXNlRXZlbnQgPSB7XG5cdFx0XHRpbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHZhciBjb3VudGVycyA9IHRoaXMuZ2V0VmlldygpLl9ldmVudENvdW50ZXJzO1xuXHRcdFx0XHRpZiAoY291bnRlcnMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbW91c2VGbGFncykge1xuXHRcdFx0XHRcdFx0Y291bnRlcnNba2V5XSA9IChjb3VudGVyc1trZXldIHx8IDApXG5cdFx0XHRcdFx0XHRcdFx0KyAobW91c2VGbGFnc1trZXldW3R5cGVdIHx8IDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHR2YXIgY291bnRlcnMgPSB0aGlzLmdldFZpZXcoKS5fZXZlbnRDb3VudGVycztcblx0XHRcdFx0aWYgKGNvdW50ZXJzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG1vdXNlRmxhZ3MpXG5cdFx0XHRcdFx0XHRjb3VudGVyc1trZXldIC09IG1vdXNlRmxhZ3Nba2V5XVt0eXBlXSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBCYXNlLmVhY2goWydvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25DbGljaycsXG5cdFx0XHQnb25Eb3VibGVDbGljaycsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlRW50ZXInLCAnb25Nb3VzZUxlYXZlJ10sXG5cdFx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHRoaXNbbmFtZV0gPSBtb3VzZUV2ZW50O1xuXHRcdFx0fSwge1xuXHRcdFx0XHRvbkZyYW1lOiB7XG5cdFx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRlSXRlbSh0cnVlKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRlSXRlbShmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uTG9hZDoge31cblx0XHRcdH1cblx0XHQpO1xuXHR9LFxuXG5cdF9hbmltYXRlSXRlbTogZnVuY3Rpb24oYW5pbWF0ZSkge1xuXHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCBhbmltYXRlKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0dmFyIHByb3BzID0ge30sXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBmaWVsZHMpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhhdFtrZXldO1xuXHRcdFx0XHRpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBrZXkgPT09ICdsZWFkaW5nJ1xuXHRcdFx0XHRcdFx0PyBmaWVsZHMuZm9udFNpemUgKiAxLjIgOiBmaWVsZHNba2V5XSkpIHtcblx0XHRcdFx0XHRwcm9wc1trZXldID0gQmFzZS5zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMsXG5cdFx0XHRcdFx0XHRcdGtleSAhPT0gJ2RhdGEnLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlcmlhbGl6ZSh0aGlzLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRzZXJpYWxpemUodGhpcy5fc3R5bGUuX2RlZmF1bHRzKTtcblx0XHRyZXR1cm4gWyB0aGlzLl9jbGFzcywgcHJvcHMgXTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHR2YXIgc3ltYm9sID0gdGhpcy5fcGFyZW50U3ltYm9sLFxuXHRcdFx0Y2FjaGVQYXJlbnQgPSB0aGlzLl9wYXJlbnQgfHwgc3ltYm9sLFxuXHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2VkID1cblx0XHRcdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKGNhY2hlUGFyZW50XG5cdFx0XHRcdCYmIChmbGFncyAmIDQwKSkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShjYWNoZVBhcmVudCk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDIpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChwcm9qZWN0KSB7XG5cdFx0XHRpZiAoZmxhZ3MgJiAxKSB7XG5cdFx0XHRcdHByb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9qZWN0Ll9jaGFuZ2VzKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IHByb2plY3QuX2NoYW5nZXNCeUlkW3RoaXMuX2lkXTtcblx0XHRcdFx0aWYgKGVudHJ5KSB7XG5cdFx0XHRcdFx0ZW50cnkuZmxhZ3MgfD0gZmxhZ3M7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW50cnkgPSB7IGl0ZW06IHRoaXMsIGZsYWdzOiBmbGFncyB9O1xuXHRcdFx0XHRcdHByb2plY3QuX2NoYW5nZXNCeUlkW3RoaXMuX2lkXSA9IGVudHJ5O1xuXHRcdFx0XHRcdHByb2plY3QuX2NoYW5nZXMucHVzaChlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN5bWJvbClcblx0XHRcdHN5bWJvbC5fY2hhbmdlZChmbGFncyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihwcm9wcykge1xuXHRcdGlmIChwcm9wcylcblx0XHRcdHRoaXMuX3NldChwcm9wcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0SWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fSxcblxuXHRnZXROYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0fSxcblxuXHRzZXROYW1lOiBmdW5jdGlvbihuYW1lLCB1bmlxdWUpIHtcblxuXHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0dGhpcy5fcmVtb3ZlTmFtZWQoKTtcblx0XHRpZiAobmFtZSA9PT0gKCtuYW1lKSArICcnKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdOYW1lcyBjb25zaXN0aW5nIG9ubHkgb2YgbnVtYmVycyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChuYW1lICYmIHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHBhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0b3JpZyA9IG5hbWUsXG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0d2hpbGUgKHVuaXF1ZSAmJiBjaGlsZHJlbltuYW1lXSlcblx0XHRcdFx0bmFtZSA9IG9yaWcgKyAnICcgKyAoaSsrKTtcblx0XHRcdChuYW1lZENoaWxkcmVuW25hbWVdID0gbmFtZWRDaGlsZHJlbltuYW1lXSB8fCBbXSkucHVzaCh0aGlzKTtcblx0XHRcdGNoaWxkcmVuW25hbWVdID0gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NoYW5nZWQoMTI4KTtcblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuXHR9XG59LCBCYXNlLmVhY2goWydsb2NrZWQnLCAndmlzaWJsZScsICdibGVuZE1vZGUnLCAnb3BhY2l0eScsICdndWlkZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRuYW1lID0gJ18nICsgbmFtZTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdH07XG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzW25hbWVdKSB7XG5cdFx0XHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZChuYW1lID09PSAnX2xvY2tlZCdcblx0XHRcdFx0XHRcdD8gMTI4IDogMTI5KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxue30pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9sb2NrZWQ6IGZhbHNlLFxuXG5cdF92aXNpYmxlOiB0cnVlLFxuXG5cdF9ibGVuZE1vZGU6ICdub3JtYWwnLFxuXG5cdF9vcGFjaXR5OiAxLFxuXG5cdF9ndWlkZTogZmFsc2UsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBub0NoaWxkcmVuKSB7XG5cdFx0aWYgKCFub0NoaWxkcmVuICYmIHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdGlmICgoc2VsZWN0ZWQgPSAhIXNlbGVjdGVkKSBeIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0dGhpcy5fcHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMjkpO1xuXHRcdH1cblx0fSxcblxuXHRfc2VsZWN0ZWQ6IGZhbHNlLFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRydWUpO1xuXHR9LFxuXG5cdGlzQ2xpcE1hc2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGlwTWFzaztcblx0fSxcblxuXHRzZXRDbGlwTWFzazogZnVuY3Rpb24oY2xpcE1hc2spIHtcblx0XHRpZiAodGhpcy5fY2xpcE1hc2sgIT0gKGNsaXBNYXNrID0gISFjbGlwTWFzaykpIHtcblx0XHRcdHRoaXMuX2NsaXBNYXNrID0gY2xpcE1hc2s7XG5cdFx0XHRpZiAoY2xpcE1hc2spIHtcblx0XHRcdFx0dGhpcy5zZXRGaWxsQ29sb3IobnVsbCk7XG5cdFx0XHRcdHRoaXMuc2V0U3Ryb2tlQ29sb3IobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0XHRpZiAodGhpcy5fcGFyZW50KVxuXHRcdFx0XHR0aGlzLl9wYXJlbnQuX2NoYW5nZWQoMTAyNCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jbGlwTWFzazogZmFsc2UsXG5cblx0Z2V0RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9kYXRhKVxuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9LFxuXG5cdHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24sXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRpZiAoIXBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gPSBwaXZvdFxuXHRcdFx0XHRcdD8gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IGN0b3IocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdGhpcywgJ3NldFBvc2l0aW9uJyk7XG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5zdWJ0cmFjdCh0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH0sXG5cblx0Z2V0UGl2b3Q6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdGlmIChwaXZvdCkge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cGl2b3QgPSBuZXcgY3RvcihwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0UGl2b3QnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBpdm90O1xuXHR9LFxuXG5cdHNldFBpdm90OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9waXZvdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcGl2b3Q6IG51bGwsXG5cblx0Z2V0UmVnaXN0cmF0aW9uOiAnI2dldFBpdm90Jyxcblx0c2V0UmVnaXN0cmF0aW9uOiAnI3NldFBpdm90J1xufSwgQmFzZS5lYWNoKFsnYm91bmRzJywgJ3N0cm9rZUJvdW5kcycsICdoYW5kbGVCb3VuZHMnLCAncm91Z2hCb3VuZHMnLFxuXHRcdCdpbnRlcm5hbEJvdW5kcycsICdpbnRlcm5hbFJvdWdoQm91bmRzJ10sXG5cdGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBnZXR0ZXIgPSAnZ2V0JyArIEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0bWF0Y2ggPSBrZXkubWF0Y2goL15pbnRlcm5hbCguKikkLyksXG5cdFx0XHRpbnRlcm5hbEdldHRlciA9IG1hdGNoID8gJ2dldCcgKyBtYXRjaFsxXSA6IG51bGw7XG5cdFx0dGhpc1tnZXR0ZXJdID0gZnVuY3Rpb24oX21hdHJpeCkge1xuXHRcdFx0dmFyIGJvdW5kc0dldHRlciA9IHRoaXMuX2JvdW5kc0dldHRlcixcblx0XHRcdFx0bmFtZSA9ICFpbnRlcm5hbEdldHRlciAmJiAodHlwZW9mIGJvdW5kc0dldHRlciA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHRcdD8gYm91bmRzR2V0dGVyIDogYm91bmRzR2V0dGVyICYmIGJvdW5kc0dldHRlcltnZXR0ZXJdKVxuXHRcdFx0XHRcdFx0fHwgZ2V0dGVyLFxuXHRcdFx0XHRib3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHMobmFtZSwgX21hdHJpeCwgdGhpcyxcblx0XHRcdFx0XHRcdGludGVybmFsR2V0dGVyKTtcblx0XHRcdHJldHVybiBrZXkgPT09ICdib3VuZHMnXG5cdFx0XHRcdFx0PyBuZXcgTGlua2VkUmVjdGFuZ2xlKGJvdW5kcy54LCBib3VuZHMueSwgYm91bmRzLndpZHRoLFxuXHRcdFx0XHRcdFx0XHRib3VuZHMuaGVpZ2h0LCB0aGlzLCAnc2V0Qm91bmRzJylcblx0XHRcdFx0XHQ6IGJvdW5kcztcblx0XHR9O1xuXHR9LFxue1xuXHRiZWFuczogdHJ1ZSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5sZW5ndGggPT0gMClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0dmFyIHgxID0gSW5maW5pdHksXG5cdFx0XHR4MiA9IC14MSxcblx0XHRcdHkxID0geDEsXG5cdFx0XHR5MiA9IHgyO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZC5fdmlzaWJsZSAmJiAhY2hpbGQuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdHZhciByZWN0ID0gY2hpbGQuX2dldENhY2hlZEJvdW5kcyhnZXR0ZXIsXG5cdFx0XHRcdFx0XHRtYXRyaXggJiYgbWF0cml4LmNoYWluKGNoaWxkLl9tYXRyaXgpLCBjYWNoZUl0ZW0pO1xuXHRcdFx0XHR4MSA9IE1hdGgubWluKHJlY3QueCwgeDEpO1xuXHRcdFx0XHR5MSA9IE1hdGgubWluKHJlY3QueSwgeTEpO1xuXHRcdFx0XHR4MiA9IE1hdGgubWF4KHJlY3QueCArIHJlY3Qud2lkdGgsIHgyKTtcblx0XHRcdFx0eTIgPSBNYXRoLm1heChyZWN0LnkgKyByZWN0LmhlaWdodCwgeTIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaXNGaW5pdGUoeDEpXG5cdFx0XHRcdD8gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpXG5cdFx0XHRcdDogbmV3IFJlY3RhbmdsZSgpO1xuXHR9LFxuXG5cdHNldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKCk7XG5cdFx0bWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdGlmIChyZWN0LndpZHRoICE9IGJvdW5kcy53aWR0aCB8fCByZWN0LmhlaWdodCAhPSBib3VuZHMuaGVpZ2h0KSB7XG5cdFx0XHRtYXRyaXguc2NhbGUoXG5cdFx0XHRcdFx0Ym91bmRzLndpZHRoICE9IDAgPyByZWN0LndpZHRoIC8gYm91bmRzLndpZHRoIDogMSxcblx0XHRcdFx0XHRib3VuZHMuaGVpZ2h0ICE9IDAgPyByZWN0LmhlaWdodCAvIGJvdW5kcy5oZWlnaHQgOiAxKTtcblx0XHR9XG5cdFx0Y2VudGVyID0gYm91bmRzLmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoLWNlbnRlci54LCAtY2VudGVyLnkpO1xuXHRcdHRoaXMudHJhbnNmb3JtKG1hdHJpeCk7XG5cdH0sXG5cblx0X2dldENhY2hlZEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSwgaW50ZXJuYWxHZXR0ZXIpIHtcblx0XHRtYXRyaXggPSBtYXRyaXggJiYgbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKTtcblx0XHR2YXIgX21hdHJpeCA9IGludGVybmFsR2V0dGVyID8gbnVsbCA6IHRoaXMuX21hdHJpeC5vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRjYWNoZSA9ICghbWF0cml4IHx8IG1hdHJpeC5lcXVhbHMoX21hdHJpeCkpICYmIGdldHRlcjtcblx0XHR2YXIgY2FjaGVQYXJlbnQgPSB0aGlzLl9wYXJlbnQgfHwgdGhpcy5fcGFyZW50U3ltYm9sO1xuXHRcdGlmIChjYWNoZVBhcmVudCkge1xuXHRcdFx0dmFyIGlkID0gY2FjaGVJdGVtLl9pZCxcblx0XHRcdFx0cmVmID0gY2FjaGVQYXJlbnQuX2JvdW5kc0NhY2hlID0gY2FjaGVQYXJlbnQuX2JvdW5kc0NhY2hlIHx8IHtcblx0XHRcdFx0XHRpZHM6IHt9LFxuXHRcdFx0XHRcdGxpc3Q6IFtdXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAoIXJlZi5pZHNbaWRdKSB7XG5cdFx0XHRcdHJlZi5saXN0LnB1c2goY2FjaGVJdGVtKTtcblx0XHRcdFx0cmVmLmlkc1tpZF0gPSBjYWNoZUl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjYWNoZSAmJiB0aGlzLl9ib3VuZHMgJiYgdGhpcy5fYm91bmRzW2NhY2hlXSlcblx0XHRcdHJldHVybiB0aGlzLl9ib3VuZHNbY2FjaGVdLmNsb25lKCk7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dldEJvdW5kcyhpbnRlcm5hbEdldHRlciB8fCBnZXR0ZXIsXG5cdFx0XHRcdG1hdHJpeCB8fCBfbWF0cml4LCBjYWNoZUl0ZW0pO1xuXHRcdGlmIChjYWNoZSkge1xuXHRcdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHRcdHRoaXMuX2JvdW5kcyA9IHt9O1xuXHRcdFx0dmFyIGNhY2hlZCA9IHRoaXMuX2JvdW5kc1tjYWNoZV0gPSBib3VuZHMuY2xvbmUoKTtcblx0XHRcdGNhY2hlZC5faW50ZXJuYWwgPSAhIWludGVybmFsR2V0dGVyO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRfY2xlYXJCb3VuZHNDYWNoZTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0dmFyIGNhY2hlID0gaXRlbS5fYm91bmRzQ2FjaGU7XG5cdFx0XHRpZiAoY2FjaGUpIHtcblx0XHRcdFx0aXRlbS5fYm91bmRzID0gaXRlbS5fcG9zaXRpb24gPSBpdGVtLl9ib3VuZHNDYWNoZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxpc3QgPSBjYWNoZS5saXN0LCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgb3RoZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRcdGlmIChvdGhlciAhPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0b3RoZXIuX2JvdW5kcyA9IG90aGVyLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmIChvdGhlci5fYm91bmRzQ2FjaGUpXG5cdFx0XHRcdFx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUob3RoZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59KSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRfZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVjb21wb3NlZCA9IHRoaXMuX21hdHJpeC5kZWNvbXBvc2UoKTtcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkIHx8IHRoaXMuX2RlY29tcG9zZSgpO1xuXHRcdHJldHVybiBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQucm90YXRpb247XG5cdH0sXG5cblx0c2V0Um90YXRpb246IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFJvdGF0aW9uKCk7XG5cdFx0aWYgKGN1cnJlbnQgIT0gbnVsbCAmJiByb3RhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG5cdFx0XHR0aGlzLnJvdGF0ZShyb3RhdGlvbiAtIGN1cnJlbnQpO1xuXHRcdFx0ZGVjb21wb3NlZC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFNjYWxpbmc6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCB8fCB0aGlzLl9kZWNvbXBvc2UoKSxcblx0XHRcdHNjYWxpbmcgPSBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQuc2NhbGluZyxcblx0XHRcdGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHJldHVybiBzY2FsaW5nICYmIG5ldyBjdG9yKHNjYWxpbmcueCwgc2NhbGluZy55LCB0aGlzLCAnc2V0U2NhbGluZycpO1xuXHR9LFxuXG5cdHNldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRTY2FsaW5nKCk7XG5cdFx0aWYgKGN1cnJlbnQpIHtcblx0XHRcdHZhciBzY2FsaW5nID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUgfSksXG5cdFx0XHRcdGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5zY2FsZShzY2FsaW5nLnggLyBjdXJyZW50LngsIHNjYWxpbmcueSAvIGN1cnJlbnQueSk7XG5cdFx0XHRkZWNvbXBvc2VkLnNjYWxpbmcgPSBzY2FsaW5nO1xuXHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fSxcblxuXHRzZXRNYXRyaXg6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHRoaXMuX21hdHJpeC5pbml0aWFsaXplKG1hdHJpeCk7XG5cdFx0aWYgKHRoaXMuX2FwcGx5TWF0cml4KSB7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0R2xvYmFsTWF0cml4OiBmdW5jdGlvbihfZG9udENsb25lKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCxcblx0XHRcdHVwZGF0ZVZlcnNpb24gPSB0aGlzLl9wcm9qZWN0Ll91cGRhdGVWZXJzaW9uO1xuXHRcdGlmIChtYXRyaXggJiYgbWF0cml4Ll91cGRhdGVWZXJzaW9uICE9PSB1cGRhdGVWZXJzaW9uKVxuXHRcdFx0bWF0cml4ID0gbnVsbDtcblx0XHRpZiAoIW1hdHJpeCkge1xuXHRcdFx0bWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0bWF0cml4LnByZUNvbmNhdGVuYXRlKHBhcmVudC5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpO1xuXHRcdFx0bWF0cml4Ll91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcblx0XHR9XG5cdFx0cmV0dXJuIF9kb250Q2xvbmUgPyBtYXRyaXggOiBtYXRyaXguY2xvbmUoKTtcblx0fSxcblxuXHRnZXRBcHBseU1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcGx5TWF0cml4O1xuXHR9LFxuXG5cdHNldEFwcGx5TWF0cml4OiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiAhIXRyYW5zZm9ybSlcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHR9LFxuXG5cdGdldFRyYW5zZm9ybUNvbnRlbnQ6ICcjZ2V0QXBwbHlNYXRyaXgnLFxuXHRzZXRUcmFuc2Zvcm1Db250ZW50OiAnI3NldEFwcGx5TWF0cml4Jyxcbn0sIHtcblx0Z2V0UHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Q7XG5cdH0sXG5cblx0X3NldFByb2plY3Q6IGZ1bmN0aW9uKHByb2plY3QsIGluc3RhbGxFdmVudHMpIHtcblx0XHRpZiAodGhpcy5fcHJvamVjdCAhPT0gcHJvamVjdCkge1xuXHRcdFx0aWYgKHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0dGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdGluc3RhbGxFdmVudHMgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFsbEV2ZW50cylcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHModHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiBfaW5zdGFsbEV2ZW50cyhpbnN0YWxsKSB7XG5cdFx0X2luc3RhbGxFdmVudHMuYmFzZS5jYWxsKHRoaXMsIGluc3RhbGwpO1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uX2luc3RhbGxFdmVudHMoaW5zdGFsbCk7XG5cdH0sXG5cblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIExheWVyKVxuXHRcdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQ7XG5cdH0sXG5cblx0c2V0UGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uYWRkQ2hpbGQodGhpcyk7XG5cdH0sXG5cblx0Z2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcblx0fSxcblxuXHRzZXRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0dGhpcy5hZGRDaGlsZHJlbihpdGVtcyk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TGFzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblx0XHRcdFx0fHwgbnVsbDtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50Ll9jaGlsZHJlblt0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA9PT0gdGhpcyB8fCBpdGVtICYmIHRoaXMuX2NsYXNzID09PSBpdGVtLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdHlsZS5lcXVhbHMoaXRlbS5fc3R5bGUpXG5cdFx0XHRcdCYmIHRoaXMuX21hdHJpeC5lcXVhbHMoaXRlbS5fbWF0cml4KVxuXHRcdFx0XHQmJiB0aGlzLl9sb2NrZWQgPT09IGl0ZW0uX2xvY2tlZFxuXHRcdFx0XHQmJiB0aGlzLl92aXNpYmxlID09PSBpdGVtLl92aXNpYmxlXG5cdFx0XHRcdCYmIHRoaXMuX2JsZW5kTW9kZSA9PT0gaXRlbS5fYmxlbmRNb2RlXG5cdFx0XHRcdCYmIHRoaXMuX29wYWNpdHkgPT09IGl0ZW0uX29wYWNpdHlcblx0XHRcdFx0JiYgdGhpcy5fY2xpcE1hc2sgPT09IGl0ZW0uX2NsaXBNYXNrXG5cdFx0XHRcdCYmIHRoaXMuX2d1aWRlID09PSBpdGVtLl9ndWlkZVxuXHRcdFx0XHQmJiB0aGlzLl9lcXVhbHMoaXRlbSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBCYXNlLmVxdWFscyh0aGlzLl9jaGlsZHJlbiwgaXRlbS5fY2hpbGRyZW4pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUobmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuXHR9LFxuXG5cdF9jbG9uZTogZnVuY3Rpb24oY29weSwgaW5zZXJ0KSB7XG5cdFx0Y29weS5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y29weS5hZGRDaGlsZCh0aGlzLl9jaGlsZHJlbltpXS5jbG9uZShmYWxzZSksIHRydWUpO1xuXHRcdH1cblx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0Y29weS5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHR2YXIga2V5cyA9IFsnX2xvY2tlZCcsICdfdmlzaWJsZScsICdfYmxlbmRNb2RlJywgJ19vcGFjaXR5Jyxcblx0XHRcdFx0J19jbGlwTWFzaycsICdfZ3VpZGUnLCAnX2FwcGx5TWF0cml4J107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuXHRcdFx0XHRjb3B5W2tleV0gPSB0aGlzW2tleV07XG5cdFx0fVxuXHRcdGNvcHkuX21hdHJpeC5pbml0aWFsaXplKHRoaXMuX21hdHJpeCk7XG5cdFx0Y29weS5fZGF0YSA9IHRoaXMuX2RhdGEgPyBCYXNlLmNsb25lKHRoaXMuX2RhdGEpIDogbnVsbDtcblx0XHRjb3B5LnNldFNlbGVjdGVkKHRoaXMuX3NlbGVjdGVkKTtcblx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdGNvcHkuc2V0TmFtZSh0aGlzLl9uYW1lLCB0cnVlKTtcblx0XHRyZXR1cm4gY29weTtcblx0fSxcblxuXHRjb3B5VG86IGZ1bmN0aW9uKGl0ZW1PclByb2plY3QpIHtcblx0XHRyZXR1cm4gaXRlbU9yUHJvamVjdC5hZGRDaGlsZCh0aGlzLmNsb25lKGZhbHNlKSk7XG5cdH0sXG5cblx0cmFzdGVyaXplOiBmdW5jdGlvbihyZXNvbHV0aW9uKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKCksXG5cdFx0XHRzY2FsZSA9IChyZXNvbHV0aW9uIHx8IHRoaXMuZ2V0VmlldygpLmdldFJlc29sdXRpb24oKSkgLyA3Mixcblx0XHRcdHRvcExlZnQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCksXG5cdFx0XHRib3R0b21SaWdodCA9IGJvdW5kcy5nZXRCb3R0b21SaWdodCgpLmNlaWwoKSxcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShib3R0b21SaWdodC5zdWJ0cmFjdCh0b3BMZWZ0KSksXG5cdFx0XHRjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZS5tdWx0aXBseShzY2FsZSkpLFxuXHRcdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUoc2NhbGUpLnRyYW5zbGF0ZSh0b3BMZWZ0Lm5lZ2F0ZSgpKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHRoaXMuZHJhdyhjdHgsIG5ldyBCYXNlKHsgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHZhciByYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyYXN0ZXIuc2V0Q2FudmFzKGNhbnZhcyk7XG5cdFx0cmFzdGVyLnRyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKHRvcExlZnQuYWRkKHNpemUuZGl2aWRlKDIpKSlcblx0XHRcdFx0LnNjYWxlKDEgLyBzY2FsZSkpO1xuXHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9jb250YWlucyhcblx0XHRcdFx0dGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHR9LFxuXG5cdF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAodGhpcy5fY2hpbGRyZW5baV0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnQuaXNJbnNpZGUodGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0fSxcblxuXHRpc0luc2lkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcy5nZXRCb3VuZHMoKSk7XG5cdH0sXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuXHRcdFx0cmVjdGFuZ2xlOiB0aGlzLmdldEludGVybmFsQm91bmRzKCksXG5cdFx0XHRtYXRyaXg6IHRoaXMuX21hdHJpeCxcblx0XHRcdGluc2VydDogZmFsc2UsXG5cdFx0fSk7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oaXRlbSwgX21hdHJpeCkge1xuXHRcdGlmICghKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcy5fYXNQYXRoSXRlbSgpLmdldEludGVyc2VjdGlvbnMoaXRlbS5fYXNQYXRoSXRlbSgpLFxuXHRcdFx0XHRfbWF0cml4IHx8IGl0ZW0uX21hdHJpeCkubGVuZ3RoID4gMDtcblx0fSxcblxuXHRoaXRUZXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGl0VGVzdChcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRIaXRSZXN1bHQuZ2V0T3B0aW9ucyhCYXNlLnJlYWQoYXJndW1lbnRzKSkpO1xuXHR9LFxuXG5cdF9oaXRUZXN0OiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdGlmICh0aGlzLl9sb2NrZWQgfHwgIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fZ3VpZGUgJiYgIW9wdGlvbnMuZ3VpZGVzXG5cdFx0XHRcdHx8IHRoaXMuaXNFbXB0eSgpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0cGFyZW50VG90YWxNYXRyaXggPSBvcHRpb25zLl90b3RhbE1hdHJpeCxcblx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdHRvdGFsTWF0cml4ID0gb3B0aW9ucy5fdG90YWxNYXRyaXggPSBwYXJlbnRUb3RhbE1hdHJpeFxuXHRcdFx0XHRcdD8gcGFyZW50VG90YWxNYXRyaXguY2hhaW4obWF0cml4KVxuXHRcdFx0XHRcdDogdGhpcy5nZXRHbG9iYWxNYXRyaXgoKS5wcmVDb25jYXRlbmF0ZSh2aWV3Ll9tYXRyaXgpLFxuXHRcdFx0dG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcgPSBuZXcgU2l6ZShcblx0XHRcdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoMSwgdG90YWxNYXRyaXguaW52ZXJ0ZWQoKSlcblx0XHRcdFx0XHQpLm11bHRpcGx5KFxuXHRcdFx0XHRcdFx0TWF0aC5tYXgob3B0aW9ucy50b2xlcmFuY2UsIDAuMDAwMDEpXG5cdFx0XHRcdFx0KTtcblx0XHRwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShwb2ludCk7XG5cblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuICYmICF0aGlzLmdldEludGVybmFsUm91Z2hCb3VuZHMoKVxuXHRcdFx0XHQuZXhwYW5kKHRvbGVyYW5jZVBhZGRpbmcubXVsdGlwbHkoMikpLl9jb250YWluc1BvaW50KHBvaW50KSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBjaGVja1NlbGYgPSAhKG9wdGlvbnMuZ3VpZGVzICYmICF0aGlzLl9ndWlkZVxuXHRcdFx0XHR8fCBvcHRpb25zLnNlbGVjdGVkICYmICF0aGlzLl9zZWxlY3RlZFxuXHRcdFx0XHR8fCBvcHRpb25zLnR5cGUgJiYgb3B0aW9ucy50eXBlICE9PSBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0fHwgb3B0aW9ucy5jbGFzcyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBvcHRpb25zLmNsYXNzKSksXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdHJlcztcblxuXHRcdGZ1bmN0aW9uIGNoZWNrQm91bmRzKHR5cGUsIHBhcnQpIHtcblx0XHRcdHZhciBwdCA9IGJvdW5kc1snZ2V0JyArIHBhcnRdKCk7XG5cdFx0XHRpZiAocG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZSh0b2xlcmFuY2VQYWRkaW5nKS5sZW5ndGggPD0gMSlcblx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQodHlwZSwgdGhhdCxcblx0XHRcdFx0XHRcdHsgbmFtZTogQmFzZS5oeXBoZW5hdGUocGFydCksIHBvaW50OiBwdCB9KTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2tTZWxmICYmIChvcHRpb25zLmNlbnRlciB8fCBvcHRpb25zLmJvdW5kcykgJiYgdGhpcy5fcGFyZW50KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpO1xuXHRcdFx0aWYgKG9wdGlvbnMuY2VudGVyKVxuXHRcdFx0XHRyZXMgPSBjaGVja0JvdW5kcygnY2VudGVyJywgJ0NlbnRlcicpO1xuXHRcdFx0aWYgKCFyZXMgJiYgb3B0aW9ucy5ib3VuZHMpIHtcblx0XHRcdFx0dmFyIHBvaW50cyA9IFtcblx0XHRcdFx0XHQnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0Jyxcblx0XHRcdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ1xuXHRcdFx0XHRdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDggJiYgIXJlczsgaSsrKVxuXHRcdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdib3VuZHMnLCBwb2ludHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGlsZHJlbiA9ICFyZXMgJiYgdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHR2YXIgb3B0cyA9IHRoaXMuX2dldENoaWxkSGl0VGVzdE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwICYmICFyZXM7IGktLSlcblx0XHRcdFx0cmVzID0gY2hpbGRyZW5baV0uX2hpdFRlc3QocG9pbnQsIG9wdHMpO1xuXHRcdH1cblx0XHRpZiAoIXJlcyAmJiBjaGVja1NlbGYpXG5cdFx0XHRyZXMgPSB0aGlzLl9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucyk7XG5cdFx0aWYgKHJlcyAmJiByZXMucG9pbnQpXG5cdFx0XHRyZXMucG9pbnQgPSBtYXRyaXgudHJhbnNmb3JtKHJlcy5wb2ludCk7XG5cdFx0b3B0aW9ucy5fdG90YWxNYXRyaXggPSBwYXJlbnRUb3RhbE1hdHJpeDtcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zLmZpbGwgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKTtcblx0fSxcblxuXHRtYXRjaGVzOiBmdW5jdGlvbihuYW1lLCBjb21wYXJlKSB7XG5cdFx0ZnVuY3Rpb24gbWF0Y2hPYmplY3Qob2JqMSwgb2JqMikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBvYmoxKSB7XG5cdFx0XHRcdGlmIChvYmoxLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dmFyIHZhbDEgPSBvYmoxW2ldLFxuXHRcdFx0XHRcdFx0dmFsMiA9IG9iajJbaV07XG5cdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdCh2YWwxKSAmJiBCYXNlLmlzUGxhaW5PYmplY3QodmFsMikpIHtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2hPYmplY3QodmFsMSwgdmFsMikpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWwxLCB2YWwyKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMubWF0Y2hlcyhrZXksIG5hbWVba2V5XSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvXihlbXB0eXxlZGl0YWJsZSkkLy50ZXN0KG5hbWUpXG5cdFx0XHRcdFx0PyB0aGlzWydpcycgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldKClcblx0XHRcdFx0XHQ6IG5hbWUgPT09ICd0eXBlJ1xuXHRcdFx0XHRcdFx0PyBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0XHRcdDogdGhpc1tuYW1lXTtcblx0XHRcdGlmICgvXihjb25zdHJ1Y3RvcnxjbGFzcykkLy50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBjb21wYXJlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdFx0aWYgKCFjb21wYXJlLnRlc3QodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKCFjb21wYXJlKHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChjb21wYXJlKSkge1xuXHRcdFx0XHRpZiAoIW1hdGNoT2JqZWN0KGNvbXBhcmUsIHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwgY29tcGFyZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRJdGVtczogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCB0aGlzLl9tYXRyaXgpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMuX2NoaWxkcmVuLCBtYXRjaCwgdGhpcy5fbWF0cml4LCBudWxsLCB0cnVlKVxuXHRcdFx0XHRbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X2dldEl0ZW1zOiBmdW5jdGlvbiBfZ2V0SXRlbXMoY2hpbGRyZW4sIG1hdGNoLCBtYXRyaXgsIHBhcmFtLFxuXHRcdFx0XHRmaXJzdE9ubHkpIHtcblx0XHRcdGlmICghcGFyYW0pIHtcblx0XHRcdFx0dmFyIG92ZXJsYXBwaW5nID0gbWF0Y2gub3ZlcmxhcHBpbmcsXG5cdFx0XHRcdFx0aW5zaWRlID0gbWF0Y2guaW5zaWRlLFxuXHRcdFx0XHRcdGJvdW5kcyA9IG92ZXJsYXBwaW5nIHx8IGluc2lkZSxcblx0XHRcdFx0XHRyZWN0ID1cdGJvdW5kcyAmJiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSk7XG5cdFx0XHRcdHBhcmFtID0ge1xuXHRcdFx0XHRcdGl0ZW1zOiBbXSxcblx0XHRcdFx0XHRpbnNpZGU6IHJlY3QsXG5cdFx0XHRcdFx0b3ZlcmxhcHBpbmc6IG92ZXJsYXBwaW5nICYmIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRcdFx0XHRyZWN0YW5nbGU6IHJlY3QsXG5cdFx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGJvdW5kcylcblx0XHRcdFx0XHRtYXRjaCA9IEJhc2Uuc2V0KHt9LCBtYXRjaCxcblx0XHRcdFx0XHRcdFx0eyBpbnNpZGU6IHRydWUsIG92ZXJsYXBwaW5nOiB0cnVlIH0pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGl0ZW1zID0gcGFyYW0uaXRlbXMsXG5cdFx0XHRcdGluc2lkZSA9IHBhcmFtLmluc2lkZSxcblx0XHRcdFx0b3ZlcmxhcHBpbmcgPSBwYXJhbS5vdmVybGFwcGluZztcblx0XHRcdG1hdHJpeCA9IGluc2lkZSAmJiAobWF0cml4IHx8IG5ldyBNYXRyaXgoKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0XHRjaGlsZE1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksXG5cdFx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKGluc2lkZSkge1xuXHRcdFx0XHRcdHZhciBib3VuZHMgPSBjaGlsZC5nZXRCb3VuZHMoY2hpbGRNYXRyaXgpO1xuXHRcdFx0XHRcdGlmICghaW5zaWRlLmludGVyc2VjdHMoYm91bmRzKSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlmICghKGluc2lkZSAmJiBpbnNpZGUuY29udGFpbnMoYm91bmRzKSkgJiYgIShvdmVybGFwcGluZ1xuXHRcdFx0XHRcdFx0XHQmJiBvdmVybGFwcGluZy5pbnRlcnNlY3RzKGNoaWxkLCBjaGlsZE1hdHJpeCkpKVxuXHRcdFx0XHRcdFx0YWRkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFkZCAmJiBjaGlsZC5tYXRjaGVzKG1hdGNoKSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdGlmIChmaXJzdE9ubHkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRfZ2V0SXRlbXMoY2hpbGQuX2NoaWxkcmVuLCBtYXRjaCxcblx0XHRcdFx0XHRcdGNoaWxkTWF0cml4LCBwYXJhbSxcblx0XHRcdFx0XHRcdGZpcnN0T25seSk7XG5cdFx0XHRcdGlmIChmaXJzdE9ubHkgJiYgaXRlbXMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdH1cbn0sIHtcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uKSB7XG5cdFx0dmFyIHJlcyA9IEJhc2UuaW1wb3J0SlNPTihqc29uLCB0aGlzKTtcblx0XHRyZXR1cm4gcmVzICE9PSB0aGlzXG5cdFx0XHRcdD8gdGhpcy5hZGRDaGlsZChyZXMpXG5cdFx0XHRcdDogcmVzO1xuXHR9LFxuXG5cdGFkZENoaWxkOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCh1bmRlZmluZWQsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGQ6IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHR2YXIgcmVzID0gdGhpcy5pbnNlcnRDaGlsZHJlbihpbmRleCwgW2l0ZW1dLCBfcHJlc2VydmUpO1xuXHRcdHJldHVybiByZXMgJiYgcmVzWzBdO1xuXHR9LFxuXG5cdGFkZENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcywgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4ubGVuZ3RoLCBpdGVtcywgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24oaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIF9wcm90bykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbiAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShpdGVtcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdFx0aWYgKF9wcm90byAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBfcHJvdG8pKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGl0ZW0uX3JlbW92ZShmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdEJhc2Uuc3BsaWNlKGNoaWxkcmVuLCBpdGVtcywgaW5kZXgsIDApO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRub3RpZnlTZWxmID0gcHJvamVjdCAmJiBwcm9qZWN0Ll9jaGFuZ2VzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdFx0aXRlbS5fcGFyZW50ID0gdGhpcztcblx0XHRcdFx0aXRlbS5fc2V0UHJvamVjdCh0aGlzLl9wcm9qZWN0LCB0cnVlKTtcblx0XHRcdFx0aWYgKGl0ZW0uX25hbWUpXG5cdFx0XHRcdFx0aXRlbS5zZXROYW1lKGl0ZW0uX25hbWUpO1xuXHRcdFx0XHRpZiAobm90aWZ5U2VsZilcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW1zID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdF9pbnNlcnQ6IGZ1bmN0aW9uKGFib3ZlLCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRpZiAoIWl0ZW0uX3BhcmVudClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBpbmRleCA9IGl0ZW0uX2luZGV4ICsgKGFib3ZlID8gMSA6IDApO1xuXHRcdGlmIChpdGVtLl9wYXJlbnQgPT09IHRoaXMuX3BhcmVudCAmJiBpbmRleCA+IHRoaXMuX2luZGV4KVxuXHRcdFx0aW5kZXgtLTtcblx0XHRyZXR1cm4gaXRlbS5fcGFyZW50Lmluc2VydENoaWxkKGluZGV4LCB0aGlzLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydEFib3ZlOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0KHRydWUsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0QmVsb3c6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLl9pbnNlcnQoZmFsc2UsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0c2VuZFRvQmFjazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRDaGlsZCgwLCB0aGlzKTtcblx0fSxcblxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG5cdH0sXG5cblx0YXBwZW5kVG9wOiAnI2FkZENoaWxkJyxcblxuXHRhcHBlbmRCb3R0b206IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCgwLCBpdGVtKTtcblx0fSxcblxuXHRtb3ZlQWJvdmU6ICcjaW5zZXJ0QWJvdmUnLFxuXG5cdG1vdmVCZWxvdzogJyNpbnNlcnRCZWxvdycsXG5cblx0cmVkdWNlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlblswXS5yZWR1Y2UoKTtcblx0XHRcdGNoaWxkLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0Y2hpbGQuc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3JlbW92ZU5hbWVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHBhcmVudC5fY2hpbGRyZW4sXG5cdFx0XHRcdG5hbWVkQ2hpbGRyZW4gPSBwYXJlbnQuX25hbWVkQ2hpbGRyZW4sXG5cdFx0XHRcdG5hbWUgPSB0aGlzLl9uYW1lLFxuXHRcdFx0XHRuYW1lZEFycmF5ID0gbmFtZWRDaGlsZHJlbltuYW1lXSxcblx0XHRcdFx0aW5kZXggPSBuYW1lZEFycmF5ID8gbmFtZWRBcnJheS5pbmRleE9mKHRoaXMpIDogLTE7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGlmIChjaGlsZHJlbltuYW1lXSA9PSB0aGlzKVxuXHRcdFx0XHRcdGRlbGV0ZSBjaGlsZHJlbltuYW1lXTtcblx0XHRcdFx0bmFtZWRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRpZiAobmFtZWRBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRjaGlsZHJlbltuYW1lXSA9IG5hbWVkQXJyYXlbbmFtZWRBcnJheS5sZW5ndGggLSAxXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgbmFtZWRDaGlsZHJlbltuYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlOiBmdW5jdGlvbihub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdFx0aWYgKHRoaXMuX2luZGV4ICE9IG51bGwpXG5cdFx0XHRcdEJhc2Uuc3BsaWNlKHBhcmVudC5fY2hpbGRyZW4sIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0aWYgKG5vdGlmeVNlbGYpIHtcblx0XHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdFx0XHRpZiAocHJvamVjdCAmJiBwcm9qZWN0Ll9jaGFuZ2VzKVxuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobm90aWZ5UGFyZW50KVxuXHRcdFx0XHRwYXJlbnQuX2NoYW5nZWQoMTEpO1xuXHRcdFx0dGhpcy5fcGFyZW50ID0gbnVsbDtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVtb3ZlKHRydWUsIHRydWUpO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIG9rID0gaXRlbSAmJiBpdGVtLmluc2VydEJlbG93KHRoaXMpO1xuXHRcdGlmIChvaylcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIG9rO1xuXHR9LFxuXG5cdHJlbW92ZUNoaWxkcmVuOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdGlmICghdGhpcy5fY2hpbGRyZW4pXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRmcm9tID0gZnJvbSB8fCAwO1xuXHRcdHRvID0gQmFzZS5waWNrKHRvLCB0aGlzLl9jaGlsZHJlbi5sZW5ndGgpO1xuXHRcdHZhciByZW1vdmVkID0gQmFzZS5zcGxpY2UodGhpcy5fY2hpbGRyZW4sIG51bGwsIGZyb20sIHRvIC0gZnJvbSk7XG5cdFx0Zm9yICh2YXIgaSA9IHJlbW92ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHJlbW92ZWRbaV0uX3JlbW92ZSh0cnVlLCBmYWxzZSk7XG5cdFx0fVxuXHRcdGlmIChyZW1vdmVkLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbGVhcjogJyNyZW1vdmVDaGlsZHJlbicsXG5cblx0cmV2ZXJzZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdHRoaXMuX2NoaWxkcmVuLnJldmVyc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9jaGlsZHJlbltpXS5faW5kZXggPSBpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0fVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuXHR9LFxuXG5cdGlzRWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtID0gdGhpcztcblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKCFpdGVtLl92aXNpYmxlIHx8IGl0ZW0uX2xvY2tlZClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aGFzRmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNGaWxsKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1N0cm9rZSgpO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTaGFkb3coKTtcblx0fSxcblxuXHRfZ2V0T3JkZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRmdW5jdGlvbiBnZXRMaXN0KGl0ZW0pIHtcblx0XHRcdHZhciBsaXN0ID0gW107XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGxpc3QudW5zaGlmdChpdGVtKTtcblx0XHRcdH0gd2hpbGUgKGl0ZW0gPSBpdGVtLl9wYXJlbnQpO1xuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXHRcdHZhciBsaXN0MSA9IGdldExpc3QodGhpcyksXG5cdFx0XHRsaXN0MiA9IGdldExpc3QoaXRlbSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbihsaXN0MS5sZW5ndGgsIGxpc3QyLmxlbmd0aCk7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChsaXN0MVtpXSAhPSBsaXN0MltpXSkge1xuXHRcdFx0XHRyZXR1cm4gbGlzdDFbaV0uX2luZGV4IDwgbGlzdDJbaV0uX2luZGV4ID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHRoYXNDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA+IDA7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pc0luc2VydGVkKCkgOiBmYWxzZTtcblx0fSxcblxuXHRpc0Fib3ZlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAtMTtcblx0fSxcblxuXHRpc0JlbG93OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAxO1xuXHR9LFxuXG5cdGlzUGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbTtcblx0fSxcblxuXHRpc0NoaWxkOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5fcGFyZW50ID09PSB0aGlzO1xuXHR9LFxuXG5cdGlzRGVzY2VuZGFudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCA9PSBpdGVtKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzQW5jZXN0b3I6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA/IGl0ZW0uaXNEZXNjZW5kYW50KHRoaXMpIDogZmFsc2U7XG5cdH0sXG5cblx0aXNHcm91cGVkV2l0aDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0d2hpbGUgKHBhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudC5fcGFyZW50XG5cdFx0XHRcdCYmIC9eKEdyb3VwfExheWVyfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpXG5cdFx0XHRcdCYmIGl0ZW0uaXNEZXNjZW5kYW50KHBhcmVudCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShteC50cmFuc2xhdGUuYXBwbHkobXgsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5yb3RhdGUoYW5nbGUsXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzLCAxLCB7IHJlYWROdWxsOiB0cnVlIH0pXG5cdFx0XHRcdFx0fHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9XG59LCBCYXNlLmVhY2goWydzY2FsZScsICdzaGVhcicsICdza2V3J10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KClbbmFtZV0ocG9pbnQsXG5cdFx0XHRcdGNlbnRlciB8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH07XG59LCB7XG5cbn0pLCB7XG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4LCBfYXBwbHlNYXRyaXgpIHtcblx0XHRpZiAobWF0cml4ICYmIG1hdHJpeC5pc0lkZW50aXR5KCkpXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdHZhciBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0YXBwbHlNYXRyaXggPSAoX2FwcGx5TWF0cml4IHx8IHRoaXMuX2FwcGx5TWF0cml4KVxuXHRcdFx0XHQmJiAoIV9tYXRyaXguaXNJZGVudGl0eSgpIHx8IG1hdHJpeCk7XG5cdFx0aWYgKCFtYXRyaXggJiYgIWFwcGx5TWF0cml4KVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdF9tYXRyaXgucHJlQ29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHRpZiAoYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeCAmJiB0aGlzLl90cmFuc2Zvcm1Db250ZW50KF9tYXRyaXgpKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdCxcblx0XHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdFx0ZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKHRydWUpLFxuXHRcdFx0XHRzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKHRydWUpO1xuXHRcdFx0aWYgKHBpdm90KVxuXHRcdFx0XHRfbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdCwgcGl2b3QsIHRydWUpO1xuXHRcdFx0aWYgKGZpbGxDb2xvcilcblx0XHRcdFx0ZmlsbENvbG9yLnRyYW5zZm9ybShfbWF0cml4KTtcblx0XHRcdGlmIChzdHJva2VDb2xvcilcblx0XHRcdFx0c3Ryb2tlQ29sb3IudHJhbnNmb3JtKF9tYXRyaXgpO1xuXHRcdFx0X21hdHJpeC5yZXNldCh0cnVlKTtcblx0XHR9XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcyxcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR2YXIgZGVjb21wID0gYm91bmRzICYmIG1hdHJpeCAmJiBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0aWYgKGRlY29tcCAmJiAhZGVjb21wLnNoZWFyaW5nICYmIGRlY29tcC5yb3RhdGlvbiAlIDkwID09PSAwKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYm91bmRzKSB7XG5cdFx0XHRcdHZhciByZWN0ID0gYm91bmRzW2tleV07XG5cdFx0XHRcdGlmIChhcHBseU1hdHJpeCB8fCAhcmVjdC5faW50ZXJuYWwpXG5cdFx0XHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCwgcmVjdCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZ2V0dGVyID0gdGhpcy5fYm91bmRzR2V0dGVyLFxuXHRcdFx0XHRyZWN0ID0gYm91bmRzW2dldHRlciAmJiBnZXR0ZXIuZ2V0Qm91bmRzIHx8IGdldHRlciB8fCAnZ2V0Qm91bmRzJ107XG5cdFx0XHRpZiAocmVjdClcblx0XHRcdFx0dGhpcy5fcG9zaXRpb24gPSByZWN0LmdldENlbnRlcih0cnVlKTtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcblx0XHR9IGVsc2UgaWYgKG1hdHJpeCAmJiBwb3NpdGlvbikge1xuXHRcdFx0dGhpcy5fcG9zaXRpb24gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvc2l0aW9uLCBwb3NpdGlvbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS50cmFuc2Zvcm0obWF0cml4LCB0cnVlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRnbG9iYWxUb0xvY2FsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX2ludmVyc2VUcmFuc2Zvcm0oXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0bG9jYWxUb0dsb2JhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl90cmFuc2Zvcm1Qb2ludChcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRwYXJlbnRUb0xvY2FsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0bG9jYWxUb1BhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgZmlsbCkge1xuXHRcdHJlY3RhbmdsZSA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRpdGVtUmF0aW8gPSBib3VuZHMuaGVpZ2h0IC8gYm91bmRzLndpZHRoLFxuXHRcdFx0cmVjdFJhdGlvID0gcmVjdGFuZ2xlLmhlaWdodCAvIHJlY3RhbmdsZS53aWR0aCxcblx0XHRcdHNjYWxlID0gKGZpbGwgPyBpdGVtUmF0aW8gPiByZWN0UmF0aW8gOiBpdGVtUmF0aW8gPCByZWN0UmF0aW8pXG5cdFx0XHRcdFx0PyByZWN0YW5nbGUud2lkdGggLyBib3VuZHMud2lkdGhcblx0XHRcdFx0XHQ6IHJlY3RhbmdsZS5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0LFxuXHRcdFx0bmV3Qm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSxcblx0XHRcdFx0XHRuZXcgU2l6ZShib3VuZHMud2lkdGggKiBzY2FsZSwgYm91bmRzLmhlaWdodCAqIHNjYWxlKSk7XG5cdFx0bmV3Qm91bmRzLnNldENlbnRlcihyZWN0YW5nbGUuZ2V0Q2VudGVyKCkpO1xuXHRcdHRoaXMuc2V0Qm91bmRzKG5ld0JvdW5kcyk7XG5cdH0sXG5cblx0X3NldFN0eWxlczogZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IoKSxcblx0XHRcdHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IoKSxcblx0XHRcdHNoYWRvd0NvbG9yID0gc3R5bGUuZ2V0U2hhZG93Q29sb3IoKTtcblx0XHRpZiAoZmlsbENvbG9yKVxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0aWYgKHN0cm9rZUNvbG9yKSB7XG5cdFx0XHR2YXIgc3Ryb2tlV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuXHRcdFx0aWYgKHN0cm9rZVdpZHRoID4gMCkge1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcblx0XHRcdFx0dmFyIHN0cm9rZUpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG5cdFx0XHRcdFx0c3Ryb2tlQ2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRcdFx0bWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdFx0aWYgKHN0cm9rZUpvaW4pXG5cdFx0XHRcdFx0Y3R4LmxpbmVKb2luID0gc3Ryb2tlSm9pbjtcblx0XHRcdFx0aWYgKHN0cm9rZUNhcClcblx0XHRcdFx0XHRjdHgubGluZUNhcCA9IHN0cm9rZUNhcDtcblx0XHRcdFx0aWYgKG1pdGVyTGltaXQpXG5cdFx0XHRcdFx0Y3R4Lm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHRcdFx0XHRpZiAocGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoKSB7XG5cdFx0XHRcdFx0dmFyIGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRcdFx0ZGFzaE9mZnNldCA9IHN0eWxlLmdldERhc2hPZmZzZXQoKTtcblx0XHRcdFx0XHRpZiAoZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmICgnc2V0TGluZURhc2gnIGluIGN0eCkge1xuXHRcdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoID0gZGFzaEFycmF5O1xuXHRcdFx0XHRcdFx0XHRjdHgubW96RGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzaGFkb3dDb2xvcikge1xuXHRcdFx0dmFyIHNoYWRvd0JsdXIgPSBzdHlsZS5nZXRTaGFkb3dCbHVyKCk7XG5cdFx0XHRpZiAoc2hhZG93Qmx1ciA+IDApIHtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdFx0XHRjdHguc2hhZG93Qmx1ciA9IHNoYWRvd0JsdXI7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLmdldFNoYWRvd09mZnNldCgpO1xuXHRcdFx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IG9mZnNldC54O1xuXHRcdFx0XHRjdHguc2hhZG93T2Zmc2V0WSA9IG9mZnNldC55O1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBwYXJlbnRTdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB0aGlzLl9wcm9qZWN0Ll91cGRhdGVWZXJzaW9uO1xuXHRcdGlmICghdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9vcGFjaXR5ID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBtYXRyaWNlcyA9IHBhcmFtLm1hdHJpY2VzLFxuXHRcdFx0dmlld01hdHJpeCA9IHBhcmFtLnZpZXdNYXRyaXgsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRnbG9iYWxNYXRyaXggPSBtYXRyaWNlc1ttYXRyaWNlcy5sZW5ndGggLSAxXS5jaGFpbihtYXRyaXgpO1xuXHRcdGlmICghZ2xvYmFsTWF0cml4LmlzSW52ZXJ0aWJsZSgpKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Vmlld01hdHJpeChtYXRyaXgpIHtcblx0XHRcdHJldHVybiB2aWV3TWF0cml4ID8gdmlld01hdHJpeC5jaGFpbihtYXRyaXgpIDogbWF0cml4O1xuXHRcdH1cblxuXHRcdG1hdHJpY2VzLnB1c2goZ2xvYmFsTWF0cml4KTtcblx0XHRpZiAocGFyYW0udXBkYXRlTWF0cml4KSB7XG5cdFx0XHRnbG9iYWxNYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdFx0dGhpcy5fZ2xvYmFsTWF0cml4ID0gZ2xvYmFsTWF0cml4O1xuXHRcdH1cblxuXHRcdHZhciBibGVuZE1vZGUgPSB0aGlzLl9ibGVuZE1vZGUsXG5cdFx0XHRvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSxcblx0XHRcdG5vcm1hbEJsZW5kID0gYmxlbmRNb2RlID09PSAnbm9ybWFsJyxcblx0XHRcdG5hdGl2ZUJsZW5kID0gQmxlbmRNb2RlLm5hdGl2ZU1vZGVzW2JsZW5kTW9kZV0sXG5cdFx0XHRkaXJlY3QgPSBub3JtYWxCbGVuZCAmJiBvcGFjaXR5ID09PSAxXG5cdFx0XHRcdFx0fHwgcGFyYW0uZG9udFN0YXJ0XG5cdFx0XHRcdFx0fHwgcGFyYW0uY2xpcFxuXHRcdFx0XHRcdHx8IChuYXRpdmVCbGVuZCB8fCBub3JtYWxCbGVuZCAmJiBvcGFjaXR5IDwgMSlcblx0XHRcdFx0XHRcdCYmIHRoaXMuX2NhbkNvbXBvc2l0ZSgpLFxuXHRcdFx0cGl4ZWxSYXRpbyA9IHBhcmFtLnBpeGVsUmF0aW8sXG5cdFx0XHRtYWluQ3R4LCBpdGVtT2Zmc2V0LCBwcmV2T2Zmc2V0O1xuXHRcdGlmICghZGlyZWN0KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpKTtcblx0XHRcdGlmICghYm91bmRzLndpZHRoIHx8ICFib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRwcmV2T2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aXRlbU9mZnNldCA9IHBhcmFtLm9mZnNldCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKTtcblx0XHRcdG1haW5DdHggPSBjdHg7XG5cdFx0XHRjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KGJvdW5kcy5nZXRTaXplKCkuY2VpbCgpLmFkZCgxKVxuXHRcdFx0XHRcdC5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSlcblx0XHRcdFx0Y3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBzdHJva2VNYXRyaXggPSBwYXJlbnRTdHJva2VNYXRyaXhcblx0XHRcdFx0PyBwYXJlbnRTdHJva2VNYXRyaXguY2hhaW4obWF0cml4KVxuXHRcdFx0XHQ6ICF0aGlzLmdldFN0cm9rZVNjYWxpbmcodHJ1ZSkgJiYgZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpLFxuXHRcdFx0Y2xpcCA9ICFkaXJlY3QgJiYgcGFyYW0uY2xpcEl0ZW0sXG5cdFx0XHR0cmFuc2Zvcm0gPSAhc3Ryb2tlTWF0cml4IHx8IGNsaXA7XG5cdFx0aWYgKGRpcmVjdCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblx0XHRcdGlmIChuYXRpdmVCbGVuZClcblx0XHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcblx0XHR9IGVsc2UgaWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgtaXRlbU9mZnNldC54LCAtaXRlbU9mZnNldC55KTtcblx0XHR9XG5cdFx0aWYgKHRyYW5zZm9ybSlcblx0XHRcdChkaXJlY3QgPyBtYXRyaXggOiBnZXRWaWV3TWF0cml4KGdsb2JhbE1hdHJpeCkpLmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0aWYgKGNsaXApXG5cdFx0XHRwYXJhbS5jbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0aWYgKHN0cm9rZU1hdHJpeCkge1xuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcblx0XHRcdHZhciBvZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG5cdFx0XHRpZiAob2Zmc2V0KVxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKC1vZmZzZXQueCwgLW9mZnNldC55KTtcblx0XHR9XG5cdFx0dGhpcy5fZHJhdyhjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0bWF0cmljZXMucG9wKCk7XG5cdFx0aWYgKHBhcmFtLmNsaXAgJiYgIXBhcmFtLmRvbnRGaW5pc2gpXG5cdFx0XHRjdHguY2xpcCgpO1xuXHRcdGlmICghZGlyZWN0KSB7XG5cdFx0XHRCbGVuZE1vZGUucHJvY2VzcyhibGVuZE1vZGUsIGN0eCwgbWFpbkN0eCwgb3BhY2l0eSxcblx0XHRcdFx0XHRpdGVtT2Zmc2V0LnN1YnRyYWN0KHByZXZPZmZzZXQpLm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcblx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0XHRcdHBhcmFtLm9mZnNldCA9IHByZXZPZmZzZXQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1VwZGF0ZWQ6IGZ1bmN0aW9uKHVwZGF0ZVZlcnNpb24pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRyZXR1cm4gcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbik7XG5cdFx0dmFyIHVwZGF0ZWQgPSB0aGlzLl91cGRhdGVWZXJzaW9uID09PSB1cGRhdGVWZXJzaW9uO1xuXHRcdGlmICghdXBkYXRlZCAmJiBwYXJlbnQgJiYgcGFyZW50Ll92aXNpYmxlXG5cdFx0XHRcdCYmIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdXBkYXRlZDtcblx0fSxcblxuXHRfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHNpemUsIHNlbGVjdGVkSXRlbXMsIHVwZGF0ZVZlcnNpb24pIHtcblx0XHRpZiAoKHRoaXMuX2RyYXdTZWxlY3RlZCB8fCB0aGlzLl9ib3VuZHNTZWxlY3RlZClcblx0XHRcdFx0JiYgdGhpcy5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG5cdFx0XHR2YXIgY29sb3IgPSB0aGlzLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSlcblx0XHRcdFx0XHR8fCB0aGlzLmdldExheWVyKCkuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKSxcblx0XHRcdFx0bXggPSBtYXRyaXguY2hhaW4odGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cdFx0XHRcdFx0PyBjb2xvci50b0NhbnZhc1N0eWxlKGN0eCkgOiAnIzAwOWRlYyc7XG5cdFx0XHRpZiAodGhpcy5fZHJhd1NlbGVjdGVkKVxuXHRcdFx0XHR0aGlzLl9kcmF3U2VsZWN0ZWQoY3R4LCBteCwgc2VsZWN0ZWRJdGVtcyk7XG5cdFx0XHRpZiAodGhpcy5fYm91bmRzU2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIGhhbGYgPSBzaXplIC8gMjtcblx0XHRcdFx0XHRjb29yZHMgPSBteC5fdHJhbnNmb3JtQ29ybmVycyh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuXHRcdFx0XHRcdGN0eFtpID09PSAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10oY29vcmRzW2ldLCBjb29yZHNbKytpXSk7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKylcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29vcmRzW2ldIC0gaGFsZiwgY29vcmRzWysraV0gLSBoYWxmLFxuXHRcdFx0XHRcdFx0XHRzaXplLCBzaXplKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59LCBCYXNlLmVhY2goWydkb3duJywgJ2RyYWcnLCAndXAnLCAnbW92ZSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHRoaXNbJ3JlbW92ZU9uJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzaCA9IHt9O1xuXHRcdGhhc2hbbmFtZV0gPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZU9uKGhhc2gpO1xuXHR9O1xufSwge1xuXG5cdHJlbW92ZU9uOiBmdW5jdGlvbihvYmopIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0aWYgKG9ialtuYW1lXSkge1xuXHRcdFx0XHR2YXIga2V5ID0gJ21vdXNlJyArIG5hbWUsXG5cdFx0XHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdFx0c2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV0gPSBzZXRzW2tleV0gfHwge307XG5cdFx0XHRcdHNldHNba2V5XVt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSkpO1xuXG52YXIgR3JvdXAgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyb3VwJyxcblx0X3NlbGVjdENoaWxkcmVuOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y2hpbGRyZW46IFtdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JvdXAoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpXG5cdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiAxMDI2KSB7XG5cdFx0XHR0aGlzLl9jbGlwSXRlbSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0X2dldENsaXBJdGVtOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2xpcEl0ZW0gPSB0aGlzLl9jbGlwSXRlbTtcblx0XHRpZiAoY2xpcEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2xpcEl0ZW0gPSBudWxsO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChjaGlsZC5fY2xpcE1hc2spIHtcblx0XHRcdFx0XHRjbGlwSXRlbSA9IGNoaWxkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jbGlwSXRlbSA9IGNsaXBJdGVtO1xuXHRcdH1cblx0XHRyZXR1cm4gY2xpcEl0ZW07XG5cdH0sXG5cblx0aXNDbGlwcGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXHR9LFxuXG5cdHNldENsaXBwZWQ6IGZ1bmN0aW9uKGNsaXBwZWQpIHtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRpZiAoY2hpbGQpXG5cdFx0XHRjaGlsZC5zZXRDbGlwTWFzayhjbGlwcGVkKTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHZhciBjbGlwID0gcGFyYW0uY2xpcCxcblx0XHRcdGNsaXBJdGVtID0gIWNsaXAgJiYgdGhpcy5fZ2V0Q2xpcEl0ZW0oKSxcblx0XHRcdGRyYXcgPSB0cnVlO1xuXHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgY2xpcEl0ZW06IGNsaXBJdGVtLCBjbGlwOiBmYWxzZSB9KTtcblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRcdGN0eC5jdXJyZW50UGF0aCA9IHRoaXMuX2N1cnJlbnRQYXRoO1xuXHRcdFx0XHRkcmF3ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdHBhcmFtLmRvbnRTdGFydCA9IHBhcmFtLmRvbnRGaW5pc2ggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY2xpcEl0ZW0pIHtcblx0XHRcdGNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcblx0XHR9XG5cdFx0aWYgKGRyYXcpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChpdGVtICE9PSBjbGlwSXRlbSlcblx0XHRcdFx0XHRpdGVtLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgTGF5ZXIgPSBHcm91cC5leHRlbmQoe1xuXHRfY2xhc3M6ICdMYXllcicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTGF5ZXIoYXJnKSB7XG5cdFx0dmFyIHByb3BzID0gQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0PyBuZXcgQmFzZShhcmcpXG5cdFx0XHRcdDogeyBjaGlsZHJlbjogQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzIH0sXG5cdFx0XHRpbnNlcnQgPSBwcm9wcy5pbnNlcnQ7XG5cdFx0cHJvcHMuaW5zZXJ0ID0gZmFsc2U7XG5cdFx0R3JvdXAuY2FsbCh0aGlzLCBwcm9wcyk7XG5cdFx0aWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fcHJvamVjdC5hZGRDaGlsZCh0aGlzKTtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZTogZnVuY3Rpb24gX3JlbW92ZShub3RpZnkpIHtcblx0XHRpZiAodGhpcy5fcGFyZW50KVxuXHRcdFx0cmV0dXJuIF9yZW1vdmUuYmFzZS5jYWxsKHRoaXMsIG5vdGlmeSk7XG5cdFx0aWYgKHRoaXMuX2luZGV4ICE9IG51bGwpIHtcblx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRcdGlmIChwcm9qZWN0Ll9hY3RpdmVMYXllciA9PT0gdGhpcylcblx0XHRcdFx0cHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzLmdldE5leHRTaWJsaW5nKClcblx0XHRcdFx0XHRcdHx8IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cdFx0XHRCYXNlLnNwbGljZShwcm9qZWN0LmxheWVycywgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHRwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbiBnZXROZXh0U2libGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gZ2V0TmV4dFNpYmxpbmcuYmFzZS5jYWxsKHRoaXMpXG5cdFx0XHRcdDogdGhpcy5fcHJvamVjdC5sYXllcnNbdGhpcy5faW5kZXggKyAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzU2libGluZzogZnVuY3Rpb24gZ2V0UHJldmlvdXNTaWJsaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBnZXRQcmV2aW91c1NpYmxpbmcuYmFzZS5jYWxsKHRoaXMpXG5cdFx0XHRcdDogdGhpcy5fcHJvamVjdC5sYXllcnNbdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uIGlzSW5zZXJ0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGlzSW5zZXJ0ZWQuYmFzZS5jYWxsKHRoaXMpIDogdGhpcy5faW5kZXggIT0gbnVsbDtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzO1xuXHR9LFxuXG5cdF9pbnNlcnQ6IGZ1bmN0aW9uIF9pbnNlcnQoYWJvdmUsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdGlmIChpdGVtIGluc3RhbmNlb2YgTGF5ZXIgJiYgIWl0ZW0uX3BhcmVudCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlKHRydWUsIHRydWUpO1xuXHRcdFx0QmFzZS5zcGxpY2UoaXRlbS5fcHJvamVjdC5sYXllcnMsIFt0aGlzXSxcblx0XHRcdFx0XHRpdGVtLl9pbmRleCArIChhYm92ZSA/IDEgOiAwKSwgMCk7XG5cdFx0XHR0aGlzLl9zZXRQcm9qZWN0KGl0ZW0uX3Byb2plY3QsIHRydWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiBfaW5zZXJ0LmJhc2UuY2FsbCh0aGlzLCBhYm92ZSwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fVxufSk7XG5cbnZhciBTaGFwZSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2hhcGUnLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHR0eXBlOiBudWxsLFxuXHRcdHNpemU6IG51bGwsXG5cdFx0cmFkaXVzOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2hhcGUocHJvcHMpIHtcblx0XHR0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IGl0ZW0uX3R5cGVcblx0XHRcdCYmIHRoaXMuX3NpemUuZXF1YWxzKGl0ZW0uX3NpemUpXG5cdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9yYWRpdXMsIGl0ZW0uX3JhZGl1cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFNoYXBlKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFR5cGUodGhpcy5fdHlwZSk7XG5cdFx0Y29weS5zZXRTaXplKHRoaXMuX3NpemUpO1xuXHRcdGNvcHkuc2V0UmFkaXVzKHRoaXMuX3JhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH0sXG5cblx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHR9LFxuXG5cdGdldFNoYXBlOiAnI2dldFR5cGUnLFxuXHRzZXRTaGFwZTogJyNzZXRUeXBlJyxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUubWluKHRoaXMuX3JhZGl1cywgc2l6ZS5kaXZpZGUoMikpO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHdpZHRoIC8gMjtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmFkID0gdGhpcy5fcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSAnY2lyY2xlJ1xuXHRcdFx0XHQ/IHJhZFxuXHRcdFx0XHQ6IG5ldyBMaW5rZWRTaXplKHJhZC53aWR0aCwgcmFkLmhlaWdodCwgdGhpcywgJ3NldFJhZGl1cycpO1xuXHR9LFxuXG5cdHNldFJhZGl1czogZnVuY3Rpb24ocmFkaXVzKSB7XG5cdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuXHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0aWYgKHJhZGl1cyA9PT0gdGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgc2l6ZSA9IHJhZGl1cyAqIDI7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0XHR0aGlzLl9zaXplLnNldChzaXplLCBzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuX3JhZGl1cykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXMuY2xvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9yYWRpdXMuZXF1YWxzKHJhZGl1cykpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBzaXplID0gU2l6ZS5tYXgodGhpcy5fc2l6ZSwgcmFkaXVzLm11bHRpcGx5KDIpKTtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5zZXQocmFkaXVzLndpZHRoICogMiwgcmFkaXVzLmhlaWdodCAqIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRvUGF0aDogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aFtCYXNlLmNhcGl0YWxpemUodGhpcy5fdHlwZSldKHtcblx0XHRcdGNlbnRlcjogbmV3IFBvaW50KCksXG5cdFx0XHRzaXplOiB0aGlzLl9zaXplLFxuXHRcdFx0cmFkaXVzOiB0aGlzLl9yYWRpdXMsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0fSk7XG5cdFx0cGF0aC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0cGF0aC50cmFuc2Zvcm0odGhpcy5fbWF0cml4KTtcblx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0cGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHR1bnRyYW5zZm9ybWVkID0gIXN0cm9rZU1hdHJpeDtcblx0XHRpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0aXNDaXJjbGUgPSB0eXBlID09PSAnY2lyY2xlJztcblx0XHRcdGlmICghcGFyYW0uZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiBpc0NpcmNsZSkge1xuXHRcdFx0XHRjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJ4ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0c2l6ZSA9IHRoaXMuX3NpemUsXG5cdFx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiB0eXBlID09PSAncmVjdCcgJiYgcnggPT09IDAgJiYgcnkgPT09IDApIHtcblx0XHRcdFx0XHRjdHgucmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHggPSB3aWR0aCAvIDIsXG5cdFx0XHRcdFx0XHR5ID0gaGVpZ2h0IC8gMixcblx0XHRcdFx0XHRcdGthcHBhID0gMSAtIDAuNTUyMjg0NzQ5ODMwNzkzNixcblx0XHRcdFx0XHRcdGN4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRcdGN5ID0gcnkgKiBrYXBwYSxcblx0XHRcdFx0XHRcdGMgPSBbXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIHJ5LFxuXHRcdFx0XHRcdFx0XHQteCwgLXkgKyBjeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdC14ICsgcngsIC15LFxuXHRcdFx0XHRcdFx0XHR4IC0gcngsIC15LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIC15LFxuXHRcdFx0XHRcdFx0XHR4LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHR4LCAteSArIHJ5LFxuXHRcdFx0XHRcdFx0XHR4LCB5IC0gcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0eCAtIGN4LCB5LFxuXHRcdFx0XHRcdFx0XHR4IC0gcngsIHksXG5cdFx0XHRcdFx0XHRcdC14ICsgcngsIHksXG5cdFx0XHRcdFx0XHRcdC14ICsgY3gsIHksXG5cdFx0XHRcdFx0XHRcdC14LCB5IC0gY3ksXG5cdFx0XHRcdFx0XHRcdC14LCB5IC0gcnlcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0aWYgKHN0cm9rZU1hdHJpeClcblx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeC50cmFuc2Zvcm0oYywgYywgMzIpO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oY1swXSwgY1sxXSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XSwgY1s3XSk7XG5cdFx0XHRcdFx0aWYgKHggIT09IHJ4KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzhdLCBjWzldKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzEwXSwgY1sxMV0sIGNbMTJdLCBjWzEzXSwgY1sxNF0sIGNbMTVdKTtcblx0XHRcdFx0XHRpZiAoeSAhPT0gcnkpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMTZdLCBjWzE3XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1sxOF0sIGNbMTldLCBjWzIwXSwgY1syMV0sIGNbMjJdLCBjWzIzXSk7XG5cdFx0XHRcdFx0aWYgKHggIT09IHJ4KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzI0XSwgY1syNV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMjZdLCBjWzI3XSwgY1syOF0sIGNbMjldLCBjWzMwXSwgY1szMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0fVxuXHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChoYXNTdHJva2UpXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdGlmIChnZXR0ZXIgIT09ICdnZXRCb3VuZHMnICYmIHRoaXMuaGFzU3Ryb2tlKCkpXG5cdFx0XHRyZWN0ID0gcmVjdC5leHBhbmQodGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldENvcm5lckNlbnRlcih0aGF0LCBwb2ludCwgZXhwYW5kKSB7XG5cdFx0dmFyIHJhZGl1cyA9IHRoYXQuX3JhZGl1cztcblx0XHRpZiAoIXJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGhhbGZTaXplID0gdGhhdC5fc2l6ZS5kaXZpZGUoMik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHR2YXIgZGlyID0gbmV3IFBvaW50KGkgJiAxID8gMSA6IC0xLCBpID4gMSA/IDEgOiAtMSksXG5cdFx0XHRcdFx0Y29ybmVyID0gZGlyLm11bHRpcGx5KGhhbGZTaXplKSxcblx0XHRcdFx0XHRjZW50ZXIgPSBjb3JuZXIuc3VidHJhY3QoZGlyLm11bHRpcGx5KHJhZGl1cykpLFxuXHRcdFx0XHRcdHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvcm5lciwgY2VudGVyKTtcblx0XHRcdFx0aWYgKChleHBhbmQgPyByZWN0LmV4cGFuZChleHBhbmQpIDogcmVjdCkuY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiBjZW50ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RWxsaXBzZVJhZGl1cyhwb2ludCwgcmFkaXVzKSB7XG5cdFx0dmFyIGFuZ2xlID0gcG9pbnQuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdHdpZHRoID0gcmFkaXVzLndpZHRoICogMixcblx0XHRcdGhlaWdodCA9IHJhZGl1cy5oZWlnaHQgKiAyLFxuXHRcdFx0eCA9IHdpZHRoICogTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0eSA9IGhlaWdodCAqIE1hdGguY29zKGFuZ2xlKTtcblx0XHRyZXR1cm4gd2lkdGggKiBoZWlnaHQgLyAoMiAqIE1hdGguc3FydCh4ICogeCArIHkgKiB5KSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9jb250YWluczogZnVuY3Rpb24gX2NvbnRhaW5zKHBvaW50KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGdldENvcm5lckNlbnRlcih0aGlzLCBwb2ludCk7XG5cdFx0XHRcdHJldHVybiBjZW50ZXJcblx0XHRcdFx0XHRcdD8gcG9pbnQuc3VidHJhY3QoY2VudGVyKS5kaXZpZGUodGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRcdFx0XHQuZ2V0TGVuZ3RoKCkgPD0gMVxuXHRcdFx0XHRcdFx0OiBfY29udGFpbnMuYmFzZS5jYWxsKHRoaXMsIHBvaW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBwb2ludC5kaXZpZGUodGhpcy5zaXplKS5nZXRMZW5ndGgoKSA8PSAwLjU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgaGl0ID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRcdHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aCgpICsgMiAqIG9wdGlvbnMudG9sZXJhbmNlO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50LCBzdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0aWYgKGNlbnRlcikge1xuXHRcdFx0XHRcdFx0dmFyIHB0ID0gcG9pbnQuc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwdC5nZXRMZW5ndGgoKVxuXHRcdFx0XHRcdFx0XHRcdC0gZ2V0RWxsaXBzZVJhZGl1cyhwdCwgcmFkaXVzKSkgPD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCksXG5cdFx0XHRcdFx0XHRcdG91dGVyID0gcmVjdC5leHBhbmQoc3Ryb2tlV2lkdGgpLFxuXHRcdFx0XHRcdFx0XHRpbm5lciA9IHJlY3QuZXhwYW5kKC1zdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0XHRoaXQgPSBvdXRlci5fY29udGFpbnNQb2ludChwb2ludClcblx0XHRcdFx0XHRcdFx0XHQmJiAhaW5uZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKVxuXHRcdFx0XHRcdFx0cmFkaXVzID0gZ2V0RWxsaXBzZVJhZGl1cyhwb2ludCwgcmFkaXVzKTtcblx0XHRcdFx0XHRoaXQgPSAyICogTWF0aC5hYnMocG9pbnQuZ2V0TGVuZ3RoKCkgLSByYWRpdXMpXG5cdFx0XHRcdFx0XHRcdDw9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGl0XG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdzdHJva2UnLCB0aGlzKVxuXHRcdFx0XHRcdDogX2hpdFRlc3RTZWxmLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59LCB7XG5cbnN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gY3JlYXRlU2hhcGUodHlwZSwgcG9pbnQsIHNpemUsIHJhZGl1cywgYXJncykge1xuXHRcdHZhciBpdGVtID0gbmV3IFNoYXBlKEJhc2UuZ2V0TmFtZWQoYXJncykpO1xuXHRcdGl0ZW0uX3R5cGUgPSB0eXBlO1xuXHRcdGl0ZW0uX3NpemUgPSBzaXplO1xuXHRcdGl0ZW0uX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gaXRlbS50cmFuc2xhdGUocG9pbnQpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ2NpcmNsZScsIGNlbnRlciwgbmV3IFNpemUocmFkaXVzICogMiksIHJhZGl1cyxcblx0XHRcdFx0XHRhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKSxcblx0XHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdyZWN0YW5nbGUnLCByZWN0LmdldENlbnRlcih0cnVlKSxcblx0XHRcdFx0XHRyZWN0LmdldFNpemUodHJ1ZSksIHJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpLFxuXHRcdFx0XHRyYWRpdXMgPSBlbGxpcHNlLnJhZGl1cztcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnZWxsaXBzZScsIGVsbGlwc2UuY2VudGVyLCByYWRpdXMubXVsdGlwbHkoMiksXG5cdFx0XHRcdFx0cmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRfcmVhZEVsbGlwc2U6IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRcdHZhciBjZW50ZXIsXG5cdFx0XHRcdHJhZGl1cztcblx0XHRcdGlmIChCYXNlLmhhc05hbWVkKGFyZ3MsICdyYWRpdXMnKSkge1xuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpO1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJncywgJ3JlY3RhbmdsZScpO1xuXHRcdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcih0cnVlKTtcblx0XHRcdFx0cmFkaXVzID0gcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7IGNlbnRlcjogY2VudGVyLCByYWRpdXM6IHJhZGl1cyB9O1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIFJhc3RlciA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmFzdGVyJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc0dldHRlcjogJ2dldEJvdW5kcycsXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHNvdXJjZTogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJhc3RlcihvYmplY3QsIHBvc2l0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKG9iamVjdCxcblx0XHRcdFx0cG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKSB7XG5cdFx0XHRpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRTb3VyY2Uob2JqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0SW1hZ2Uob2JqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCF0aGlzLl9zaXplKVxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKCk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmdldFNvdXJjZSgpID09PSBpdGVtLmdldFNvdXJjZSgpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpLFxuXHRcdFx0aW1hZ2UgPSB0aGlzLl9pbWFnZSxcblx0XHRcdGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdGNvcHkuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdH0gZWxzZSBpZiAoY2FudmFzKSB7XG5cdFx0XHR2YXIgY29weUNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyh0aGlzLl9zaXplKTtcblx0XHRcdGNvcHlDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblx0XHRcdGNvcHkuc2V0Q2FudmFzKGNvcHlDYW52YXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLl9zaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRcdHRoaXMuc2V0Q2FudmFzKENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKSk7XG5cdFx0XHRpZiAoZWxlbWVudClcblx0XHRcdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLFxuXHRcdFx0XHRcdFx0c2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemUud2lkdGg7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5oZWlnaHQ7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemUud2lkdGggPT09IDAgJiYgdGhpcy5fc2l6ZS5oZWlnaHQgPT09IDA7XG5cdH0sXG5cblx0Z2V0UmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdG9yaWcgPSBuZXcgUG9pbnQoMCwgMCkudHJhbnNmb3JtKG1hdHJpeCksXG5cdFx0XHR1ID0gbmV3IFBvaW50KDEsIDApLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpLFxuXHRcdFx0diA9IG5ldyBQb2ludCgwLCAxKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKTtcblx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHQ3MiAvIHUuZ2V0TGVuZ3RoKCksXG5cdFx0XHQ3MiAvIHYuZ2V0TGVuZ3RoKClcblx0XHQpO1xuXHR9LFxuXG5cdGdldFBwaTogJyNnZXRSZXNvbHV0aW9uJyxcblxuXHRnZXRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xuXHR9LFxuXG5cdHNldEltYWdlOiBmdW5jdGlvbihpbWFnZSkge1xuXHRcdGlmICh0aGlzLl9jYW52YXMpXG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0aWYgKGltYWdlICYmIGltYWdlLmdldENvbnRleHQpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NhbnZhcyA9IGltYWdlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IGltYWdlO1xuXHRcdFx0dGhpcy5fY2FudmFzID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS53aWR0aCA6IDAsXG5cdFx0XHRcdGltYWdlID8gaW1hZ2UubmF0dXJhbEhlaWdodCB8fCBpbWFnZS5oZWlnaHQgOiAwKTtcblx0XHR0aGlzLl9jb250ZXh0ID0gbnVsbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDUyMSk7XG5cdH0sXG5cblx0Z2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2NhbnZhcykge1xuXHRcdFx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQodGhpcy5fc2l6ZSk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAodGhpcy5faW1hZ2UpXG5cdFx0XHRcdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLl9pbWFnZSwgMCwgMCk7XG5cdFx0XHRcdHRoaXMuX2NhbnZhcyA9IGN0eC5jYW52YXM7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhcztcblx0fSxcblxuXHRzZXRDYW52YXM6ICcjc2V0SW1hZ2UnLFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKG1vZGlmeSkge1xuXHRcdGlmICghdGhpcy5fY29udGV4dClcblx0XHRcdHRoaXMuX2NvbnRleHQgPSB0aGlzLmdldENhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG5cdFx0aWYgKG1vZGlmeSkge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg1MTMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY29udGV4dDtcblx0fSxcblxuXHRzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0dGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cdH0sXG5cblx0Z2V0U291cmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2Uuc3JjIHx8IHRoaXMudG9EYXRhVVJMKCk7XG5cdH0sXG5cblx0c2V0U291cmNlOiBmdW5jdGlvbihzcmMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRpbWFnZTtcblxuXHRcdGZ1bmN0aW9uIGxvYWRlZCgpIHtcblx0XHRcdHZhciB2aWV3ID0gdGhhdC5nZXRWaWV3KCk7XG5cdFx0XHRpZiAodmlldykge1xuXHRcdFx0XHRwYXBlciA9IHZpZXcuX3Njb3BlO1xuXHRcdFx0XHR0aGF0LnNldEltYWdlKGltYWdlKTtcblx0XHRcdFx0dGhhdC5lbWl0KCdsb2FkJyk7XG5cdFx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0XHRpbWFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNyYykgfHwgbmV3IEltYWdlKCk7XG5cblx0XHRpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmIGltYWdlLm5hdHVyYWxIZWlnaHQpIHtcblx0XHRcdHNldFRpbWVvdXQobG9hZGVkLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tRXZlbnQuYWRkKGltYWdlLCB7XG5cdFx0XHRcdGxvYWQ6IGxvYWRlZFxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoIWltYWdlLnNyYylcblx0XHRcdFx0aW1hZ2Uuc3JjID0gc3JjO1xuXHRcdH1cblx0XHR0aGlzLnNldEltYWdlKGltYWdlKTtcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzIHx8IHRoaXMuX2ltYWdlO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRTdWJDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuXHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgcmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIGN0eC5jYW52YXM7XG5cdH0sXG5cblx0Z2V0U3ViUmFzdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRyYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyYXN0ZXIuc2V0Q2FudmFzKHRoaXMuZ2V0U3ViQ2FudmFzKHJlY3QpKTtcblx0XHRyYXN0ZXIudHJhbnNsYXRlKHJlY3QuZ2V0Q2VudGVyKCkuc3VidHJhY3QodGhpcy5nZXRTaXplKCkuZGl2aWRlKDIpKSk7XG5cdFx0cmFzdGVyLl9tYXRyaXgucHJlQ29uY2F0ZW5hdGUodGhpcy5fbWF0cml4KTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHR0b0RhdGFVUkw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzcmMgPSB0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZS5zcmM7XG5cdFx0aWYgKC9eZGF0YTovLnRlc3Qoc3JjKSlcblx0XHRcdHJldHVybiBzcmM7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG5cdFx0cmV0dXJuIGNhbnZhcyA/IGNhbnZhcy50b0RhdGFVUkwoKSA6IG51bGw7XG5cdH0sXG5cblx0ZHJhd0ltYWdlOiBmdW5jdGlvbihpbWFnZSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShpbWFnZSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0QXZlcmFnZUNvbG9yOiBmdW5jdGlvbihvYmplY3QpIHtcblx0XHR2YXIgYm91bmRzLCBwYXRoO1xuXHRcdGlmICghb2JqZWN0KSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUGF0aEl0ZW0pIHtcblx0XHRcdHBhdGggPSBvYmplY3Q7XG5cdFx0XHRib3VuZHMgPSBvYmplY3QuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3Qud2lkdGgpIHtcblx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0KTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdC54KSB7XG5cdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdC54IC0gMC41LCBvYmplY3QueSAtIDAuNSwgMSwgMSk7XG5cdFx0fVxuXHRcdHZhciBzYW1wbGVTaXplID0gMzIsXG5cdFx0XHR3aWR0aCA9IE1hdGgubWluKGJvdW5kcy53aWR0aCwgc2FtcGxlU2l6ZSksXG5cdFx0XHRoZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzYW1wbGVTaXplKTtcblx0XHR2YXIgY3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0O1xuXHRcdGlmICghY3R4KSB7XG5cdFx0XHRjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQgPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KFxuXHRcdFx0XHRcdG5ldyBTaXplKHNhbXBsZVNpemUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzYW1wbGVTaXplICsgMSwgc2FtcGxlU2l6ZSArIDEpO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4KClcblx0XHRcdFx0LnNjYWxlKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHQudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAocGF0aClcblx0XHRcdHBhdGguZHJhdyhjdHgsIG5ldyBCYXNlKHsgY2xpcDogdHJ1ZSwgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHR0aGlzLl9tYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuZ2V0RWxlbWVudCgpLFxuXHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMC41LCAwLjUsIE1hdGguY2VpbCh3aWR0aCksXG5cdFx0XHRcdE1hdGguY2VpbChoZWlnaHQpKS5kYXRhLFxuXHRcdFx0Y2hhbm5lbHMgPSBbMCwgMCwgMF0sXG5cdFx0XHR0b3RhbCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwaXhlbHMubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHR2YXIgYWxwaGEgPSBwaXhlbHNbaSArIDNdO1xuXHRcdFx0dG90YWwgKz0gYWxwaGE7XG5cdFx0XHRhbHBoYSAvPSAyNTU7XG5cdFx0XHRjaGFubmVsc1swXSArPSBwaXhlbHNbaV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzFdICs9IHBpeGVsc1tpICsgMV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzJdICs9IHBpeGVsc1tpICsgMl0gKiBhbHBoYTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspXG5cdFx0XHRjaGFubmVsc1tpXSAvPSB0b3RhbDtcblx0XHRyZXR1cm4gdG90YWwgPyBDb2xvci5yZWFkKGNoYW5uZWxzKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShwb2ludC54LCBwb2ludC55LCAxLCAxKS5kYXRhO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoJ3JnYicsIFtkYXRhWzBdIC8gMjU1LCBkYXRhWzFdIC8gMjU1LCBkYXRhWzJdIC8gMjU1XSxcblx0XHRcdFx0ZGF0YVszXSAvIDI1NSk7XG5cdH0sXG5cblx0c2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y29tcG9uZW50cyA9IGNvbG9yLl9jb252ZXJ0KCdyZ2InKSxcblx0XHRcdGFscGhhID0gY29sb3IuX2FscGhhLFxuXHRcdFx0Y3R4ID0gdGhpcy5nZXRDb250ZXh0KHRydWUpLFxuXHRcdFx0aW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKSxcblx0XHRcdGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHRkYXRhWzBdID0gY29tcG9uZW50c1swXSAqIDI1NTtcblx0XHRkYXRhWzFdID0gY29tcG9uZW50c1sxXSAqIDI1NTtcblx0XHRkYXRhWzJdID0gY29tcG9uZW50c1syXSAqIDI1NTtcblx0XHRkYXRhWzNdID0gYWxwaGEgIT0gbnVsbCA/IGFscGhhICogMjU1IDogMjU1O1xuXHRcdGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHJlY3QuaXNFbXB0eSgpKVxuXHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9LFxuXG5cdHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ3BpeGVsJywgdGhhdCwge1xuXHRcdFx0XHRvZmZzZXQ6IHBvaW50LmFkZCh0aGF0Ll9zaXplLmRpdmlkZSgyKSkucm91bmQoKSxcblx0XHRcdFx0Y29sb3I6IHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoYXQuZ2V0UGl4ZWwodGhpcy5vZmZzZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9vcGFjaXR5O1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShlbGVtZW50LFxuXHRcdFx0XHRcdC10aGlzLl9zaXplLndpZHRoIC8gMiwgLXRoaXMuX3NpemUuaGVpZ2h0IC8gMik7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxudmFyIFBsYWNlZFN5bWJvbCA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGxhY2VkU3ltYm9sJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc0dldHRlcjogeyBnZXRCb3VuZHM6ICdnZXRTdHJva2VCb3VuZHMnIH0sXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHN5bWJvbDogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBsYWNlZFN5bWJvbChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZzAsXG5cdFx0XHRcdGFyZzEgIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKVxuXHRcdFx0dGhpcy5zZXRTeW1ib2woYXJnMCBpbnN0YW5jZW9mIFN5bWJvbCA/IGFyZzAgOiBuZXcgU3ltYm9sKGFyZzApKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbCA9PT0gaXRlbS5fc3ltYm9sO1xuXHR9LFxuXG5cdGdldFN5bWJvbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbDtcblx0fSxcblxuXHRzZXRTeW1ib2w6IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdHRoaXMuX3N5bWJvbCA9IHN5bWJvbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBQbGFjZWRTeW1ib2woSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U3ltYm9sKHRoaXMuX3N5bWJvbCk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5pc0VtcHR5KCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSkge1xuXHRcdHZhciBkZWZpbml0aW9uID0gdGhpcy5zeW1ib2wuX2RlZmluaXRpb247XG5cdFx0cmV0dXJuIGRlZmluaXRpb24uX2dldENhY2hlZEJvdW5kcyhnZXR0ZXIsXG5cdFx0XHRcdG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oZGVmaW5pdGlvbi5fbWF0cml4KSwgY2FjaGVJdGVtKTtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5faGl0VGVzdChwb2ludCwgb3B0aW9ucyk7XG5cdFx0aWYgKHJlcylcblx0XHRcdHJlcy5pdGVtID0gdGhpcztcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dGhpcy5zeW1ib2wuX2RlZmluaXRpb24uZHJhdyhjdHgsIHBhcmFtKTtcblx0fVxuXG59KTtcblxudmFyIEhpdFJlc3VsdCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnSGl0UmVzdWx0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBIaXRSZXN1bHQodHlwZSwgaXRlbSwgdmFsdWVzKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLml0ZW0gPSBpdGVtO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdHZhbHVlcy5lbnVtZXJhYmxlID0gdHJ1ZTtcblx0XHRcdHRoaXMuaW5qZWN0KHZhbHVlcyk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRnZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEJhc2Uoe1xuXHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHR0b2xlcmFuY2U6IHBhcGVyLnNldHRpbmdzLmhpdFRvbGVyYW5jZSxcblx0XHRcdFx0ZmlsbDogIW9wdGlvbnMsXG5cdFx0XHRcdHN0cm9rZTogIW9wdGlvbnMsXG5cdFx0XHRcdHNlZ21lbnRzOiAhb3B0aW9ucyxcblx0XHRcdFx0aGFuZGxlczogZmFsc2UsXG5cdFx0XHRcdGVuZHM6IGZhbHNlLFxuXHRcdFx0XHRjZW50ZXI6IGZhbHNlLFxuXHRcdFx0XHRib3VuZHM6IGZhbHNlLFxuXHRcdFx0XHRndWlkZXM6IGZhbHNlLFxuXHRcdFx0XHRzZWxlY3RlZDogZmFsc2Vcblx0XHRcdH0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTZWdtZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTZWdtZW50Jyxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHBvaW50LCBoYW5kbGVJbiwgaGFuZGxlT3V0O1xuXHRcdGlmIChjb3VudCA9PT0gMCkge1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcwLnBvaW50KSB7XG5cdFx0XHRcdHBvaW50ID0gYXJnMC5wb2ludDtcblx0XHRcdFx0aGFuZGxlSW4gPSBhcmcwLmhhbmRsZUluO1xuXHRcdFx0XHRoYW5kbGVPdXQgPSBhcmcwLmhhbmRsZU91dDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50ID0gYXJnMDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAyICYmIHR5cGVvZiBhcmcwID09PSAnbnVtYmVyJykge1xuXHRcdFx0cG9pbnQgPSBhcmd1bWVudHM7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA8PSAzKSB7XG5cdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHRoYW5kbGVJbiA9IGFyZzE7XG5cdFx0XHRoYW5kbGVPdXQgPSBhcmcyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb2ludCA9IGFyZzAgIT09IHVuZGVmaW5lZCA/IFsgYXJnMCwgYXJnMSBdIDogbnVsbDtcblx0XHRcdGhhbmRsZUluID0gYXJnMiAhPT0gdW5kZWZpbmVkID8gWyBhcmcyLCBhcmczIF0gOiBudWxsO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnNCAhPT0gdW5kZWZpbmVkID8gWyBhcmc0LCBhcmc1IF0gOiBudWxsO1xuXHRcdH1cblx0XHRuZXcgU2VnbWVudFBvaW50KHBvaW50LCB0aGlzLCAnX3BvaW50Jyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVJbiwgdGhpcywgJ19oYW5kbGVJbicpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlT3V0LCB0aGlzLCAnX2hhbmRsZU91dCcpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5pc0xpbmVhcigpID8gdGhpcy5fcG9pbnRcblx0XHRcdFx0OiBbdGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmU7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dClcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cGF0aC5fY2hhbmdlZCgyNSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkgJiYgdGhpcy5faGFuZGxlT3V0LmlzWmVybygpO1xuXHR9LFxuXG5cdHNldExpbmVhcjogZnVuY3Rpb24obGluZWFyKSB7XG5cdFx0aWYgKGxpbmVhcikge1xuXHRcdFx0dGhpcy5faGFuZGxlSW4uc2V0KDAsIDApO1xuXHRcdFx0dGhpcy5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdH1cblx0fSxcblxuXHRpc0NvbGluZWFyOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0dmFyIG5leHQxID0gdGhpcy5nZXROZXh0KCksXG5cdFx0XHRuZXh0MiA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgbmV4dDEuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdCYmIHNlZ21lbnQuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBuZXh0Mi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0JiYgbmV4dDEuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KS5pc0NvbGluZWFyKFxuXHRcdFx0XHRcdG5leHQyLl9wb2ludC5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZXYgPSB0aGlzLmdldFByZXZpb3VzKCksXG5cdFx0XHRuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG5cdFx0cmV0dXJuIHByZXYuX2hhbmRsZU91dC5pc1plcm8oKSAmJiB0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0JiYgdGhpcy5faGFuZGxlT3V0LmlzWmVybygpICYmIG5leHQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHQmJiB0aGlzLl9wb2ludC5zdWJ0cmFjdChwcmV2Ll9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdG5leHQuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSk7XG5cdH0sXG5cblx0aXNBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCksXG5cdFx0XHRoYW5kbGUxID0gdGhpcy5faGFuZGxlT3V0LFxuXHRcdFx0aGFuZGxlMiA9IG5leHQuX2hhbmRsZUluLFxuXHRcdFx0a2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cdFx0aWYgKGhhbmRsZTEuaXNPcnRob2dvbmFsKGhhbmRsZTIpKSB7XG5cdFx0XHR2YXIgZnJvbSA9IHRoaXMuX3BvaW50LFxuXHRcdFx0XHR0byA9IG5leHQuX3BvaW50LFxuXHRcdFx0XHRjb3JuZXIgPSBuZXcgTGluZShmcm9tLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QoXG5cdFx0XHRcdFx0XHRuZXcgTGluZSh0bywgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuXHRcdFx0cmV0dXJuIGNvcm5lciAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTEuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdChmcm9tKS5nZXRMZW5ndGgoKSAtIGthcHBhKVxuXHRcdFx0XHQmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTIuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdCh0bykuZ2V0TGVuZ3RoKCkgLSBrYXBwYSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfc2VsZWN0aW9uU3RhdGU6IDAsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oX3BvaW50KSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGU7XG5cdFx0cmV0dXJuICFfcG9pbnQgPyAhIShzdGF0ZSAmIDcpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyAhIShzdGF0ZSAmIDQpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAhIShzdGF0ZSAmIDEpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gISEoc3RhdGUgJiAyKVxuXHRcdFx0OiBmYWxzZTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIF9wb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHNlbGVjdGVkID0gISFzZWxlY3RlZCxcblx0XHRcdHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGUsXG5cdFx0XHRvbGRTdGF0ZSA9IHN0YXRlLFxuXHRcdFx0ZmxhZyA9ICFfcG9pbnQgPyA3XG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX3BvaW50ID8gNFxuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/IDFcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gMlxuXHRcdFx0XHRcdDogMDtcblx0XHRpZiAoc2VsZWN0ZWQpIHtcblx0XHRcdHN0YXRlIHw9IGZsYWc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXRlICY9IH5mbGFnO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3Rpb25TdGF0ZSA9IHN0YXRlO1xuXHRcdGlmIChwYXRoICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFN0YXRlLCBzdGF0ZSk7XG5cdFx0XHRwYXRoLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24obWF0cml4LCBjb29yZHMsIGNoYW5nZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0aGFuZGxlSW4gPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlSW4gOiBudWxsLFxuXHRcdFx0aGFuZGxlT3V0ID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVPdXQgOiBudWxsLFxuXHRcdFx0eCA9IHBvaW50Ll94LFxuXHRcdFx0eSA9IHBvaW50Ll95LFxuXHRcdFx0aSA9IDI7XG5cdFx0Y29vcmRzWzBdID0geDtcblx0XHRjb29yZHNbMV0gPSB5O1xuXHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl95ICsgeTtcblx0XHR9XG5cdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCBpIC8gMik7XG5cdFx0XHR4ID0gY29vcmRzWzBdO1xuXHRcdFx0eSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChjaGFuZ2UpIHtcblx0XHRcdFx0cG9pbnQuX3ggPSB4O1xuXHRcdFx0XHRwb2ludC5feSA9IHk7XG5cdFx0XHRcdGkgID0gMjtcblx0XHRcdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9XG59KTtcblxudmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnRQb2ludChwb2ludCwgb3duZXIsIGtleSkge1xuXHRcdHZhciB4LCB5LCBzZWxlY3RlZDtcblx0XHRpZiAoIXBvaW50KSB7XG5cdFx0XHR4ID0geSA9IDA7XG5cdFx0fSBlbHNlIGlmICgoeCA9IHBvaW50WzBdKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR5ID0gcG9pbnRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwdCA9IHBvaW50O1xuXHRcdFx0aWYgKCh4ID0gcHQueCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0eCA9IHB0Lng7XG5cdFx0XHR9XG5cdFx0XHR5ID0gcHQueTtcblx0XHRcdHNlbGVjdGVkID0gcHQuc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0b3duZXJba2V5XSA9IHRoaXM7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcixcblx0XHRcdHggPSBmLm51bWJlcih0aGlzLl94KSxcblx0XHRcdHkgPSBmLm51bWJlcih0aGlzLl95KTtcblx0XHRyZXR1cm4gdGhpcy5pc1NlbGVjdGVkKClcblx0XHRcdFx0PyB7IHg6IHgsIHk6IHksIHNlbGVjdGVkOiB0cnVlIH1cblx0XHRcdFx0OiBbeCwgeV07XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuX3gpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5feSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRoaXMpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vd25lci5pc1NlbGVjdGVkKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGNvdW50ID09PSAzKSB7XG5cdFx0XHR0aGlzLl9wYXRoID0gYXJnMDtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gYXJnMTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gYXJnMjtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KCk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KCk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQxKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50Mik7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChhcmcwKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoYXJnMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwb2ludDEsIGhhbmRsZTEsIGhhbmRsZTIsIHBvaW50Mjtcblx0XHRcdGlmIChjb3VudCA9PT0gNCkge1xuXHRcdFx0XHRwb2ludDEgPSBhcmcwO1xuXHRcdFx0XHRoYW5kbGUxID0gYXJnMTtcblx0XHRcdFx0aGFuZGxlMiA9IGFyZzI7XG5cdFx0XHRcdHBvaW50MiA9IGFyZzM7XG5cdFx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA4KSB7XG5cdFx0XHRcdHBvaW50MSA9IFthcmcwLCBhcmcxXTtcblx0XHRcdFx0cG9pbnQyID0gW2FyZzYsIGFyZzddO1xuXHRcdFx0XHRoYW5kbGUxID0gW2FyZzIgLSBhcmcwLCBhcmczIC0gYXJnMV07XG5cdFx0XHRcdGhhbmRsZTIgPSBbYXJnNCAtIGFyZzYsIGFyZzUgLSBhcmc3XTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQocG9pbnQxLCBudWxsLCBoYW5kbGUxKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQocG9pbnQyLCBoYW5kbGUyLCBudWxsKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRnZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRTZWdtZW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDI7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0Z2V0TmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50MSgpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0UG9pbnQyKCkuaXNTZWxlY3RlZCgpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHRoaXMuZ2V0UG9pbnQxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRQb2ludDIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVzOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0VmFsdWVzKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50MiwgbWF0cml4KTtcblx0fSxcblxuXHRnZXRQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpXG5cdFx0XHRwb2ludHMucHVzaChuZXcgUG9pbnQoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKSk7XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5pc0xpbmVhcigpXG5cdFx0XHRcdD8gdGhpcy5fc2VnbWVudDIuX3BvaW50LmdldERpc3RhbmNlKHRoaXMuX3NlZ21lbnQxLl9wb2ludClcblx0XHRcdFx0OiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgMCwgMSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEFyZWEodGhpcy5nZXRWYWx1ZXMoKSk7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKEN1cnZlLmdldFBhcnQodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pKTtcblx0fSxcblxuXHRnZXRQYXJ0TGVuZ3RoOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHQmJiB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCk7XG5cdH0sXG5cblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0xpbmVhcigpICYmIE51bWVyaWNhbC5pc1plcm8oXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9wb2ludC5feSAtIHRoaXMuX3NlZ21lbnQyLl9wb2ludC5feSk7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24oY3VydmUpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0SW50ZXJzZWN0aW9ucyh0aGlzLmdldFZhbHVlcygpLCBjdXJ2ZS5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0dGhpcywgY3VydmUsIFtdKTtcblx0fSxcblxuXHRfZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0cmV0dXJuIGlzUGFyYW1ldGVyXG5cdFx0XHRcdD8gb2Zmc2V0XG5cdFx0XHRcdDogb2Zmc2V0ICYmIG9mZnNldC5jdXJ2ZSA9PT0gdGhpc1xuXHRcdFx0XHRcdD8gb2Zmc2V0LnBhcmFtZXRlclxuXHRcdFx0XHRcdDogb2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgaXNQYXJhbWV0ZXIgPT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0PyAwLjVcblx0XHRcdFx0XHRcdDogdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQsIDApO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlciwgaWdub3JlTGluZWFyKSB7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuX2dldFBhcmFtZXRlcihvZmZzZXQsIGlzUGFyYW1ldGVyKSxcblx0XHRcdHRvbGVyYW5jZSA9IDAuMDAwMDEsXG5cdFx0XHRyZXMgPSBudWxsO1xuXHRcdGlmIChwYXJhbWV0ZXIgPiB0b2xlcmFuY2UgJiYgcGFyYW1ldGVyIDwgMSAtIHRvbGVyYW5jZSkge1xuXHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHRoaXMuZ2V0VmFsdWVzKCksIHBhcmFtZXRlciksXG5cdFx0XHRcdGlzTGluZWFyID0gaWdub3JlTGluZWFyID8gZmFsc2UgOiB0aGlzLmlzTGluZWFyKCksXG5cdFx0XHRcdGxlZnQgPSBwYXJ0c1swXSxcblx0XHRcdFx0cmlnaHQgPSBwYXJ0c1sxXTtcblxuXHRcdFx0aWYgKCFpc0xpbmVhcikge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChsZWZ0WzJdIC0gbGVmdFswXSxcblx0XHRcdFx0XHRcdGxlZnRbM10gLSBsZWZ0WzFdKTtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChyaWdodFs0XSAtIHJpZ2h0WzZdLFxuXHRcdFx0XHRcdFx0cmlnaHRbNV0gLSByaWdodFs3XSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB4ID0gbGVmdFs2XSwgeSA9IGxlZnRbN10sXG5cdFx0XHRcdHNlZ21lbnQgPSBuZXcgU2VnbWVudChuZXcgUG9pbnQoeCwgeSksXG5cdFx0XHRcdFx0XHQhaXNMaW5lYXIgJiYgbmV3IFBvaW50KGxlZnRbNF0gLSB4LCBsZWZ0WzVdIC0geSksXG5cdFx0XHRcdFx0XHQhaXNMaW5lYXIgJiYgbmV3IFBvaW50KHJpZ2h0WzJdIC0geCwgcmlnaHRbM10gLSB5KSk7XG5cblx0XHRcdGlmICh0aGlzLl9wYXRoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zZWdtZW50MS5faW5kZXggPiAwICYmIHRoaXMuX3NlZ21lbnQyLl9pbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3BhdGguYWRkKHNlZ21lbnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3BhdGguaW5zZXJ0KHRoaXMuX3NlZ21lbnQyLl9pbmRleCwgc2VnbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzID0gdGhpcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlbmQgPSB0aGlzLl9zZWdtZW50Mjtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuXHRcdFx0XHRyZXMgPSBuZXcgQ3VydmUoc2VnbWVudCwgZW5kKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoXG5cdFx0XHQ/IHRoaXMuX3BhdGguc3BsaXQodGhpcy5fc2VnbWVudDEuX2luZGV4LFxuXHRcdFx0XHRcdHRoaXMuX2dldFBhcmFtZXRlcihvZmZzZXQsIGlzUGFyYW1ldGVyKSlcblx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2UoKSwgdGhpcy5fc2VnbWVudDEucmV2ZXJzZSgpKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZW1vdmVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3BhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Mi5faGFuZGxlT3V0O1xuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnQyLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHJlbW92ZWQpXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGhhbmRsZU91dC54LCBoYW5kbGVPdXQueSk7XG5cdFx0fVxuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Mik7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50MTogJyArIHRoaXMuX3NlZ21lbnQxLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTE6ICcgKyB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0KTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuXHRcdHBhcnRzLnB1c2goJ3BvaW50MjogJyArIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KSB7XG5cdFx0dmFyIHAxID0gc2VnbWVudDEuX3BvaW50LFxuXHRcdFx0aDEgPSBzZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0aDIgPSBzZWdtZW50Mi5faGFuZGxlSW4sXG5cdFx0XHRwMiA9IHNlZ21lbnQyLl9wb2ludCxcblx0XHRcdHZhbHVlcyA9IFtcblx0XHRcdFx0cDEuX3gsIHAxLl95LFxuXHRcdFx0XHRwMS5feCArIGgxLl94LCBwMS5feSArIGgxLl95LFxuXHRcdFx0XHRwMi5feCArIGgyLl94LCBwMi5feSArIGgyLl95LFxuXHRcdFx0XHRwMi5feCwgcDIuX3lcblx0XHRcdF07XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXModmFsdWVzLCB2YWx1ZXMsIDQpO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKHYsIHQsIHR5cGUpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblx0XHRcdHRvbGVyYW5jZSA9IDAuMDAwMDEsXG5cdFx0XHR4LCB5O1xuXG5cdFx0aWYgKHR5cGUgPT09IDAgJiYgKHQgPCB0b2xlcmFuY2UgfHwgdCA+IDEgLSB0b2xlcmFuY2UpKSB7XG5cdFx0XHR2YXIgaXNaZXJvID0gdCA8IHRvbGVyYW5jZTtcblx0XHRcdHggPSBpc1plcm8gPyBwMXggOiBwMng7XG5cdFx0XHR5ID0gaXNaZXJvID8gcDF5IDogcDJ5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY3ggPSAzICogKGMxeCAtIHAxeCksXG5cdFx0XHRcdGJ4ID0gMyAqIChjMnggLSBjMXgpIC0gY3gsXG5cdFx0XHRcdGF4ID0gcDJ4IC0gcDF4IC0gY3ggLSBieCxcblxuXHRcdFx0XHRjeSA9IDMgKiAoYzF5IC0gcDF5KSxcblx0XHRcdFx0YnkgPSAzICogKGMyeSAtIGMxeSkgLSBjeSxcblx0XHRcdFx0YXkgPSBwMnkgLSBwMXkgLSBjeSAtIGJ5O1xuXHRcdFx0aWYgKHR5cGUgPT09IDApIHtcblx0XHRcdFx0eCA9ICgoYXggKiB0ICsgYngpICogdCArIGN4KSAqIHQgKyBwMXg7XG5cdFx0XHRcdHkgPSAoKGF5ICogdCArIGJ5KSAqIHQgKyBjeSkgKiB0ICsgcDF5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHQgPCB0b2xlcmFuY2UgJiYgYzF4ID09PSBwMXggJiYgYzF5ID09PSBwMXlcblx0XHRcdFx0XHRcdHx8IHQgPiAxIC0gdG9sZXJhbmNlICYmIGMyeCA9PT0gcDJ4ICYmIGMyeSA9PT0gcDJ5KSB7XG5cdFx0XHRcdFx0eCA9IGMyeCAtIGMxeDtcblx0XHRcdFx0XHR5ID0gYzJ5IC0gYzF5O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQgPCB0b2xlcmFuY2UpIHtcblx0XHRcdFx0XHR4ID0gY3g7XG5cdFx0XHRcdFx0eSA9IGN5O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQgPiAxIC0gdG9sZXJhbmNlKSB7XG5cdFx0XHRcdFx0eCA9IDMgKiAocDJ4IC0gYzJ4KTtcblx0XHRcdFx0XHR5ID0gMyAqIChwMnkgLSBjMnkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHggPSAoMyAqIGF4ICogdCArIDIgKiBieCkgKiB0ICsgY3g7XG5cdFx0XHRcdFx0eSA9ICgzICogYXkgKiB0ICsgMiAqIGJ5KSAqIHQgKyBjeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdHZhciB4MiA9IDYgKiBheCAqIHQgKyAyICogYngsXG5cdFx0XHRcdFx0XHR5MiA9IDYgKiBheSAqIHQgKyAyICogYnk7XG5cdFx0XHRcdFx0cmV0dXJuICh4ICogeTIgLSB5ICogeDIpIC8gTWF0aC5wb3coeCAqIHggKyB5ICogeSwgMyAvIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlID09PSAyID8gbmV3IFBvaW50KHksIC14KSA6IG5ldyBQb2ludCh4LCB5KTtcblx0fSxcblxuXHRzdWJkaXZpZGU6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcblx0XHRpZiAodCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dCA9IDAuNTtcblx0XHR2YXIgdSA9IDEgLSB0LFxuXHRcdFx0cDN4ID0gdSAqIHAxeCArIHQgKiBjMXgsIHAzeSA9IHUgKiBwMXkgKyB0ICogYzF5LFxuXHRcdFx0cDR4ID0gdSAqIGMxeCArIHQgKiBjMngsIHA0eSA9IHUgKiBjMXkgKyB0ICogYzJ5LFxuXHRcdFx0cDV4ID0gdSAqIGMyeCArIHQgKiBwMngsIHA1eSA9IHUgKiBjMnkgKyB0ICogcDJ5LFxuXHRcdFx0cDZ4ID0gdSAqIHAzeCArIHQgKiBwNHgsIHA2eSA9IHUgKiBwM3kgKyB0ICogcDR5LFxuXHRcdFx0cDd4ID0gdSAqIHA0eCArIHQgKiBwNXgsIHA3eSA9IHUgKiBwNHkgKyB0ICogcDV5LFxuXHRcdFx0cDh4ID0gdSAqIHA2eCArIHQgKiBwN3gsIHA4eSA9IHUgKiBwNnkgKyB0ICogcDd5O1xuXHRcdHJldHVybiBbXG5cdFx0XHRbcDF4LCBwMXksIHAzeCwgcDN5LCBwNngsIHA2eSwgcDh4LCBwOHldLFxuXHRcdFx0W3A4eCwgcDh5LCBwN3gsIHA3eSwgcDV4LCBwNXksIHAyeCwgcDJ5XVxuXHRcdF07XG5cdH0sXG5cblx0c29sdmVDdWJpYzogZnVuY3Rpb24gKHYsIGNvb3JkLCB2YWwsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdHZhciBwMSA9IHZbY29vcmRdLFxuXHRcdFx0YzEgPSB2W2Nvb3JkICsgMl0sXG5cdFx0XHRjMiA9IHZbY29vcmQgKyA0XSxcblx0XHRcdHAyID0gdltjb29yZCArIDZdLFxuXHRcdFx0YyA9IDMgKiAoYzEgLSBwMSksXG5cdFx0XHRiID0gMyAqIChjMiAtIGMxKSAtIGMsXG5cdFx0XHRhID0gcDIgLSBwMSAtIGMgLSBiO1xuXHRcdHJldHVybiBOdW1lcmljYWwuc29sdmVDdWJpYyhhLCBiLCBjLCBwMSAtIHZhbCwgcm9vdHMsIG1pbiwgbWF4KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJPZjogZnVuY3Rpb24odiwgeCwgeSkge1xuXHRcdHZhciB0b2xlcmFuY2UgPSAwLjAwMDAxO1xuXHRcdGlmIChNYXRoLmFicyh2WzBdIC0geCkgPCB0b2xlcmFuY2UgJiYgTWF0aC5hYnModlsxXSAtIHkpIDwgdG9sZXJhbmNlKVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0aWYgKE1hdGguYWJzKHZbNl0gLSB4KSA8IHRvbGVyYW5jZSAmJiBNYXRoLmFicyh2WzddIC0geSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRyZXR1cm4gMTtcblx0XHR2YXIgdHhzID0gW10sXG5cdFx0XHR0eXMgPSBbXSxcblx0XHRcdHN4ID0gQ3VydmUuc29sdmVDdWJpYyh2LCAwLCB4LCB0eHMsIDAsIDEpLFxuXHRcdFx0c3kgPSBDdXJ2ZS5zb2x2ZUN1YmljKHYsIDEsIHksIHR5cywgMCwgMSksXG5cdFx0XHR0eCwgdHk7XG5cdFx0Zm9yICh2YXIgY3ggPSAwOyAgc3ggPT0gLTEgfHwgY3ggPCBzeDspIHtcblx0XHRcdGlmIChzeCA9PSAtMSB8fCAodHggPSB0eHNbY3grK10pID49IDAgJiYgdHggPD0gMSkge1xuXHRcdFx0XHRmb3IgKHZhciBjeSA9IDA7IHN5ID09IC0xIHx8IGN5IDwgc3k7KSB7XG5cdFx0XHRcdFx0aWYgKHN5ID09IC0xIHx8ICh0eSA9IHR5c1tjeSsrXSkgPj0gMCAmJiB0eSA8PSAxKSB7XG5cdFx0XHRcdFx0XHRpZiAoc3ggPT0gLTEpIHR4ID0gdHk7XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChzeSA9PSAtMSkgdHkgPSB0eDtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyh0eCAtIHR5KSA8IHRvbGVyYW5jZSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuICh0eCArIHR5KSAqIDAuNTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN4ID09IC0xKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRQYXJ0OiBmdW5jdGlvbih2LCBmcm9tLCB0bykge1xuXHRcdGlmIChmcm9tID4gMClcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgZnJvbSlbMV07XG5cdFx0aWYgKHRvIDwgMSlcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgKHRvIC0gZnJvbSkgLyAoMSAtIGZyb20pKVswXTtcblx0XHRyZXR1cm4gdjtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24odikge1xuXHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdHJldHVybiBpc1plcm8odlswXSAtIHZbMl0pICYmIGlzWmVybyh2WzFdIC0gdlszXSlcblx0XHRcdFx0JiYgaXNaZXJvKHZbNF0gLSB2WzZdKSAmJiBpc1plcm8odls1XSAtIHZbN10pO1xuXHR9LFxuXG5cdGlzRmxhdEVub3VnaDogZnVuY3Rpb24odiwgdG9sZXJhbmNlKSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR1eCA9IDMgKiBjMXggLSAyICogcDF4IC0gcDJ4LFxuXHRcdFx0dXkgPSAzICogYzF5IC0gMiAqIHAxeSAtIHAyeSxcblx0XHRcdHZ4ID0gMyAqIGMyeCAtIDIgKiBwMnggLSBwMXgsXG5cdFx0XHR2eSA9IDMgKiBjMnkgLSAyICogcDJ5IC0gcDF5O1xuXHRcdHJldHVybiBNYXRoLm1heCh1eCAqIHV4LCB2eCAqIHZ4KSArIE1hdGgubWF4KHV5ICogdXksIHZ5ICogdnkpXG5cdFx0XHRcdDwgMTAgKiB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24odikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddO1xuXHRcdHJldHVybiAoICAzLjAgKiBjMXkgKiBwMXggLSAxLjUgKiBjMXkgKiBjMnhcblx0XHRcdFx0LSAxLjUgKiBjMXkgKiBwMnggLSAzLjAgKiBwMXkgKiBjMXhcblx0XHRcdFx0LSAxLjUgKiBwMXkgKiBjMnggLSAwLjUgKiBwMXkgKiBwMnhcblx0XHRcdFx0KyAxLjUgKiBjMnkgKiBwMXggKyAxLjUgKiBjMnkgKiBjMXhcblx0XHRcdFx0LSAzLjAgKiBjMnkgKiBwMnggKyAwLjUgKiBwMnkgKiBwMXhcblx0XHRcdFx0KyAxLjUgKiBwMnkgKiBjMXggKyAzLjAgKiBwMnkgKiBjMngpIC8gMTA7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbih2KSB7XG5cdFx0dmFyIG1pbiA9IHYuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSxcblx0XHRcdHJvb3RzID0gWzAsIDBdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKVxuXHRcdFx0Q3VydmUuX2FkZEJvdW5kcyh2W2ldLCB2W2kgKyAyXSwgdltpICsgNF0sIHZbaSArIDZdLFxuXHRcdFx0XHRcdGksIDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcblx0fSxcblxuXHRfYWRkQm91bmRzOiBmdW5jdGlvbih2MCwgdjEsIHYyLCB2MywgY29vcmQsIHBhZGRpbmcsIG1pbiwgbWF4LCByb290cykge1xuXHRcdGZ1bmN0aW9uIGFkZCh2YWx1ZSwgcGFkZGluZykge1xuXHRcdFx0dmFyIGxlZnQgPSB2YWx1ZSAtIHBhZGRpbmcsXG5cdFx0XHRcdHJpZ2h0ID0gdmFsdWUgKyBwYWRkaW5nO1xuXHRcdFx0aWYgKGxlZnQgPCBtaW5bY29vcmRdKVxuXHRcdFx0XHRtaW5bY29vcmRdID0gbGVmdDtcblx0XHRcdGlmIChyaWdodCA+IG1heFtjb29yZF0pXG5cdFx0XHRcdG1heFtjb29yZF0gPSByaWdodDtcblx0XHR9XG5cdFx0dmFyIGEgPSAzICogKHYxIC0gdjIpIC0gdjAgKyB2Myxcblx0XHRcdGIgPSAyICogKHYwICsgdjIpIC0gNCAqIHYxLFxuXHRcdFx0YyA9IHYxIC0gdjAsXG5cdFx0XHRjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cyksXG5cdFx0XHR0TWluID0gMC4wMDAwMSxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRhZGQodjMsIDApO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0dmFyIHQgPSByb290c1tpXSxcblx0XHRcdFx0dSA9IDEgLSB0O1xuXHRcdFx0aWYgKHRNaW4gPCB0ICYmIHQgPCB0TWF4KVxuXHRcdFx0XHRhZGQodSAqIHUgKiB1ICogdjBcblx0XHRcdFx0XHQrIDMgKiB1ICogdSAqIHQgKiB2MVxuXHRcdFx0XHRcdCsgMyAqIHUgKiB0ICogdCAqIHYyXG5cdFx0XHRcdFx0KyB0ICogdCAqIHQgKiB2Myxcblx0XHRcdFx0XHRwYWRkaW5nKTtcblx0XHR9XG5cdH1cbn19LCBCYXNlLmVhY2goWydnZXRCb3VuZHMnLCAnZ2V0U3Ryb2tlQm91bmRzJywgJ2dldEhhbmRsZUJvdW5kcycsICdnZXRSb3VnaEJvdW5kcyddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHRcdHRoaXMuX2JvdW5kcyA9IHt9O1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kc1tuYW1lXTtcblx0XHRcdGlmICghYm91bmRzKSB7XG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2JvdW5kc1tuYW1lXSA9IFBhdGhbbmFtZV0oW3RoaXMuX3NlZ21lbnQxLFxuXHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudDJdLCBmYWxzZSwgdGhpcy5fcGF0aC5nZXRTdHlsZSgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3VuZHMuY2xvbmUoKTtcblx0XHR9O1xuXHR9LFxue1xuXG59KSwgQmFzZS5lYWNoKFsnZ2V0UG9pbnQnLCAnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ10sXG5cdGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKTtcblx0XHRcdHJldHVybiBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIGlzUGFyYW1ldGVyXG5cdFx0XHRcdFx0PyBvZmZzZXQgOiBDdXJ2ZS5nZXRQYXJhbWV0ZXJBdCh2YWx1ZXMsIG9mZnNldCwgMCksIGluZGV4KTtcblx0XHR9O1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihwYXJhbWV0ZXIpIHtcblx0XHRcdHJldHVybiBDdXJ2ZS5ldmFsdWF0ZSh0aGlzLmdldFZhbHVlcygpLCBwYXJhbWV0ZXIsIGluZGV4KTtcblx0XHR9O1xuXHR9LFxue1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKG9mZnNldCwgc3RhcnQpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0UGFyYW1ldGVyQXQodGhpcy5nZXRWYWx1ZXMoKSwgb2Zmc2V0LCBzdGFydCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5nZXRWYWx1ZXMoKSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdGlmICghaXNQYXJhbWV0ZXIpXG5cdFx0XHRvZmZzZXQgPSB0aGlzLmdldFBhcmFtZXRlckF0KG9mZnNldCk7XG5cdFx0cmV0dXJuIG9mZnNldCA+PSAwICYmIG9mZnNldCA8PSAxICYmIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIG9mZnNldCk7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb25BdCh0aGlzLmdldFBhcmFtZXRlck9mKFBvaW50LnJlYWQoYXJndW1lbnRzKSksXG5cdFx0XHRcdHRydWUpO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0Y291bnQgPSAxMDAsXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5UID0gMDtcblxuXHRcdGZ1bmN0aW9uIHJlZmluZSh0KSB7XG5cdFx0XHRpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuXHRcdFx0XHR2YXIgZGlzdCA9IHBvaW50LmdldERpc3RhbmNlKFxuXHRcdFx0XHRcdFx0Q3VydmUuZXZhbHVhdGUodmFsdWVzLCB0LCAwKSwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChkaXN0IDwgbWluRGlzdCkge1xuXHRcdFx0XHRcdG1pbkRpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdG1pblQgPSB0O1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKylcblx0XHRcdHJlZmluZShpIC8gY291bnQpO1xuXG5cdFx0dmFyIHN0ZXAgPSAxIC8gKGNvdW50ICogMik7XG5cdFx0d2hpbGUgKHN0ZXAgPiAwLjAwMDAxKSB7XG5cdFx0XHRpZiAoIXJlZmluZShtaW5UIC0gc3RlcCkgJiYgIXJlZmluZShtaW5UICsgc3RlcCkpXG5cdFx0XHRcdHN0ZXAgLz0gMjtcblx0XHR9XG5cdFx0dmFyIHB0ID0gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCBtaW5ULCAwKTtcblx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgbWluVCwgcHQsIG51bGwsIG51bGwsIG51bGwsXG5cdFx0XHRcdHBvaW50LmdldERpc3RhbmNlKHB0KSk7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKS5nZXRQb2ludCgpO1xuXHR9XG5cbn0pLFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldExlbmd0aEludGVncmFuZCh2KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cblx0XHRcdGF4ID0gOSAqIChjMXggLSBjMngpICsgMyAqIChwMnggLSBwMXgpLFxuXHRcdFx0YnggPSA2ICogKHAxeCArIGMyeCkgLSAxMiAqIGMxeCxcblx0XHRcdGN4ID0gMyAqIChjMXggLSBwMXgpLFxuXG5cdFx0XHRheSA9IDkgKiAoYzF5IC0gYzJ5KSArIDMgKiAocDJ5IC0gcDF5KSxcblx0XHRcdGJ5ID0gNiAqIChwMXkgKyBjMnkpIC0gMTIgKiBjMXksXG5cdFx0XHRjeSA9IDMgKiAoYzF5IC0gcDF5KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuXHRcdFx0XHRkeSA9IChheSAqIHQgKyBieSkgKiB0ICsgY3k7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SXRlcmF0aW9ucyhhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KDIsIE1hdGgubWluKDE2LCBNYXRoLmNlaWwoTWF0aC5hYnMoYiAtIGEpICogMzIpKSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHN0YXRpY3M6IHRydWUsXG5cblx0XHRnZXRMZW5ndGg6IGZ1bmN0aW9uKHYsIGEsIGIpIHtcblx0XHRcdGlmIChhID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGEgPSAwO1xuXHRcdFx0aWYgKGIgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YiA9IDE7XG5cdFx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRcdGlmIChhID09PSAwICYmIGIgPT09IDFcblx0XHRcdFx0XHQmJiBpc1plcm8odlswXSAtIHZbMl0pICYmIGlzWmVybyh2WzFdIC0gdlszXSlcblx0XHRcdFx0XHQmJiBpc1plcm8odls2XSAtIHZbNF0pICYmIGlzWmVybyh2WzddIC0gdls1XSkpIHtcblx0XHRcdFx0dmFyIGR4ID0gdls2XSAtIHZbMF0sXG5cdFx0XHRcdFx0ZHkgPSB2WzddIC0gdlsxXTtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodik7XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmludGVncmF0ZShkcywgYSwgYiwgZ2V0SXRlcmF0aW9ucyhhLCBiKSk7XG5cdFx0fSxcblxuXHRcdGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbih2LCBvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0c3RhcnQgPSBvZmZzZXQgPCAwID8gMSA6IDBcblx0XHRcdGlmIChvZmZzZXQgPT09IDApXG5cdFx0XHRcdHJldHVybiBzdGFydDtcblx0XHRcdHZhciBmb3J3YXJkID0gb2Zmc2V0ID4gMCxcblx0XHRcdFx0YSA9IGZvcndhcmQgPyBzdGFydCA6IDAsXG5cdFx0XHRcdGIgPSBmb3J3YXJkID8gMSA6IHN0YXJ0LFxuXHRcdFx0XHRkcyA9IGdldExlbmd0aEludGVncmFuZCh2KSxcblx0XHRcdFx0cmFuZ2VMZW5ndGggPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBhLCBiLFxuXHRcdFx0XHRcdFx0Z2V0SXRlcmF0aW9ucyhhLCBiKSk7XG5cdFx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0KSA+PSByYW5nZUxlbmd0aClcblx0XHRcdFx0cmV0dXJuIGZvcndhcmQgPyBiIDogYTtcblx0XHRcdHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0ZnVuY3Rpb24gZih0KSB7XG5cdFx0XHRcdGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCxcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMTYsXG5cdFx0XHRcdFx0MC4wMDAwMSk7XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGN1cnZlMSwgdDEsIHBvaW50MSwgY3VydmUyLCB0Mixcblx0XHRcdHBvaW50Mikge1xuXHRcdHZhciBsb2MgPSBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZTEsIHQxLCBwb2ludDEsIGN1cnZlMiwgdDIsIHBvaW50Mik7XG5cdFx0aWYgKCFpbmNsdWRlIHx8IGluY2x1ZGUobG9jKSlcblx0XHRcdGxvY2F0aW9ucy5wdXNoKGxvYyk7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0dE1pbiwgdE1heCwgdU1pbiwgdU1heCwgb2xkVERpZmYsIHJldmVyc2UsIHJlY3Vyc2lvbikge1xuXHRcdGlmIChyZWN1cnNpb24gPiAyMClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcTB4ID0gdjJbMF0sIHEweSA9IHYyWzFdLCBxM3ggPSB2Mls2XSwgcTN5ID0gdjJbN10sXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAxLFxuXHRcdFx0aHVsbEVwc2lsb24gPSAxZS05LFxuXHRcdFx0Z2V0U2lnbmVkRGlzdGFuY2UgPSBMaW5lLmdldFNpZ25lZERpc3RhbmNlLFxuXHRcdFx0ZDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzJdLCB2MlszXSkgfHwgMCxcblx0XHRcdGQyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2Mls0XSwgdjJbNV0pIHx8IDAsXG5cdFx0XHRmYWN0b3IgPSBkMSAqIGQyID4gMCA/IDMgLyA0IDogNCAvIDksXG5cdFx0XHRkTWluID0gZmFjdG9yICogTWF0aC5taW4oMCwgZDEsIGQyKSxcblx0XHRcdGRNYXggPSBmYWN0b3IgKiBNYXRoLm1heCgwLCBkMSwgZDIpLFxuXHRcdFx0ZHAwID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVswXSwgdjFbMV0pLFxuXHRcdFx0ZHAxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVsyXSwgdjFbM10pLFxuXHRcdFx0ZHAyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs0XSwgdjFbNV0pLFxuXHRcdFx0ZHAzID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs2XSwgdjFbN10pLFxuXHRcdFx0dE1pbk5ldywgdE1heE5ldywgdERpZmY7XG5cdFx0aWYgKHEweCA9PT0gcTN4ICYmIHVNYXggLSB1TWluIDw9IGh1bGxFcHNpbG9uICYmIHJlY3Vyc2lvbiA+IDMpIHtcblx0XHRcdHRNaW5OZXcgPSAodE1heCArIHRNaW4pIC8gMjtcblx0XHRcdHRNYXhOZXcgPSB0TWluTmV3O1xuXHRcdFx0dERpZmYgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaHVsbCA9IGdldENvbnZleEh1bGwoZHAwLCBkcDEsIGRwMiwgZHAzKSxcblx0XHRcdFx0dG9wID0gaHVsbFswXSxcblx0XHRcdFx0Ym90dG9tID0gaHVsbFsxXSxcblx0XHRcdFx0dE1pbkNsaXAsIHRNYXhDbGlwO1xuXHRcdFx0dE1pbkNsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCk7XG5cdFx0XHR0b3AucmV2ZXJzZSgpO1xuXHRcdFx0Ym90dG9tLnJldmVyc2UoKTtcblx0XHRcdHRNYXhDbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpO1xuXHRcdFx0aWYgKHRNaW5DbGlwID09IG51bGwgfHwgdE1heENsaXAgPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0djEgPSBDdXJ2ZS5nZXRQYXJ0KHYxLCB0TWluQ2xpcCwgdE1heENsaXApO1xuXHRcdFx0dERpZmYgPSB0TWF4Q2xpcCAtIHRNaW5DbGlwO1xuXHRcdFx0dE1pbk5ldyA9IHRNYXggKiB0TWluQ2xpcCArIHRNaW4gKiAoMSAtIHRNaW5DbGlwKTtcblx0XHRcdHRNYXhOZXcgPSB0TWF4ICogdE1heENsaXAgKyB0TWluICogKDEgLSB0TWF4Q2xpcCk7XG5cdFx0fVxuXHRcdGlmIChvbGRURGlmZiA+IDAuOCAmJiB0RGlmZiA+IDAuOCkge1xuXHRcdFx0aWYgKHRNYXhOZXcgLSB0TWluTmV3ID4gdU1heCAtIHVNaW4pIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYxLCAwLjUpLFxuXHRcdFx0XHRcdHQgPSB0TWluTmV3ICsgKHRNYXhOZXcgLSB0TWluTmV3KSAvIDI7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2MiwgcGFydHNbMF0sIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdE1pbk5ldywgdCwgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2MiwgcGFydHNbMV0sIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdCwgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYyLCAwLjUpLFxuXHRcdFx0XHRcdHQgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRwYXJ0c1swXSwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRwYXJ0c1sxXSwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dCwgdU1heCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoTWF0aC5tYXgodU1heCAtIHVNaW4sIHRNYXhOZXcgLSB0TWluTmV3KSA8IHRvbGVyYW5jZSkge1xuXHRcdFx0dmFyIHQxID0gdE1pbk5ldyArICh0TWF4TmV3IC0gdE1pbk5ldykgLyAyLFxuXHRcdFx0XHR0MiA9IHVNaW4gKyAodU1heCAtIHVNaW4pIC8gMjtcblx0XHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGN1cnZlMiwgdDIsIEN1cnZlLmV2YWx1YXRlKHYyLCB0MiwgMCksXG5cdFx0XHRcdFx0XHRjdXJ2ZTEsIHQxLCBDdXJ2ZS5ldmFsdWF0ZSh2MSwgdDEsIDApKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGN1cnZlMSwgdDEsIEN1cnZlLmV2YWx1YXRlKHYxLCB0MSwgMCksXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5ldmFsdWF0ZSh2MiwgdDIsIDApKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYyLCB2MSwgY3VydmUyLCBjdXJ2ZTEsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHR1TWluLCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsICsrcmVjdXJzaW9uKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb252ZXhIdWxsKGRxMCwgZHExLCBkcTIsIGRxMykge1xuXHRcdHZhciBwMCA9IFsgMCwgZHEwIF0sXG5cdFx0XHRwMSA9IFsgMSAvIDMsIGRxMSBdLFxuXHRcdFx0cDIgPSBbIDIgLyAzLCBkcTIgXSxcblx0XHRcdHAzID0gWyAxLCBkcTMgXSxcblx0XHRcdGdldFNpZ25lZERpc3RhbmNlID0gTGluZS5nZXRTaWduZWREaXN0YW5jZSxcblx0XHRcdGRpc3QxID0gZ2V0U2lnbmVkRGlzdGFuY2UoMCwgZHEwLCAxLCBkcTMsIDEgLyAzLCBkcTEpLFxuXHRcdFx0ZGlzdDIgPSBnZXRTaWduZWREaXN0YW5jZSgwLCBkcTAsIDEsIGRxMywgMiAvIDMsIGRxMiksXG5cdFx0XHRmbGlwID0gZmFsc2UsXG5cdFx0XHRodWxsO1xuXHRcdGlmIChkaXN0MSAqIGRpc3QyIDwgMCkge1xuXHRcdFx0aHVsbCA9IFtbcDAsIHAxLCBwM10sIFtwMCwgcDIsIHAzXV07XG5cdFx0XHRmbGlwID0gZGlzdDEgPCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcG1heCwgY3Jvc3MgPSAwLFxuXHRcdFx0XHRkaXN0WmVybyA9IGRpc3QxID09PSAwIHx8IGRpc3QyID09PSAwO1xuXHRcdFx0aWYgKE1hdGguYWJzKGRpc3QxKSA+IE1hdGguYWJzKGRpc3QyKSkge1xuXHRcdFx0XHRwbWF4ID0gcDE7XG5cdFx0XHRcdGNyb3NzID0gKGRxMyAtIGRxMiAtIChkcTMgLSBkcTApIC8gMylcblx0XHRcdFx0XHRcdCogKDIgKiAoZHEzIC0gZHEyKSAtIGRxMyArIGRxMSkgLyAzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG1heCA9IHAyO1xuXHRcdFx0XHRjcm9zcyA9IChkcTEgLSBkcTAgKyAoZHEwIC0gZHEzKSAvIDMpXG5cdFx0XHRcdFx0XHQqICgtMiAqIChkcTAgLSBkcTEpICsgZHEwIC0gZHEyKSAvIDM7XG5cdFx0XHR9XG5cdFx0XHRodWxsID0gY3Jvc3MgPCAwIHx8IGRpc3RaZXJvXG5cdFx0XHRcdFx0PyBbW3AwLCBwbWF4LCBwM10sIFtwMCwgcDNdXVxuXHRcdFx0XHRcdDogW1twMCwgcDEsIHAyLCBwM10sIFtwMCwgcDNdXTtcblx0XHRcdGZsaXAgPSBkaXN0MSA/IGRpc3QxIDwgMCA6IGRpc3QyIDwgMDtcblx0XHR9XG5cdFx0cmV0dXJuIGZsaXAgPyBodWxsLnJldmVyc2UoKSA6IGh1bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBjbGlwQ29udmV4SHVsbChodWxsVG9wLCBodWxsQm90dG9tLCBkTWluLCBkTWF4KSB7XG5cdFx0dmFyIHRQcm94eSxcblx0XHRcdHRWYWwgPSBudWxsLFxuXHRcdFx0cHgsIHB5LFxuXHRcdFx0cXgsIHF5O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaHVsbEJvdHRvbS5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRweSA9IGh1bGxCb3R0b21baV1bMV07XG5cdFx0XHRxeSA9IGh1bGxCb3R0b21baSArIDFdWzFdO1xuXHRcdFx0aWYgKHB5IDwgcXkpIHtcblx0XHRcdFx0dFByb3h5ID0gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAocXkgPD0gZE1heCkge1xuXHRcdFx0XHRweCA9IGh1bGxCb3R0b21baV1bMF07XG5cdFx0XHRcdHF4ID0gaHVsbEJvdHRvbVtpICsgMV1bMF07XG5cdFx0XHRcdHRQcm94eSA9IHB4ICsgKGRNYXggLSBweSkgKiAocXggLSBweCkgLyAocXkgLSBweSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAoaHVsbFRvcFswXVsxXSA8PSBkTWF4KVxuXHRcdFx0dFByb3h5ID0gaHVsbFRvcFswXVswXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGh1bGxUb3AubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0cHkgPSBodWxsVG9wW2ldWzFdO1xuXHRcdFx0cXkgPSBodWxsVG9wW2kgKyAxXVsxXTtcblx0XHRcdGlmIChweSA+PSBkTWluKSB7XG5cdFx0XHRcdHRWYWwgPSB0UHJveHk7XG5cdFx0XHR9IGVsc2UgaWYgKHB5ID4gcXkpIHtcblx0XHRcdFx0dFZhbCA9IG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKHF5ID49IGRNaW4pIHtcblx0XHRcdFx0cHggPSBodWxsVG9wW2ldWzBdO1xuXHRcdFx0XHRxeCA9IGh1bGxUb3BbaSArIDFdWzBdO1xuXHRcdFx0XHR0VmFsID0gcHggKyAoZE1pbiAgLSBweSkgKiAocXggLSBweCkgLyAocXkgLSBweSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm4gdFZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnModjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLFxuXHRcdFx0aW5jbHVkZSkge1xuXHRcdHZhciBmbGlwID0gQ3VydmUuaXNMaW5lYXIodjEpLFxuXHRcdFx0dmMgPSBmbGlwID8gdjIgOiB2MSxcblx0XHRcdHZsID0gZmxpcCA/IHYxIDogdjIsXG5cdFx0XHRseDEgPSB2bFswXSwgbHkxID0gdmxbMV0sXG5cdFx0XHRseDIgPSB2bFs2XSwgbHkyID0gdmxbN10sXG5cdFx0XHRsZHggPSBseDIgLSBseDEsXG5cdFx0XHRsZHkgPSBseTIgLSBseTEsXG5cdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoLWxkeSwgbGR4KSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHJseDIgPSBsZHggKiBjb3MgLSBsZHkgKiBzaW4sXG5cdFx0XHRydmwgPSBbMCwgMCwgMCwgMCwgcmx4MiwgMCwgcmx4MiwgMF0sXG5cdFx0XHRydmMgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG5cdFx0XHR2YXIgeCA9IHZjW2ldIC0gbHgxLFxuXHRcdFx0XHR5ID0gdmNbaSArIDFdIC0gbHkxO1xuXHRcdFx0cnZjLnB1c2goXG5cdFx0XHRcdHggKiBjb3MgLSB5ICogc2luLFxuXHRcdFx0XHR5ICogY29zICsgeCAqIHNpbik7XG5cdFx0fVxuXHRcdHZhciByb290cyA9IFtdLFxuXHRcdFx0Y291bnQgPSBDdXJ2ZS5zb2x2ZUN1YmljKHJ2YywgMSwgMCwgcm9vdHMsIDAsIDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0dmFyIHRjID0gcm9vdHNbaV0sXG5cdFx0XHRcdHggPSBDdXJ2ZS5ldmFsdWF0ZShydmMsIHRjLCAwKS54O1xuXHRcdFx0aWYgKHggPj0gMCAmJiB4IDw9IHJseDIpIHtcblx0XHRcdFx0dmFyIHRsID0gQ3VydmUuZ2V0UGFyYW1ldGVyT2YocnZsLCB4LCAwKSxcblx0XHRcdFx0XHR0MSA9IGZsaXAgPyB0bCA6IHRjLFxuXHRcdFx0XHRcdHQyID0gZmxpcCA/IHRjIDogdGw7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGN1cnZlMSwgdDEsIEN1cnZlLmV2YWx1YXRlKHYxLCB0MSwgMCksXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5ldmFsdWF0ZSh2MiwgdDIsIDApKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRMaW5lSW50ZXJzZWN0aW9uKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdHZhciBwb2ludCA9IExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR2MVswXSwgdjFbMV0sIHYxWzZdLCB2MVs3XSxcblx0XHRcdFx0djJbMF0sIHYyWzFdLCB2Mls2XSwgdjJbN10pO1xuXHRcdGlmIChwb2ludCkge1xuXHRcdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0XHR5ID0gcG9pbnQueTtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRjdXJ2ZTEsIEN1cnZlLmdldFBhcmFtZXRlck9mKHYxLCB4LCB5KSwgcG9pbnQsXG5cdFx0XHRcdFx0Y3VydmUyLCBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2MiwgeCwgeSksIHBvaW50KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cdFx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24odjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0XHR2YXIgbGluZWFyMSA9IEN1cnZlLmlzTGluZWFyKHYxKSxcblx0XHRcdFx0bGluZWFyMiA9IEN1cnZlLmlzTGluZWFyKHYyKTtcblx0XHRcdChsaW5lYXIxICYmIGxpbmVhcjJcblx0XHRcdFx0PyBhZGRMaW5lSW50ZXJzZWN0aW9uXG5cdFx0XHRcdDogbGluZWFyMSB8fCBsaW5lYXIyXG5cdFx0XHRcdFx0PyBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0OiBhZGRDdXJ2ZUludGVyc2VjdGlvbnMpKFxuXHRcdFx0XHRcdFx0djEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0MCwgMSwgMCwgMSwgMCwgZmFsc2UsIDApO1xuXHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHR9XG5cdH19O1xufSk7XG5cbnZhciBDdXJ2ZUxvY2F0aW9uID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZUxvY2F0aW9uJyxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmVMb2NhdGlvbihjdXJ2ZSwgcGFyYW1ldGVyLCBwb2ludCwgX2N1cnZlMixcblx0XHRcdF9wYXJhbWV0ZXIyLCBfcG9pbnQyLCBfZGlzdGFuY2UpIHtcblx0XHR0aGlzLl9pZCA9IEN1cnZlTG9jYXRpb24uX2lkID0gKEN1cnZlTG9jYXRpb24uX2lkIHx8IDApICsgMTtcblx0XHR0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuXHRcdHRoaXMuX3NlZ21lbnQxID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdHRoaXMuX3NlZ21lbnQyID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50O1xuXHRcdHRoaXMuX2N1cnZlMiA9IF9jdXJ2ZTI7XG5cdFx0dGhpcy5fcGFyYW1ldGVyMiA9IF9wYXJhbWV0ZXIyO1xuXHRcdHRoaXMuX3BvaW50MiA9IF9wb2ludDI7XG5cdFx0dGhpcy5fZGlzdGFuY2UgPSBfZGlzdGFuY2U7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDogZnVuY3Rpb24oX3ByZWZlckZpcnN0KSB7XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50KSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0XHRpZiAocGFyYW1ldGVyID09PSAxKSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlciA9PT0gMCB8fCBfcHJlZmVyRmlyc3QpIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MTtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50ID0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpXG5cdFx0XHRcdFx0PCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHBhcmFtZXRlciwgMSlcblx0XHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdFx0XHQ6IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQ7XG5cdH0sXG5cblx0Z2V0Q3VydmU6IGZ1bmN0aW9uKF91bmNhY2hlZCkge1xuXHRcdGlmICghdGhpcy5fY3VydmUgfHwgX3VuY2FjaGVkKSB7XG5cdFx0XHR0aGlzLl9jdXJ2ZSA9IHRoaXMuX3NlZ21lbnQxLmdldEN1cnZlKCk7XG5cdFx0XHRpZiAodGhpcy5fY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5fcG9pbnQpID09IG51bGwpXG5cdFx0XHRcdHRoaXMuX2N1cnZlID0gdGhpcy5fc2VnbWVudDIuZ2V0UHJldmlvdXMoKS5nZXRDdXJ2ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY3VydmU7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5faW50ZXJzZWN0aW9uO1xuXHRcdGlmICghaW50ZXJzZWN0aW9uICYmIHRoaXMuX2N1cnZlMikge1xuXHRcdFx0dmFyIHBhcmFtID0gdGhpcy5fcGFyYW1ldGVyMjtcblx0XHRcdHRoaXMuX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbiA9IG5ldyBDdXJ2ZUxvY2F0aW9uKFxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlMiwgcGFyYW0sIHRoaXMuX3BvaW50MiB8fCB0aGlzLl9wb2ludCwgdGhpcyk7XG5cdFx0XHRpbnRlcnNlY3Rpb24uX2ludGVyc2VjdGlvbiA9IHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5fcGF0aDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRJbmRleCgpO1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKTtcblx0XHRyZXR1cm4gcGF0aCA/IHBhdGguX2dldE9mZnNldCh0aGlzKSA6IHRoaXMuZ2V0Q3VydmVPZmZzZXQoKTtcblx0fSxcblxuXHRnZXRDdXJ2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24oX3VuY2FjaGVkKSB7XG5cdFx0aWYgKCh0aGlzLl9wYXJhbWV0ZXIgPT0gbnVsbCB8fCBfdW5jYWNoZWQpICYmIHRoaXMuX3BvaW50KSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKF91bmNhY2hlZCk7XG5cdFx0XHR0aGlzLl9wYXJhbWV0ZXIgPSBjdXJ2ZSAmJiBjdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLl9wb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9wYXJhbWV0ZXI7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKF91bmNhY2hlZCkge1xuXHRcdGlmICgoIXRoaXMuX3BvaW50IHx8IF91bmNhY2hlZCkgJiYgdGhpcy5fcGFyYW1ldGVyICE9IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoX3VuY2FjaGVkKTtcblx0XHRcdHRoaXMuX3BvaW50ID0gY3VydmUgJiYgY3VydmUuZ2V0UG9pbnRBdCh0aGlzLl9wYXJhbWV0ZXIsIHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcG9pbnQ7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaXN0YW5jZTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUodHJ1ZSk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLmRpdmlkZSh0aGlzLmdldFBhcmFtZXRlcih0cnVlKSwgdHJ1ZSk7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUodHJ1ZSk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLnNwbGl0KHRoaXMuZ2V0UGFyYW1ldGVyKHRydWUpLCB0cnVlKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGxvYykge1xuXHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdHJldHVybiB0aGlzID09PSBsb2Ncblx0XHRcdFx0fHwgbG9jXG5cdFx0XHRcdFx0JiYgdGhpcy5fY3VydmUgPT09IGxvYy5fY3VydmVcblx0XHRcdFx0XHQmJiB0aGlzLl9jdXJ2ZTIgPT09IGxvYy5fY3VydmUyXG5cdFx0XHRcdFx0JiYgaXNaZXJvKHRoaXMuX3BhcmFtZXRlciAtIGxvYy5fcGFyYW1ldGVyKVxuXHRcdFx0XHRcdCYmIGlzWmVybyh0aGlzLl9wYXJhbWV0ZXIyIC0gbG9jLl9wYXJhbWV0ZXIyKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRwb2ludCA9IHRoaXMuZ2V0UG9pbnQoKSxcblx0XHRcdGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0aWYgKHBvaW50KVxuXHRcdFx0cGFydHMucHVzaCgncG9pbnQ6ICcgKyBwb2ludCk7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdGlmIChpbmRleCAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnaW5kZXg6ICcgKyBpbmRleCk7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0aWYgKHBhcmFtZXRlciAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgncGFyYW1ldGVyOiAnICsgZi5udW1iZXIocGFyYW1ldGVyKSk7XG5cdFx0aWYgKHRoaXMuX2Rpc3RhbmNlICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdkaXN0YW5jZTogJyArIGYubnVtYmVyKHRoaXMuX2Rpc3RhbmNlKSk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fVxufSwgQmFzZS5lYWNoKFsnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIGdldCA9IG5hbWUgKyAnQXQnO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCksXG5cdFx0XHRjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmVbZ2V0XShwYXJhbWV0ZXIsIHRydWUpO1xuXHR9O1xufSwge30pKTtcblxudmFyIFBhdGhJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoSXRlbScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aEl0ZW0oKSB7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24ocGF0aCwgX21hdHJpeCwgX2V4cGFuZCkge1xuXHRcdGlmICh0aGlzID09PSBwYXRoKVxuXHRcdFx0cGF0aCA9IG51bGw7XG5cdFx0dmFyIGxvY2F0aW9ucyA9IFtdLFxuXHRcdFx0Y3VydmVzMSA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRjdXJ2ZXMyID0gcGF0aCA/IHBhdGguZ2V0Q3VydmVzKCkgOiBjdXJ2ZXMxLFxuXHRcdFx0bWF0cml4MSA9IHRoaXMuX21hdHJpeC5vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRtYXRyaXgyID0gcGF0aCA/IChfbWF0cml4IHx8IHBhdGguX21hdHJpeCkub3JOdWxsSWZJZGVudGl0eSgpXG5cdFx0XHRcdDogbWF0cml4MSxcblx0XHRcdGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcblx0XHRcdGxlbmd0aDIgPSBwYXRoID8gY3VydmVzMi5sZW5ndGggOiBsZW5ndGgxLFxuXHRcdFx0dmFsdWVzMiA9IFtdLFxuXHRcdFx0TUlOID0gMWUtMTEsXG5cdFx0XHRNQVggPSAxIC0gMWUtMTE7XG5cdFx0aWYgKHBhdGggJiYgIXRoaXMuZ2V0Qm91bmRzKG1hdHJpeDEpLnRvdWNoZXMocGF0aC5nZXRCb3VuZHMobWF0cml4MikpKVxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKVxuXHRcdFx0dmFsdWVzMltpXSA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKG1hdHJpeDIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUxID0gY3VydmVzMVtpXSxcblx0XHRcdFx0dmFsdWVzMSA9IHBhdGggPyBjdXJ2ZTEuZ2V0VmFsdWVzKG1hdHJpeDEpIDogdmFsdWVzMltpXTtcblx0XHRcdGlmICghcGF0aCkge1xuXHRcdFx0XHR2YXIgc2VnMSA9IGN1cnZlMS5nZXRTZWdtZW50MSgpLFxuXHRcdFx0XHRcdHNlZzIgPSBjdXJ2ZTEuZ2V0U2VnbWVudDIoKSxcblx0XHRcdFx0XHRoMSA9IHNlZzEuX2hhbmRsZU91dCxcblx0XHRcdFx0XHRoMiA9IHNlZzIuX2hhbmRsZUluO1xuXHRcdFx0XHRpZiAobmV3IExpbmUoc2VnMS5fcG9pbnQuc3VidHJhY3QoaDEpLCBoMS5tdWx0aXBseSgyKSwgdHJ1ZSlcblx0XHRcdFx0XHRcdC5pbnRlcnNlY3QobmV3IExpbmUoc2VnMi5fcG9pbnQuc3VidHJhY3QoaDIpLFxuXHRcdFx0XHRcdFx0aDIubXVsdGlwbHkoMiksIHRydWUpLCBmYWxzZSkpIHtcblx0XHRcdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodmFsdWVzMSk7XG5cdFx0XHRcdFx0Q3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdHBhcnRzWzBdLCBwYXJ0c1sxXSwgY3VydmUxLCBjdXJ2ZTEsIGxvY2F0aW9ucyxcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0XHRcdFx0XHRpZiAobG9jLl9wYXJhbWV0ZXIgPD0gTUFYKSB7XG5cdFx0XHRcdFx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIgLz0gMjtcblx0XHRcdFx0XHRcdFx0XHRsb2MuX3BhcmFtZXRlcjIgPSAwLjUgKyBsb2MuX3BhcmFtZXRlcjIgLyAyO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaiA9IHBhdGggPyAwIDogaSArIDE7IGogPCBsZW5ndGgyOyBqKyspIHtcblx0XHRcdFx0Q3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2YWx1ZXMxLCB2YWx1ZXMyW2pdLCBjdXJ2ZTEsIGN1cnZlczJbal0sIGxvY2F0aW9ucyxcblx0XHRcdFx0XHQhcGF0aCAmJiAoaiA9PT0gaSArIDEgfHwgaiA9PT0gbGVuZ3RoMiAtIDEgJiYgaSA9PT0gMClcblx0XHRcdFx0XHRcdCYmIGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IGxvYy5fcGFyYW1ldGVyO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdCA+PSBNSU4gJiYgdCA8PSBNQVg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBsYXN0ID0gbG9jYXRpb25zLmxlbmd0aCAtIDE7XG5cdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgbG9jID0gbG9jYXRpb25zW2ldLFxuXHRcdFx0XHRuZXh0ID0gbG9jLl9jdXJ2ZS5nZXROZXh0KCksXG5cdFx0XHRcdG5leHQyID0gbG9jLl9jdXJ2ZTIuZ2V0TmV4dCgpO1xuXHRcdFx0aWYgKG5leHQgJiYgbG9jLl9wYXJhbWV0ZXIgPj0gTUFYKSB7XG5cdFx0XHRcdGxvYy5fcGFyYW1ldGVyID0gMDtcblx0XHRcdFx0bG9jLl9jdXJ2ZSA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmV4dDIgJiYgbG9jLl9wYXJhbWV0ZXIyID49IE1BWCkge1xuXHRcdFx0XHRsb2MuX3BhcmFtZXRlcjIgPSAwO1xuXHRcdFx0XHRsb2MuX2N1cnZlMiA9IG5leHQyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXBhcmUobG9jMSwgbG9jMikge1xuXHRcdFx0dmFyIHBhdGgxID0gbG9jMS5nZXRQYXRoKCksXG5cdFx0XHRcdHBhdGgyID0gbG9jMi5nZXRQYXRoKCk7XG5cdFx0XHRyZXR1cm4gcGF0aDEgPT09IHBhdGgyXG5cdFx0XHRcdFx0PyAobG9jMS5nZXRJbmRleCgpICsgbG9jMS5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0XHRcdFx0LSAobG9jMi5nZXRJbmRleCgpICsgbG9jMi5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0XHQ6IHBhdGgxLl9pZCAtIHBhdGgyLl9pZDtcblx0XHR9XG5cblx0XHRpZiAobGFzdCA+IDApIHtcblx0XHRcdGxvY2F0aW9ucy5zb3J0KGNvbXBhcmUpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMTsgaS0tKSB7XG5cdFx0XHRcdGlmIChsb2NhdGlvbnNbaV0uZXF1YWxzKGxvY2F0aW9uc1tpID09PSAwID8gbGFzdCA6IGkgLSAxXSkpIHtcblx0XHRcdFx0XHRsb2NhdGlvbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdGxhc3QtLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoX2V4cGFuZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMDsgaS0tKVxuXHRcdFx0XHRsb2NhdGlvbnMucHVzaChsb2NhdGlvbnNbaV0uZ2V0SW50ZXJzZWN0aW9uKCkpO1xuXHRcdFx0bG9jYXRpb25zLnNvcnQoY29tcGFyZSk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdH0sXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldFBhdGhEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG5cblx0XHR2YXIgcGFydHMgPSBkYXRhLm1hdGNoKC9bbWxodmNzcXRhel1bXm1saHZjc3F0YXpdKi9pZyksXG5cdFx0XHRjb29yZHMsXG5cdFx0XHRyZWxhdGl2ZSA9IGZhbHNlLFxuXHRcdFx0cHJldmlvdXMsXG5cdFx0XHRjb250cm9sLFxuXHRcdFx0Y3VycmVudCA9IG5ldyBQb2ludCgpLFxuXHRcdFx0c3RhcnQgPSBuZXcgUG9pbnQoKTtcblxuXHRcdGZ1bmN0aW9uIGdldENvb3JkKGluZGV4LCBjb29yZCkge1xuXHRcdFx0dmFyIHZhbCA9ICtjb29yZHNbaW5kZXhdO1xuXHRcdFx0aWYgKHJlbGF0aXZlKVxuXHRcdFx0XHR2YWwgKz0gY3VycmVudFtjb29yZF07XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFBvaW50KGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCwgJ3gnKSxcblx0XHRcdFx0Z2V0Q29vcmQoaW5kZXggKyAxLCAneScpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuY2xlYXIoKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHBhcnRzW2ldLFxuXHRcdFx0XHRjb21tYW5kID0gcGFydFswXSxcblx0XHRcdFx0bG93ZXIgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjb29yZHMgPSBwYXJ0Lm1hdGNoKC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKTtcblx0XHRcdHZhciBsZW5ndGggPSBjb29yZHMgJiYgY29vcmRzLmxlbmd0aDtcblx0XHRcdHJlbGF0aXZlID0gY29tbWFuZCA9PT0gbG93ZXI7XG5cdFx0XHRpZiAocHJldmlvdXMgPT09ICd6JyAmJiAhL1ttel0vLnRlc3QobG93ZXIpKVxuXHRcdFx0XHR0aGlzLm1vdmVUbyhjdXJyZW50ID0gc3RhcnQpO1xuXHRcdFx0c3dpdGNoIChsb3dlcikge1xuXHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0dmFyIG1vdmUgPSBsb3dlciA9PT0gJ20nO1xuXHRcdFx0XHRpZiAobW92ZSAmJiBwcmV2aW91cyAmJiBwcmV2aW91cyAhPT0gJ3onKVxuXHRcdFx0XHRcdHRoaXMuY2xvc2VQYXRoKHRydWUpO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKVxuXHRcdFx0XHRcdHRoaXNbaiA9PT0gMCAmJiBtb3ZlID8gJ21vdmVUbycgOiAnbGluZVRvJ10oXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqKSk7XG5cdFx0XHRcdGNvbnRyb2wgPSBjdXJyZW50O1xuXHRcdFx0XHRpZiAobW92ZSlcblx0XHRcdFx0XHRzdGFydCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0dmFyIGNvb3JkID0gbG93ZXIgPT09ICdoJyA/ICd4JyA6ICd5Jztcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGN1cnJlbnRbY29vcmRdID0gZ2V0Q29vcmQoaiwgY29vcmQpO1xuXHRcdFx0XHRcdHRoaXMubGluZVRvKGN1cnJlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRyb2wgPSBjdXJyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA2KSB7XG5cdFx0XHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiArIDIpLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3MnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA0KSB7XG5cdFx0XHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdC9bY3NdLy50ZXN0KHByZXZpb3VzKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3EnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA0KSB7XG5cdFx0XHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSAoL1txdF0vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqKSk7XG5cdFx0XHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA3KSB7XG5cdFx0XHRcdFx0dGhpcy5hcmNUbyhjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDUpLFxuXHRcdFx0XHRcdFx0XHRuZXcgU2l6ZSgrY29vcmRzWzBdLCArY29vcmRzWzFdKSxcblx0XHRcdFx0XHRcdFx0K2Nvb3Jkc1syXSwgK2Nvb3Jkc1s0XSwgK2Nvb3Jkc1szXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0dGhpcy5jbG9zZVBhdGgodHJ1ZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB3aW5kaW5nID0gdGhpcy5fZ2V0V2luZGluZyhwb2ludCwgZmFsc2UsIHRydWUpO1xuXHRcdHJldHVybiAhISh0aGlzLmdldFdpbmRpbmdSdWxlKCkgPT09ICdldmVub2RkJyA/IHdpbmRpbmcgJiAxIDogd2luZGluZyk7XG5cdH1cblxufSk7XG5cbnZhciBQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzZWdtZW50czogW10sXG5cdFx0Y2xvc2VkOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fc2VnbWVudHMgPSBbXTtcblx0XHR2YXIgc2VnbWVudHMgPSBBcnJheS5pc0FycmF5KGFyZylcblx0XHRcdD8gdHlwZW9mIGFyZ1swXSA9PT0gJ29iamVjdCdcblx0XHRcdFx0PyBhcmdcblx0XHRcdFx0OiBhcmd1bWVudHNcblx0XHRcdDogYXJnICYmIChhcmcuc2l6ZSA9PT0gdW5kZWZpbmVkICYmIChhcmcueCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0fHwgYXJnLnBvaW50ICE9PSB1bmRlZmluZWQpKVxuXHRcdFx0XHQ/IGFyZ3VtZW50c1xuXHRcdFx0XHQ6IG51bGw7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U2VnbWVudHModGhpcy5fc2VnbWVudHMpO1xuXHRcdGNvcHkuX2Nsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Ll9jbG9ja3dpc2UgPSB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2Nsb2Nrd2lzZSA9IHVuZGVmaW5lZDtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZXMgJiYgIShmbGFncyAmIDE2KSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2ldLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tb25vQ3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoZmxhZ3MgJiAzMikge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRyZXR1cm4gKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHRoaXMpLl9zdHlsZTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuXHR9LFxuXG5cdHNldFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBmdWxseVNlbGVjdGVkID0gdGhpcy5pc0Z1bGx5U2VsZWN0ZWQoKTtcblx0XHR0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdFx0aWYgKGZ1bGx5U2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGlmICghY3VydmVzKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdFx0Y3VydmVzW2ldID0gbmV3IEN1cnZlKHRoaXMsIHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRyZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fSxcblxuXHRzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgIT0gKGNsb3NlZCA9ICEhY2xvc2VkKSkge1xuXHRcdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRcdGlmIChjbG9zZWQpXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0fVxuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRmID0gbmV3IEZvcm1hdHRlcihfcHJlY2lzaW9uKSxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFksXG5cdFx0XHRwYXJ0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50LCBza2lwTGluZSkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoX21hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0aWYgKCFza2lwTGluZSlcblx0XHRcdFx0XHRcdHBhcnRzLnB1c2goJ2wnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCsgJyAnICsgZi5wYWlyKGluWCAtIHByZXZYLCBpblkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0KyAnICcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0fVxuXG5cdFx0aWYgKGxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiAnJztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAodGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbMF0sIHRydWUpO1xuXHRcdFx0cGFydHMucHVzaCgneicpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFydHMuam9pbignJyk7XG5cdH1cbn0sIHtcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHMubGVuZ3RoID09PSAwO1xuXHR9LFxuXG5cdGlzUG9seWdvbjogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICghdGhpcy5fc2VnbWVudHNbaV0uaXNMaW5lYXIoKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX3NlZ21lbnRzW2ldLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2FkZDogZnVuY3Rpb24oc2VncywgaW5kZXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGFtb3VudCA9IHNlZ3MubGVuZ3RoLFxuXHRcdFx0YXBwZW5kID0gaW5kZXggPT0gbnVsbCxcblx0XHRcdGluZGV4ID0gYXBwZW5kID8gc2VnbWVudHMubGVuZ3RoIDogaW5kZXg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdzW2ldO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3BhdGgpXG5cdFx0XHRcdHNlZ21lbnQgPSBzZWdzW2ldID0gc2VnbWVudC5jbG9uZSgpO1xuXHRcdFx0c2VnbWVudC5fcGF0aCA9IHRoaXM7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSlcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIDAsIHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKTtcblx0XHR9XG5cdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0c2VnbWVudHMucHVzaC5hcHBseShzZWdtZW50cywgc2Vncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlZ21lbnRzLnNwbGljZS5hcHBseShzZWdtZW50cywgW2luZGV4LCAwXS5jb25jYXQoc2VncykpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuXHRcdH1cblx0XHRpZiAoY3VydmVzIHx8IHNlZ3MuX2N1cnZlcykge1xuXHRcdFx0aWYgKCFjdXJ2ZXMpXG5cdFx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IFtdO1xuXHRcdFx0dmFyIGZyb20gPSBpbmRleCA+IDAgPyBpbmRleCAtIDEgOiBpbmRleCxcblx0XHRcdFx0c3RhcnQgPSBmcm9tLFxuXHRcdFx0XHR0byA9IE1hdGgubWluKGZyb20gKyBhbW91bnQsIHRoaXMuX2NvdW50Q3VydmVzKCkpO1xuXHRcdFx0aWYgKHNlZ3MuX2N1cnZlcykge1xuXHRcdFx0XHRjdXJ2ZXMuc3BsaWNlLmFwcGx5KGN1cnZlcywgW2Zyb20sIDBdLmNvbmNhdChzZWdzLl9jdXJ2ZXMpKTtcblx0XHRcdFx0c3RhcnQgKz0gc2Vncy5fY3VydmVzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHRvOyBpKyspXG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UoaSwgMCwgbmV3IEN1cnZlKHRoaXMsIG51bGwsIG51bGwpKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhmcm9tLCB0byk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cdF9hZGp1c3RDdXJ2ZXM6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjdXJ2ZTtcblx0XHRmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcblx0XHRcdGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0Y3VydmUuX3BhdGggPSB0aGlzO1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbaV07XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF07XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRpZiAoY3VydmUgPSBjdXJ2ZXNbdGhpcy5fY2xvc2VkICYmIGZyb20gPT09IDAgPyBzZWdtZW50cy5sZW5ndGggLSAxXG5cdFx0XHRcdDogZnJvbSAtIDFdKSB7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tmcm9tXSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0b10pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW3RvXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jb3VudEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHRyZXR1cm4gIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwID8gbGVuZ3RoIC0gMSA6IGxlbmd0aDtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKHNlZ21lbnQxICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0OiBmdW5jdGlvbihpbmRleCwgc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChhcmd1bWVudHMsIDEpLCBpbmRleClcblx0XHRcdDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSkgXSwgaW5kZXgpWzBdO1xuXHR9LFxuXG5cdGFkZFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50OiBmdW5jdGlvbihpbmRleCApIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSkgXSwgaW5kZXgpWzBdO1xuXHR9LFxuXG5cdGFkZFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudHM6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50cykge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSwgaW5kZXgpO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIGluZGV4ICsgMSlbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50czogZnVuY3Rpb24oZnJvbSwgdG8sIF9pbmNsdWRlQ3VydmVzKSB7XG5cdFx0ZnJvbSA9IGZyb20gfHwgMDtcblx0XHR0byA9IEJhc2UucGljayh0bywgdGhpcy5fc2VnbWVudHMubGVuZ3RoKTtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGNvdW50ID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnRzLnNwbGljZShmcm9tLCB0byAtIGZyb20pLFxuXHRcdFx0YW1vdW50ID0gcmVtb3ZlZC5sZW5ndGg7XG5cdFx0aWYgKCFhbW91bnQpXG5cdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHJlbW92ZWRbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSwgMCk7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IHNlZ21lbnQuX3BhdGggPSBudWxsO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gZnJvbSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0dmFyIGluZGV4ID0gZnJvbSA+IDAgJiYgdG8gPT09IGNvdW50ICsgKHRoaXMuX2Nsb3NlZCA/IDEgOiAwKVxuXHRcdFx0XHRcdD8gZnJvbSAtIDFcblx0XHRcdFx0XHQ6IGZyb20sXG5cdFx0XHRcdGN1cnZlcyA9IGN1cnZlcy5zcGxpY2UoaW5kZXgsIGFtb3VudCk7XG5cdFx0XHRpZiAoX2luY2x1ZGVDdXJ2ZXMpXG5cdFx0XHRcdHJlbW92ZWQuX2N1cnZlcyA9IGN1cnZlcy5zbGljZSgxKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhpbmRleCwgaW5kZXgpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbGVhcjogJyNyZW1vdmVTZWdtZW50cycsXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fbGVuZ3RoICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHR2YXIgYXJlYSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjdXJ2ZXNbaV0uZ2V0QXJlYSgpO1xuXHRcdHJldHVybiBhcmVhO1xuXHR9LFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQgJiYgbGVuZ3RoID4gMCAmJiB0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZVxuXHRcdFx0XHQ9PT0gbGVuZ3RoICogNztcblx0fSxcblxuXHRzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdGlmIChzZWxlY3RlZClcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKHRydWUpO1xuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbiBzZXRTZWxlY3RlZChzZWxlY3RlZCkge1xuXHRcdGlmICghc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyhmYWxzZSk7XG5cdFx0c2V0U2VsZWN0ZWQuYmFzZS5jYWxsKHRoaXMsIHNlbGVjdGVkKTtcblx0fSxcblxuXHRfc2VsZWN0U2VnbWVudHM6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IHNlbGVjdGVkXG5cdFx0XHRcdD8gbGVuZ3RoICogNyA6IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdHRoaXMuX3NlZ21lbnRzW2ldLl9zZWxlY3Rpb25TdGF0ZSA9IHNlbGVjdGVkXG5cdFx0XHRcdFx0PyA3IDogMDtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihzZWdtZW50LCBvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcblx0XHRzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdHZhciB0b3RhbCA9IHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlICs9IG5ld1N0YXRlIC0gb2xkU3RhdGU7XG5cdFx0aWYgKHRvdGFsID4gMClcblx0XHRcdHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZmxhdHRlbjogZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcblx0XHR2YXIgaXRlcmF0b3IgPSBuZXcgUGF0aEl0ZXJhdG9yKHRoaXMsIDY0LCAwLjEpLFxuXHRcdFx0cG9zID0gMCxcblx0XHRcdHN0ZXAgPSBpdGVyYXRvci5sZW5ndGggLyBNYXRoLmNlaWwoaXRlcmF0b3IubGVuZ3RoIC8gbWF4RGlzdGFuY2UpLFxuXHRcdFx0ZW5kID0gaXRlcmF0b3IubGVuZ3RoICsgKHRoaXMuX2Nsb3NlZCA/IC1zdGVwIDogc3RlcCkgLyAyO1xuXHRcdHZhciBzZWdtZW50cyA9IFtdO1xuXHRcdHdoaWxlIChwb3MgPD0gZW5kKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KGl0ZXJhdG9yLmV2YWx1YXRlKHBvcywgMCkpKTtcblx0XHRcdHBvcyArPSBzdGVwO1xuXHRcdH1cblx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGlmIChjdXJ2ZS5pc0xpbmVhcigpICYmIGN1cnZlLmdldExlbmd0aCgpID09PSAwKVxuXHRcdFx0XHRjdXJ2ZS5yZW1vdmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2ltcGxpZnk6IGZ1bmN0aW9uKHRvbGVyYW5jZSkge1xuXHRcdGlmICh0aGlzLl9zZWdtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0XHR2YXIgZml0dGVyID0gbmV3IFBhdGhGaXR0ZXIodGhpcywgdG9sZXJhbmNlIHx8IDIuNSk7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKGZpdHRlci5maXQoKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbihpbmRleCwgcGFyYW1ldGVyKSB7XG5cdFx0aWYgKHBhcmFtZXRlciA9PT0gbnVsbClcblx0XHRcdHJldHVybjtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGFyZyA9IGluZGV4O1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKVxuXHRcdFx0XHRhcmcgPSB0aGlzLmdldExvY2F0aW9uQXQoYXJnKTtcblx0XHRcdGluZGV4ID0gYXJnLmluZGV4O1xuXHRcdFx0cGFyYW1ldGVyID0gYXJnLnBhcmFtZXRlcjtcblx0XHR9XG5cdFx0dmFyIHRvbGVyYW5jZSA9IDAuMDAwMDE7XG5cdFx0aWYgKHBhcmFtZXRlciA+PSAxIC0gdG9sZXJhbmNlKSB7XG5cdFx0XHRpbmRleCsrO1xuXHRcdFx0cGFyYW1ldGVyLS07XG5cdFx0fVxuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VydmVzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHBhcmFtZXRlciA+IHRvbGVyYW5jZSkge1xuXHRcdFx0XHRjdXJ2ZXNbaW5kZXgrK10uZGl2aWRlKHBhcmFtZXRlciwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2VncyA9IHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCwgdHJ1ZSksXG5cdFx0XHRcdHBhdGg7XG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvc2VkKGZhbHNlKTtcblx0XHRcdFx0cGF0aCA9IHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKGluZGV4ID4gMCkge1xuXHRcdFx0XHRwYXRoID0gdGhpcy5fY2xvbmUobmV3IFBhdGgoKS5pbnNlcnRBYm92ZSh0aGlzLCB0cnVlKSk7XG5cdFx0XHR9XG5cdFx0XHRwYXRoLl9hZGQoc2VncywgMCk7XG5cdFx0XHR0aGlzLmFkZFNlZ21lbnQoc2Vnc1swXSk7XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIFBhdGguaXNDbG9ja3dpc2UodGhpcy5fc2VnbWVudHMpO1xuXHR9LFxuXG5cdHNldENsb2Nrd2lzZTogZnVuY3Rpb24oY2xvY2t3aXNlKSB7XG5cdFx0aWYgKHRoaXMuaXNDbG9ja3dpc2UoKSAhPSAoY2xvY2t3aXNlID0gISFjbG9ja3dpc2UpKVxuXHRcdFx0dGhpcy5yZXZlcnNlKCk7XG5cdFx0dGhpcy5fY2xvY2t3aXNlID0gY2xvY2t3aXNlO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnRzLnJldmVyc2UoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQgPSBoYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0dGhpcy5fY3VydmVzID0gbnVsbDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHR0aGlzLl9jbG9ja3dpc2UgPSAhdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0am9pbjogZnVuY3Rpb24ocGF0aCkge1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdFx0bGFzdDEgPSB0aGlzLmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxLl9wb2ludC5lcXVhbHMobGFzdDIuX3BvaW50KSlcblx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHR2YXIgZmlyc3QxLFxuXHRcdFx0XHRmaXJzdDIgPSBwYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpIHtcblx0XHRcdFx0bGFzdDEuc2V0SGFuZGxlT3V0KGZpcnN0Mi5faGFuZGxlT3V0KTtcblx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpcnN0MSA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEuX3BvaW50LmVxdWFscyhmaXJzdDIuX3BvaW50KSlcblx0XHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKSB7XG5cdFx0XHRcdFx0Zmlyc3QxLnNldEhhbmRsZUluKGxhc3QyLl9oYW5kbGVJbik7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpLCAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLmNsb3NlZClcblx0XHRcdFx0dGhpcy5fYWRkKFtzZWdtZW50c1swXV0pO1xuXHRcdFx0cGF0aC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKSxcblx0XHRcdGxhc3QgPSB0aGlzLmdldExhc3RTZWdtZW50KCk7XG5cdFx0aWYgKGZpcnN0ICE9PSBsYXN0ICYmIGZpcnN0Ll9wb2ludC5lcXVhbHMobGFzdC5fcG9pbnQpKSB7XG5cdFx0XHRmaXJzdC5zZXRIYW5kbGVJbihsYXN0Ll9oYW5kbGVJbik7XG5cdFx0XHRsYXN0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHRvU2hhcGU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdGlmICghdGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRzaXplLFxuXHRcdFx0cmFkaXVzLFxuXHRcdFx0dG9wQ2VudGVyO1xuXG5cdFx0ZnVuY3Rpb24gaXNDb2xpbmVhcihpLCBqKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uaXNDb2xpbmVhcihzZWdtZW50c1tqXSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNPcnRob2dvbmFsKGkpIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5pc09ydGhvZ29uYWwoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0FyYyhpKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uaXNBcmMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREaXN0YW5jZShpLCBqKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uX3BvaW50LmdldERpc3RhbmNlKHNlZ21lbnRzW2pdLl9wb2ludCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXNQb2x5Z29uKCkgJiYgc2VnbWVudHMubGVuZ3RoID09PSA0XG5cdFx0XHRcdCYmIGlzQ29saW5lYXIoMCwgMikgJiYgaXNDb2xpbmVhcigxLCAzKSAmJiBpc09ydGhvZ29uYWwoMSkpIHtcblx0XHRcdHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgMyksIGdldERpc3RhbmNlKDAsIDEpKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludC5hZGQoc2VnbWVudHNbMl0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDggJiYgaXNBcmMoMCkgJiYgaXNBcmMoMikgJiYgaXNBcmMoNClcblx0XHRcdFx0JiYgaXNBcmMoNikgJiYgaXNDb2xpbmVhcigxLCA1KSAmJiBpc0NvbGluZWFyKDMsIDcpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDEsIDYpLCBnZXREaXN0YW5jZSgwLCAzKSk7XG5cdFx0XHRyYWRpdXMgPSBzaXplLnN1YnRyYWN0KG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDcpLFxuXHRcdFx0XHRcdGdldERpc3RhbmNlKDEsIDIpKSkuZGl2aWRlKDIpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbM10uX3BvaW50LmFkZChzZWdtZW50c1s0XS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0FyYygwKSAmJiBpc0FyYygxKSAmJiBpc0FyYygyKSAmJiBpc0FyYygzKSkge1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZ2V0RGlzdGFuY2UoMCwgMikgLSBnZXREaXN0YW5jZSgxLCAzKSkpIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkNpcmNsZTtcblx0XHRcdFx0cmFkaXVzID0gZ2V0RGlzdGFuY2UoMCwgMikgLyAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkVsbGlwc2U7XG5cdFx0XHRcdHJhZGl1cyA9IG5ldyBTaXplKGdldERpc3RhbmNlKDIsIDApIC8gMiwgZ2V0RGlzdGFuY2UoMywgMSkgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludDtcblx0XHR9XG5cblx0XHRpZiAodHlwZSkge1xuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksXG5cdFx0XHRcdHNoYXBlID0gbmV3IHR5cGUoe1xuXHRcdFx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdHNoYXBlLnJvdGF0ZSh0b3BDZW50ZXIuc3VidHJhY3QoY2VudGVyKS5nZXRBbmdsZSgpICsgOTApO1xuXHRcdFx0c2hhcGUuc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdFx0aWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0c2hhcGUuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRyZXR1cm4gc2hhcGU7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRqb2luLCBjYXAsIG1pdGVyTGltaXQsXG5cdFx0XHRhcmVhLCBsb2MsIHJlcyxcblx0XHRcdGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0aGl0RmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoaXRDdXJ2ZXMgPSBvcHRpb25zLmN1cnZlcyxcblx0XHRcdHJhZGl1cyA9IGhpdFN0cm9rZVxuXHRcdFx0XHRcdD8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDJcblx0XHRcdFx0XHQ6IGhpdEZpbGwgJiYgb3B0aW9ucy50b2xlcmFuY2UgPiAwIHx8IGhpdEN1cnZlc1xuXHRcdFx0XHRcdFx0PyAwIDogbnVsbDtcblx0XHRpZiAocmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRpZiAocmFkaXVzID4gMCkge1xuXHRcdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpO1xuXHRcdFx0XHRjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKTtcblx0XHRcdFx0bWl0ZXJMaW1pdCA9IHJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcuYWRkKG5ldyBQb2ludChyYWRpdXMsIHJhZGl1cykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0am9pbiA9IGNhcCA9ICdyb3VuZCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNDbG9zZUVub3VnaChwdCwgcGFkZGluZykge1xuXHRcdFx0cmV0dXJuIHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUocGFkZGluZykubGVuZ3RoIDw9IDE7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBwdCwgbmFtZSkge1xuXHRcdFx0aWYgKCFvcHRpb25zLnNlbGVjdGVkIHx8IHB0LmlzU2VsZWN0ZWQoKSkge1xuXHRcdFx0XHR2YXIgYW5jaG9yID0gc2VnLl9wb2ludDtcblx0XHRcdFx0aWYgKHB0ICE9PSBhbmNob3IpXG5cdFx0XHRcdFx0cHQgPSBwdC5hZGQoYW5jaG9yKTtcblx0XHRcdFx0aWYgKGlzQ2xvc2VFbm91Z2gocHQsIHN0cm9rZVBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQobmFtZSwgdGhhdCwge1xuXHRcdFx0XHRcdFx0c2VnbWVudDogc2VnLFxuXHRcdFx0XHRcdFx0cG9pbnQ6IHB0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludHMoc2VnLCBlbmRzKSB7XG5cdFx0XHRyZXR1cm4gKGVuZHMgfHwgb3B0aW9ucy5zZWdtZW50cylcblx0XHRcdFx0JiYgY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX3BvaW50LCAnc2VnbWVudCcpXG5cdFx0XHRcdHx8ICghZW5kcyAmJiBvcHRpb25zLmhhbmRsZXMpICYmIChcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlSW4sICdoYW5kbGUtaW4nKSB8fFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVPdXQsICdoYW5kbGUtb3V0JykpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFRvQXJlYShwb2ludCkge1xuXHRcdFx0YXJlYS5hZGQocG9pbnQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSB7XG5cdFx0XHRpZiAoam9pbiAhPT0gJ3JvdW5kJyB8fCBjYXAgIT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YXJlYSA9IG5ldyBQYXRoKHsgaW50ZXJuYWw6IHRydWUsIGNsb3NlZDogdHJ1ZSB9KTtcblx0XHRcdFx0aWYgKGNsb3NlZCB8fCBzZWdtZW50Ll9pbmRleCA+IDBcblx0XHRcdFx0XHRcdCYmIHNlZ21lbnQuX2luZGV4IDwgbnVtU2VnbWVudHMgLSAxKSB7XG5cdFx0XHRcdFx0aWYgKGpvaW4gIT09ICdyb3VuZCcgJiYgKHNlZ21lbnQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0XHRcdHx8IHNlZ21lbnQuX2hhbmRsZU91dC5pc1plcm8oKSkpXG5cdFx0XHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LFxuXHRcdFx0XHRcdFx0XHRcdGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2FwICE9PSAncm91bmQnKSB7XG5cdFx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRUb0FyZWEsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYXJlYS5pc0VtcHR5KCkpIHtcblx0XHRcdFx0XHR2YXIgbG9jO1xuXHRcdFx0XHRcdHJldHVybiBhcmVhLmNvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHRcdFx0fHwgKGxvYyA9IGFyZWEuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KSlcblx0XHRcdFx0XHRcdFx0JiYgaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgdG9sZXJhbmNlUGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBpc0Nsb3NlRW5vdWdoKHNlZ21lbnQuX3BvaW50LCBzdHJva2VQYWRkaW5nKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5lbmRzICYmICFvcHRpb25zLnNlZ21lbnRzICYmICFjbG9zZWQpIHtcblx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbMF0sIHRydWUpXG5cdFx0XHRcdFx0fHwgY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0sIHRydWUpKVxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5zZWdtZW50cyB8fCBvcHRpb25zLmhhbmRsZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKylcblx0XHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tpXSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9XG5cdFx0aWYgKHJhZGl1cyAhPT0gbnVsbCkge1xuXHRcdFx0bG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYykge1xuXHRcdFx0XHR2YXIgcGFyYW1ldGVyID0gbG9jLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0XHRpZiAocGFyYW1ldGVyID09PSAwIHx8IHBhcmFtZXRlciA9PT0gMSAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0XHRpZiAoIWNoZWNrU2VnbWVudFN0cm9rZShsb2MuZ2V0U2VnbWVudCgpKSlcblx0XHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHN0cm9rZVBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFsb2MgJiYgam9pbiA9PT0gJ21pdGVyJyAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdFx0XHRpZiAocG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudC5fcG9pbnQpIDw9IG1pdGVyTGltaXRcblx0XHRcdFx0XHRcdFx0JiYgY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpKSB7XG5cdFx0XHRcdFx0XHRsb2MgPSBzZWdtZW50LmdldExvY2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICFsb2MgJiYgaGl0RmlsbCAmJiB0aGlzLl9jb250YWlucyhwb2ludClcblx0XHRcdFx0fHwgbG9jICYmICFoaXRTdHJva2UgJiYgIWhpdEN1cnZlc1xuXHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpXG5cdFx0XHRcdFx0OiBsb2Ncblx0XHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdChoaXRTdHJva2UgPyAnc3Ryb2tlJyA6ICdjdXJ2ZScsIHRoaXMsIHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IGxvYyxcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGxvYy5nZXRQb2ludCgpXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHR9XG5cbn0sIEJhc2UuZWFjaChbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KG9mZnNldCwgaXNQYXJhbWV0ZXIpO1xuXHRcdFx0cmV0dXJuIGxvYyAmJiBsb2NbbmFtZV0oKTtcblx0XHR9O1xuXHR9LFxue1xuXHRiZWFuczogZmFsc2UsXG5cblx0X2dldE9mZnNldDogZnVuY3Rpb24obG9jYXRpb24pIHtcblx0XHR2YXIgaW5kZXggPSBsb2NhdGlvbiAmJiBsb2NhdGlvbi5nZXRJbmRleCgpO1xuXHRcdGlmIChpbmRleCAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcblx0XHRcdFx0b2Zmc2V0ICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpbmRleF0sXG5cdFx0XHRcdHBhcmFtZXRlciA9IGxvY2F0aW9uLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0aWYgKHBhcmFtZXRlciA+IDApXG5cdFx0XHRcdG9mZnNldCArPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcik7XG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGxvYyA9IGN1cnZlc1tpXS5nZXRMb2NhdGlvbk9mKHBvaW50KTtcblx0XHRcdGlmIChsb2MpXG5cdFx0XHRcdHJldHVybiBsb2M7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bGVuZ3RoID0gMDtcblx0XHRpZiAoaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciBpbmRleCA9IH5+b2Zmc2V0O1xuXHRcdFx0cmV0dXJuIGN1cnZlc1tpbmRleF0uZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBpbmRleCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHN0YXJ0ID0gbGVuZ3RoLFxuXHRcdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGxlbmd0aCArPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChsZW5ndGggPiBvZmZzZXQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gc3RhcnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2Zmc2V0IDw9IHRoaXMuZ2V0TGVuZ3RoKCkpXG5cdFx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24oY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSwgMSk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluTG9jID0gbnVsbDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MuX2Rpc3RhbmNlIDwgbWluRGlzdCkge1xuXHRcdFx0XHRtaW5EaXN0ID0gbG9jLl9kaXN0YW5jZTtcblx0XHRcdFx0bWluTG9jID0gbG9jO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWluTG9jO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZ2V0UG9pbnQoKTtcblx0fVxufSksIG5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBkcmF3SGFuZGxlcyhjdHgsIHNlZ21lbnRzLCBtYXRyaXgsIHNpemUpIHtcblx0XHR2YXIgaGFsZiA9IHNpemUgLyAyO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd0hhbmRsZShpbmRleCkge1xuXHRcdFx0dmFyIGhYID0gY29vcmRzW2luZGV4XSxcblx0XHRcdFx0aFkgPSBjb29yZHNbaW5kZXggKyAxXTtcblx0XHRcdGlmIChwWCAhPSBoWCB8fCBwWSAhPSBoWSkge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8ocFgsIHBZKTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhoWCwgaFkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyhoWCwgaFksIGhhbGYsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdHZhciBzdGF0ZSA9IHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLFxuXHRcdFx0XHRwWCA9IGNvb3Jkc1swXSxcblx0XHRcdFx0cFkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoc3RhdGUgJiAxKVxuXHRcdFx0XHRkcmF3SGFuZGxlKDIpO1xuXHRcdFx0aWYgKHN0YXRlICYgMilcblx0XHRcdFx0ZHJhd0hhbmRsZSg0KTtcblx0XHRcdGN0eC5maWxsUmVjdChwWCAtIGhhbGYsIHBZIC0gaGFsZiwgc2l6ZSwgc2l6ZSk7XG5cdFx0XHRpZiAoIShzdGF0ZSAmIDQpKSB7XG5cdFx0XHRcdHZhciBmaWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmICsgMSwgcFkgLSBoYWxmICsgMSwgc2l6ZSAtIDIsIHNpemUgLSAyKTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3U2VnbWVudHMoY3R4LCBwYXRoLCBtYXRyaXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFk7XG5cblx0XHRmdW5jdGlvbiBkcmF3U2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRcdGN1clggPSBjb29yZHNbMF07XG5cdFx0XHRcdGN1clkgPSBjb29yZHNbMV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludDtcblx0XHRcdFx0Y3VyWCA9IHBvaW50Ll94O1xuXHRcdFx0XHRjdXJZID0gcG9pbnQuX3k7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdFx0aW5ZID0gY29vcmRzWzNdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdFx0XHRpblggPSBjdXJYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRcdGluWSA9IGN1clkgKyBoYW5kbGUuX3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhvdXRYLCBvdXRZLCBpblgsIGluWSwgY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdFx0b3V0WSA9IGNvb3Jkc1s1XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRcdG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcblx0XHRcdFx0b3V0WSA9IHByZXZZICsgaGFuZGxlLl95O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRkcmF3U2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHBhdGguX2Nsb3NlZCAmJiBsZW5ndGggPiAwKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHR2YXIgZG9udFN0YXJ0ID0gcGFyYW0uZG9udFN0YXJ0LFxuXHRcdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdFx0ZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdGRhc2hMZW5ndGggPSAhcGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoICYmIGhhc1N0cm9rZVxuXHRcdFx0XHRcdFx0JiYgZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGg7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0ICYmIHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRcdGN0eC5jdXJyZW50UGF0aCA9IHRoaXMuX2N1cnJlbnRQYXRoO1xuXHRcdFx0fSBlbHNlIGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSAmJiAhZGFzaExlbmd0aCB8fCBkb250UGFpbnQpIHtcblx0XHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgc3Ryb2tlTWF0cml4KTtcblx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRPZmZzZXQoaSkge1xuXHRcdFx0XHRyZXR1cm4gZGFzaEFycmF5WygoaSAlIGRhc2hMZW5ndGgpICsgZGFzaExlbmd0aCkgJSBkYXNoTGVuZ3RoXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuXHRcdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhc1N0cm9rZSkge1xuXHRcdFx0XHRcdGlmIChkYXNoTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0dmFyIGl0ZXJhdG9yID0gbmV3IFBhdGhJdGVyYXRvcih0aGlzLCAzMiwgMC4yNSxcblx0XHRcdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgpLFxuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSBpdGVyYXRvci5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGZyb20gPSAtc3R5bGUuZ2V0RGFzaE9mZnNldCgpLCB0byxcblx0XHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHRmcm9tID0gZnJvbSAlIGxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tID4gMCkge1xuXHRcdFx0XHRcdFx0XHRmcm9tIC09IGdldE9mZnNldChpLS0pICsgZ2V0T2Zmc2V0KGktLSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR0byA9IGZyb20gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdFx0aWYgKGZyb20gPiAwIHx8IHRvID4gMClcblx0XHRcdFx0XHRcdFx0XHRpdGVyYXRvci5kcmF3UGFydChjdHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdE1hdGgubWF4KGZyb20sIDApLCBNYXRoLm1heCh0bywgMCkpO1xuXHRcdFx0XHRcdFx0XHRmcm9tID0gdG8gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBtYXRyaXgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0ZHJhd0hhbmRsZXMoY3R4LCB0aGlzLl9zZWdtZW50cywgbWF0cml4LCBwYXBlci5zZXR0aW5ncy5oYW5kbGVTaXplKTtcblx0XHR9XG5cdH07XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocykge1xuXHRcdHZhciBuID0gcmhzLmxlbmd0aCxcblx0XHRcdHggPSBbXSxcblx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0YiA9IDI7XG5cdFx0eFswXSA9IHJoc1swXSAvIGI7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0XHRcdHRtcFtpXSA9IDEgLyBiO1xuXHRcdFx0YiA9IChpIDwgbiAtIDEgPyA0IDogMikgLSB0bXBbaV07XG5cdFx0XHR4W2ldID0gKHJoc1tpXSAtIHhbaSAtIDFdKSAvIGI7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR4W24gLSBpIC0gMV0gLT0gdG1wW24gLSBpXSAqIHhbbiAtIGldO1xuXHRcdH1cblx0XHRyZXR1cm4geDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c21vb3RoOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0XHRzaXplID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG5cdFx0XHRcdG4gPSBzaXplLFxuXHRcdFx0XHRvdmVybGFwID0gMDtcblx0XHRcdGlmIChzaXplIDw9IDIpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0b3ZlcmxhcCA9IE1hdGgubWluKHNpemUsIDQpO1xuXHRcdFx0XHRuICs9IE1hdGgubWluKHNpemUsIG92ZXJsYXApICogMjtcblx0XHRcdH1cblx0XHRcdHZhciBrbm90cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspXG5cdFx0XHRcdGtub3RzW2kgKyBvdmVybGFwXSA9IHNlZ21lbnRzW2ldLl9wb2ludDtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGFwOyBpKyspIHtcblx0XHRcdFx0XHRrbm90c1tpXSA9IHNlZ21lbnRzW2kgKyBzaXplIC0gb3ZlcmxhcF0uX3BvaW50O1xuXHRcdFx0XHRcdGtub3RzW2kgKyBzaXplICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciByaHMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKVxuXHRcdFx0XHRyaHNbaV0gPSA0ICoga25vdHNbaV0uX3ggKyAyICoga25vdHNbaSArIDFdLl94O1xuXHRcdFx0cmhzWzBdID0ga25vdHNbMF0uX3ggKyAyICoga25vdHNbMV0uX3g7XG5cdFx0XHRyaHNbbiAtIDFdID0gMyAqIGtub3RzW24gLSAxXS5feDtcblx0XHRcdHZhciB4ID0gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocyk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl95ICsgMiAqIGtub3RzW2kgKyAxXS5feTtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl95ICsgMiAqIGtub3RzWzFdLl95O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3k7XG5cdFx0XHR2YXIgeSA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBqID0gc2l6ZTsgaSA8IG92ZXJsYXA7IGkrKywgaisrKSB7XG5cdFx0XHRcdFx0dmFyIGYxID0gaSAvIG92ZXJsYXAsXG5cdFx0XHRcdFx0XHRmMiA9IDEgLSBmMSxcblx0XHRcdFx0XHRcdGllID0gaSArIG92ZXJsYXAsXG5cdFx0XHRcdFx0XHRqZSA9IGogKyBvdmVybGFwO1xuXHRcdFx0XHRcdHhbal0gPSB4W2ldICogZjEgKyB4W2pdICogZjI7XG5cdFx0XHRcdFx0eVtqXSA9IHlbaV0gKiBmMSArIHlbal0gKiBmMjtcblx0XHRcdFx0XHR4W2plXSA9IHhbaWVdICogZjIgKyB4W2plXSAqIGYxO1xuXHRcdFx0XHRcdHlbamVdID0geVtpZV0gKiBmMiArIHlbamVdICogZjE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bi0tO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhhbmRsZUluID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSBvdmVybGFwOyBpIDw9IG4gLSBvdmVybGFwOyBpKyspIHtcblx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpIC0gb3ZlcmxhcF07XG5cdFx0XHRcdGlmIChoYW5kbGVJbilcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdGlmIChpIDwgbikge1xuXHRcdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlT3V0KFxuXHRcdFx0XHRcdFx0XHRuZXcgUG9pbnQoeFtpXSwgeVtpXSkuc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdFx0XHRoYW5kbGVJbiA9IGkgPCBuIC0gMVxuXHRcdFx0XHRcdFx0XHQ/IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHQyICoga25vdHNbaSArIDFdLl94IC0geFtpICsgMV0sXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feSAtIHlbaSArIDFdKVxuXHRcdFx0XHRcdFx0XHQ6IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3ggKyB4W24gLSAxXSkgLyAyLFxuXHRcdFx0XHRcdFx0XHRcdChrbm90c1tuXS5feSArIHlbbiAtIDFdKSAvIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkICYmIGhhbmRsZUluKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbMF07XG5cdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlSW4oaGFuZGxlSW4uc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRTZWdtZW50KHRoYXQpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGF0Ll9zZWdtZW50cztcblx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG5cdFx0cmV0dXJuIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRtb3ZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHR0aGlzLnJlbW92ZVNlZ21lbnQoMCk7XG5cdFx0XHRpZiAoIXNlZ21lbnRzLmxlbmd0aClcblx0XHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKSBdKTtcblx0XHR9LFxuXG5cdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbW92ZUJ5KCkgaXMgdW5zdXBwb3J0ZWQgb24gUGF0aCBpdGVtcy4nKTtcblx0XHR9LFxuXG5cdFx0bGluZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdGN1YmljQ3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKTtcblx0XHRcdGN1cnJlbnQuc2V0SGFuZGxlT3V0KGhhbmRsZTEuc3VidHJhY3QoY3VycmVudC5fcG9pbnQpKTtcblx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KHRvLCBoYW5kbGUyLnN1YnRyYWN0KHRvKSkgXSk7XG5cdFx0fSxcblxuXHRcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0aGFuZGxlLmFkZChjdXJyZW50LnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSxcblx0XHRcdFx0aGFuZGxlLmFkZCh0by5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdHRvXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRjdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aHJvdWdoID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dCA9IEJhc2UucGljayhCYXNlLnJlYWQoYXJndW1lbnRzKSwgMC41KSxcblx0XHRcdFx0dDEgPSAxIC0gdCxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0aGFuZGxlID0gdGhyb3VnaC5zdWJ0cmFjdChjdXJyZW50Lm11bHRpcGx5KHQxICogdDEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdCh0by5tdWx0aXBseSh0ICogdCkpLmRpdmlkZSgyICogdCAqIHQxKTtcblx0XHRcdGlmIChoYW5kbGUuaXNOYU4oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdDYW5ub3QgcHV0IGEgY3VydmUgdGhyb3VnaCBwb2ludHMgd2l0aCBwYXJhbWV0ZXIgPSAnICsgdCk7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oaGFuZGxlLCB0byk7XG5cdFx0fSxcblxuXHRcdGFyY1RvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyksXG5cdFx0XHRcdGZyb20gPSBjdXJyZW50Ll9wb2ludCxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRocm91Z2gsXG5cdFx0XHRcdHBlZWsgPSBCYXNlLnBlZWsoYXJndW1lbnRzKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKHBlZWssIHRydWUpLFxuXHRcdFx0XHRjZW50ZXIsIGV4dGVudCwgdmVjdG9yLCBtYXRyaXg7XG5cdFx0XHRpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHZhciBtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHR0aHJvdWdoID0gbWlkZGxlLmFkZChtaWRkbGUuc3VidHJhY3QoZnJvbSkucm90YXRlKFxuXHRcdFx0XHRcdFx0Y2xvY2t3aXNlID8gLTkwIDogOTApKTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5yZW1haW4oYXJndW1lbnRzKSA8PSAyKSB7XG5cdFx0XHRcdHRocm91Z2ggPSB0bztcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubGluZVRvKHRvKTtcblx0XHRcdFx0dmFyIHJvdGF0aW9uID0gQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0Y2xvY2t3aXNlID0gISFCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRsYXJnZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRwdCA9IGZyb20uc3VidHJhY3QobWlkZGxlKS5yb3RhdGUoLXJvdGF0aW9uKSxcblx0XHRcdFx0XHR4ID0gcHQueCxcblx0XHRcdFx0XHR5ID0gcHQueSxcblx0XHRcdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0XHRFUFNJTE9OID0gMWUtMTEsXG5cdFx0XHRcdFx0cnggPSBhYnMocmFkaXVzLndpZHRoKSxcblx0XHRcdFx0XHRyeSA9IGFicyhyYWRpdXMuaGVpZ2h0KSxcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeCxcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeSxcblx0XHRcdFx0XHR4U3EgPSAgeCAqIHgsXG5cdFx0XHRcdFx0eVNxID0gIHkgKiB5O1xuXHRcdFx0XHR2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KHhTcSAvIHJ4U3EgKyB5U3EgLyByeVNxKTtcblx0XHRcdFx0aWYgKGZhY3RvciA+IDEpIHtcblx0XHRcdFx0XHRyeCAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0cnkgKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ4U3EgPSByeCAqIHJ4O1xuXHRcdFx0XHRcdHJ5U3EgPSByeSAqIHJ5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZhY3RvciA9IChyeFNxICogcnlTcSAtIHJ4U3EgKiB5U3EgLSByeVNxICogeFNxKSAvXG5cdFx0XHRcdFx0XHQocnhTcSAqIHlTcSArIHJ5U3EgKiB4U3EpO1xuXHRcdFx0XHRpZiAoYWJzKGZhY3RvcikgPCBFUFNJTE9OKVxuXHRcdFx0XHRcdGZhY3RvciA9IDA7XG5cdFx0XHRcdGlmIChmYWN0b3IgPCAwKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHRjZW50ZXIgPSBuZXcgUG9pbnQocnggKiB5IC8gcnksIC1yeSAqIHggLyByeClcblx0XHRcdFx0XHRcdC5tdWx0aXBseSgobGFyZ2UgPT09IGNsb2Nrd2lzZSA/IC0xIDogMSlcblx0XHRcdFx0XHRcdFx0KiBNYXRoLnNxcnQoZmFjdG9yKSlcblx0XHRcdFx0XHRcdC5yb3RhdGUocm90YXRpb24pLmFkZChtaWRkbGUpO1xuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKGNlbnRlcikucm90YXRlKHJvdGF0aW9uKVxuXHRcdFx0XHRcdFx0LnNjYWxlKHJ4LCByeSk7XG5cdFx0XHRcdHZlY3RvciA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShmcm9tKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUobWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRvKSk7XG5cdFx0XHRcdGlmICghY2xvY2t3aXNlICYmIGV4dGVudCA+IDApXG5cdFx0XHRcdFx0ZXh0ZW50IC09IDM2MDtcblx0XHRcdFx0ZWxzZSBpZiAoY2xvY2t3aXNlICYmIGV4dGVudCA8IDApXG5cdFx0XHRcdFx0ZXh0ZW50ICs9IDM2MDtcblx0XHRcdH1cblx0XHRcdGlmICh0aHJvdWdoKSB7XG5cdFx0XHRcdHZhciBsMSA9IG5ldyBMaW5lKGZyb20uYWRkKHRocm91Z2gpLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRcdFx0dGhyb3VnaC5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsMiA9IG5ldyBMaW5lKHRocm91Z2guYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRvLnN1YnRyYWN0KHRocm91Z2gpLnJvdGF0ZSg5MCksIHRydWUpLFxuXHRcdFx0XHRcdGxpbmUgPSBuZXcgTGluZShmcm9tLCB0byksXG5cdFx0XHRcdFx0dGhyb3VnaFNpZGUgPSBsaW5lLmdldFNpZGUodGhyb3VnaCk7XG5cdFx0XHRcdGNlbnRlciA9IGwxLmludGVyc2VjdChsMiwgdHJ1ZSk7XG5cdFx0XHRcdGlmICghY2VudGVyKSB7XG5cdFx0XHRcdFx0aWYgKCF0aHJvdWdoU2lkZSlcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmVjdG9yID0gZnJvbS5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZSh0by5zdWJ0cmFjdChjZW50ZXIpKTtcblx0XHRcdFx0dmFyIGNlbnRlclNpZGUgPSBsaW5lLmdldFNpZGUoY2VudGVyKTtcblx0XHRcdFx0aWYgKGNlbnRlclNpZGUgPT09IDApIHtcblx0XHRcdFx0XHRleHRlbnQgPSB0aHJvdWdoU2lkZSAqIE1hdGguYWJzKGV4dGVudCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhyb3VnaFNpZGUgPT09IGNlbnRlclNpZGUpIHtcblx0XHRcdFx0XHRleHRlbnQgKz0gZXh0ZW50IDwgMCA/IDM2MCA6IC0zNjA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBleHQgPSBNYXRoLmFicyhleHRlbnQpLFxuXHRcdFx0XHRjb3VudCA9IGV4dCA+PSAzNjAgPyA0IDogTWF0aC5jZWlsKGV4dCAvIDkwKSxcblx0XHRcdFx0aW5jID0gZXh0ZW50IC8gY291bnQsXG5cdFx0XHRcdGhhbGYgPSBpbmMgKiBNYXRoLlBJIC8gMzYwLFxuXHRcdFx0XHR6ID0gNCAvIDMgKiBNYXRoLnNpbihoYWxmKSAvICgxICsgTWF0aC5jb3MoaGFsZikpLFxuXHRcdFx0XHRzZWdtZW50cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgcHQgPSB0byxcblx0XHRcdFx0XHRvdXQgPSBudWxsO1xuXHRcdFx0XHRpZiAoaSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0b3V0ID0gdmVjdG9yLnJvdGF0ZSg5MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvcik7XG5cdFx0XHRcdFx0XHRvdXQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQob3V0KSlcblx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdCA9IGNlbnRlci5hZGQodmVjdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChvdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBfaW4gPSB2ZWN0b3Iucm90YXRlKC05MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0X2luID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKF9pbikpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwdCwgX2luLCBvdXQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ZWN0b3IgPSB2ZWN0b3Iucm90YXRlKGluYyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMpO1xuXHRcdH0sXG5cblx0XHRsaW5lQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5saW5lVG8oY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0Y3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBhcmFtZXRlciA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdXJ2ZVRvKGN1cnJlbnQuYWRkKHRocm91Z2gpLCBjdXJyZW50LmFkZCh0byksIHBhcmFtZXRlcik7XG5cdFx0fSxcblxuXHRcdGN1YmljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUxKSwgY3VycmVudC5hZGQoaGFuZGxlMiksXG5cdFx0XHRcdFx0Y3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUpLCBjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRhcmNCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0cG9pbnQgPSBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3VtZW50cykpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2soQmFzZS5wZWVrKGFyZ3VtZW50cyksIHRydWUpO1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjbG9ja3dpc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0XHRpZiAoam9pbilcblx0XHRcdFx0dGhpcy5qb2luKCk7XG5cdFx0fVxuXHR9O1xufSwge1xuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0cmV0dXJuIFBhdGhbZ2V0dGVyXSh0aGlzLl9zZWdtZW50cywgdGhpcy5fY2xvc2VkLCB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRcdG1hdHJpeCk7XG5cdH0sXG5cbnN0YXRpY3M6IHtcblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0dmFyIHN1bSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciB2ID0gQ3VydmUuZ2V0VmFsdWVzKFxuXHRcdFx0XHRcdHNlZ21lbnRzW2ldLCBzZWdtZW50c1tpICsgMSA8IGwgPyBpICsgMSA6IDBdKTtcblx0XHRcdGZvciAodmFyIGogPSAyOyBqIDwgODsgaiArPSAyKVxuXHRcdFx0XHRzdW0gKz0gKHZbaiAtIDJdIC0gdltqXSkgKiAodltqICsgMV0gKyB2W2ogLSAxXSk7XG5cdFx0fVxuXHRcdHJldHVybiBzdW0gPiAwO1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgc3Ryb2tlUGFkZGluZykge1xuXHRcdHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdO1xuXHRcdGlmICghZmlyc3QpXG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRwcmV2Q29vcmRzID0gZmlyc3QuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpLCBmYWxzZSksXG5cdFx0XHRtaW4gPSBwcmV2Q29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IG5ldyBBcnJheSgyKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuXHRcdFx0XHRDdXJ2ZS5fYWRkQm91bmRzKFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaV0sXG5cdFx0XHRcdFx0cHJldkNvb3Jkc1tpICsgNF0sXG5cdFx0XHRcdFx0Y29vcmRzW2kgKyAyXSxcblx0XHRcdFx0XHRjb29yZHNbaV0sXG5cdFx0XHRcdFx0aSwgc3Ryb2tlUGFkZGluZyA/IHN0cm9rZVBhZGRpbmdbaV0gOiAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRtcCA9IHByZXZDb29yZHM7XG5cdFx0XHRwcmV2Q29vcmRzID0gY29vcmRzO1xuXHRcdFx0Y29vcmRzID0gdG1wO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0cHJvY2Vzc1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmIChjbG9zZWQpXG5cdFx0XHRwcm9jZXNzU2VnbWVudChmaXJzdCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcblx0fSxcblxuXHRnZXRTdHJva2VCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgpIHtcblx0XHRpZiAoIXN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0cmV0dXJuIFBhdGguZ2V0Qm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgpO1xuXHRcdHZhciBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGggLSAoY2xvc2VkID8gMCA6IDEpLFxuXHRcdFx0cmFkaXVzID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIsXG5cdFx0XHRwYWRkaW5nID0gUGF0aC5fZ2V0UGVuUGFkZGluZyhyYWRpdXMsIG1hdHJpeCksXG5cdFx0XHRib3VuZHMgPSBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBwYWRkaW5nKSxcblx0XHRcdGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG5cdFx0XHRjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcblx0XHRcdG1pdGVyTGltaXQgPSByYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0dmFyIGpvaW5Cb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBTaXplKHBhZGRpbmcpLm11bHRpcGx5KDIpKTtcblxuXHRcdGZ1bmN0aW9uIGFkZChwb2ludCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLmluY2x1ZGUobWF0cml4XG5cdFx0XHRcdD8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb2ludCwgcG9pbnQpIDogcG9pbnQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFJvdW5kKHNlZ21lbnQpIHtcblx0XHRcdGJvdW5kcyA9IGJvdW5kcy51bml0ZShqb2luQm91bmRzLnNldENlbnRlcihtYXRyaXhcblx0XHRcdFx0PyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHNlZ21lbnQuX3BvaW50KSA6IHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkSm9pbihzZWdtZW50LCBqb2luKSB7XG5cdFx0XHR2YXIgaGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVJbixcblx0XHRcdFx0aGFuZGxlT3V0ID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0aWYgKGpvaW4gPT09ICdyb3VuZCcgfHwgIWhhbmRsZUluLmlzWmVybygpICYmICFoYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0XHQmJiBoYW5kbGVJbi5pc0NvbGluZWFyKGhhbmRsZU91dCkpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZENhcChzZWdtZW50LCBjYXApIHtcblx0XHRcdGlmIChjYXAgPT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbaV0sIGpvaW4pO1xuXHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbMF0sIGpvaW4pO1xuXHRcdH0gZWxzZSBpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzWzBdLCBjYXApO1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLCBjYXApO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdF9nZXRQZW5QYWRkaW5nOiBmdW5jdGlvbihyYWRpdXMsIG1hdHJpeCkge1xuXHRcdGlmICghbWF0cml4KVxuXHRcdFx0cmV0dXJuIFtyYWRpdXMsIHJhZGl1c107XG5cdFx0dmFyIG14ID0gbWF0cml4LnNoaWZ0bGVzcygpLFxuXHRcdFx0aG9yID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludChyYWRpdXMsIDApKSxcblx0XHRcdHZlciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQoMCwgcmFkaXVzKSksXG5cdFx0XHRwaGkgPSBob3IuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdGEgPSBob3IuZ2V0TGVuZ3RoKCksXG5cdFx0XHRiID0gdmVyLmdldExlbmd0aCgpO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbihwaGkpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MocGhpKSxcblx0XHRcdHRhbiA9IE1hdGgudGFuKHBoaSksXG5cdFx0XHR0eCA9IC1NYXRoLmF0YW4oYiAqIHRhbiAvIGEpLFxuXHRcdFx0dHkgPSBNYXRoLmF0YW4oYiAvICh0YW4gKiBhKSk7XG5cdFx0cmV0dXJuIFtNYXRoLmFicyhhICogTWF0aC5jb3ModHgpICogY29zIC0gYiAqIE1hdGguc2luKHR4KSAqIHNpbiksXG5cdFx0XHRcdE1hdGguYWJzKGIgKiBNYXRoLnNpbih0eSkgKiBjb3MgKyBhICogTWF0aC5jb3ModHkpICogc2luKV07XG5cdH0sXG5cblx0X2FkZEJldmVsSm9pbjogZnVuY3Rpb24oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBjdXJ2ZTIgPSBzZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRjdXJ2ZTEgPSBjdXJ2ZTIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdHBvaW50ID0gY3VydmUyLmdldFBvaW50QXQoMCwgdHJ1ZSksXG5cdFx0XHRub3JtYWwxID0gY3VydmUxLmdldE5vcm1hbEF0KDEsIHRydWUpLFxuXHRcdFx0bm9ybWFsMiA9IGN1cnZlMi5nZXROb3JtYWxBdCgwLCB0cnVlKSxcblx0XHRcdHN0ZXAgPSBub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMikgPCAwID8gLXJhZGl1cyA6IHJhZGl1cztcblx0XHRub3JtYWwxLnNldExlbmd0aChzdGVwKTtcblx0XHRub3JtYWwyLnNldExlbmd0aChzdGVwKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQpO1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHR9XG5cdFx0aWYgKGpvaW4gPT09ICdtaXRlcicpIHtcblx0XHRcdHZhciBjb3JuZXIgPSBuZXcgTGluZShcblx0XHRcdFx0XHRwb2ludC5hZGQobm9ybWFsMSksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwxLnksIG5vcm1hbDEueCksIHRydWVcblx0XHRcdFx0KS5pbnRlcnNlY3QobmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDIpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMi55LCBub3JtYWwyLngpLCB0cnVlXG5cdFx0XHRcdCksIHRydWUpO1xuXHRcdFx0aWYgKGNvcm5lciAmJiBwb2ludC5nZXREaXN0YW5jZShjb3JuZXIpIDw9IG1pdGVyTGltaXQpIHtcblx0XHRcdFx0YWRkUG9pbnQoY29ybmVyKTtcblx0XHRcdFx0aWYgKCFhcmVhKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFhcmVhKVxuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMikpO1xuXHR9LFxuXG5cdF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50LFxuXHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpLFxuXHRcdFx0bm9ybWFsID0gbG9jLmdldE5vcm1hbCgpLm5vcm1hbGl6ZShyYWRpdXMpO1xuXHRcdGlmIChhcmVhKSB7XG5cdFx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHR9XG5cdFx0aWYgKGNhcCA9PT0gJ3NxdWFyZScpXG5cdFx0XHRwb2ludCA9IHBvaW50LmFkZChub3JtYWwucm90YXRlKGxvYy5nZXRQYXJhbWV0ZXIoKSA9PT0gMCA/IC05MCA6IDkwKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuXHRcdGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgc3Ryb2tlUGFkZGluZyxcblx0XHRcdGpvaW5QYWRkaW5nKSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHgxID0gSW5maW5pdHksXG5cdFx0XHR4MiA9IC14MSxcblx0XHRcdHkxID0geDEsXG5cdFx0XHR5MiA9IHgyO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG5cdFx0XHRcdHZhciBwYWRkaW5nID0gaiA9PT0gMCA/IGpvaW5QYWRkaW5nIDogc3Ryb2tlUGFkZGluZyxcblx0XHRcdFx0XHRwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nWzBdIDogMCxcblx0XHRcdFx0XHRwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nWzFdIDogMCxcblx0XHRcdFx0XHR4ID0gY29vcmRzW2pdLFxuXHRcdFx0XHRcdHkgPSBjb29yZHNbaiArIDFdLFxuXHRcdFx0XHRcdHhuID0geCAtIHBhZGRpbmdYLFxuXHRcdFx0XHRcdHh4ID0geCArIHBhZGRpbmdYLFxuXHRcdFx0XHRcdHluID0geSAtIHBhZGRpbmdZLFxuXHRcdFx0XHRcdHl4ID0geSArIHBhZGRpbmdZO1xuXHRcdFx0XHRpZiAoeG4gPCB4MSkgeDEgPSB4bjtcblx0XHRcdFx0aWYgKHh4ID4geDIpIHgyID0geHg7XG5cdFx0XHRcdGlmICh5biA8IHkxKSB5MSA9IHluO1xuXHRcdFx0XHRpZiAoeXggPiB5MikgeTIgPSB5eDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRnZXRSb3VnaEJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCkge1xuXHRcdHZhciBzdHJva2VSYWRpdXMgPSBzdHlsZS5oYXNTdHJva2UoKSA/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyIDogMCxcblx0XHRcdGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXM7XG5cdFx0aWYgKHN0cm9rZVJhZGl1cyA+IDApIHtcblx0XHRcdGlmIChzdHlsZS5nZXRTdHJva2VKb2luKCkgPT09ICdtaXRlcicpXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlQ2FwKCkgPT09ICdzcXVhcmUnKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gTWF0aC5tYXgoam9pblJhZGl1cywgc3Ryb2tlUmFkaXVzICogTWF0aC5zcXJ0KDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIFBhdGguZ2V0SGFuZGxlQm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsXG5cdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoc3Ryb2tlUmFkaXVzLCBtYXRyaXgpLFxuXHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKGpvaW5SYWRpdXMsIG1hdHJpeCkpO1xuXHR9XG59fSk7XG5cblBhdGguaW5qZWN0KHsgc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNixcblx0XHRlbGxpcHNlU2VnbWVudHMgPSBbXG5cdFx0XHRuZXcgU2VnbWVudChbLTEsIDBdLCBbMCwga2FwcGEgXSwgWzAsIC1rYXBwYV0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIC0xXSwgWy1rYXBwYSwgMF0sIFtrYXBwYSwgMCBdKSxcblx0XHRcdG5ldyBTZWdtZW50KFsxLCAwXSwgWzAsIC1rYXBwYV0sIFswLCBrYXBwYSBdKSxcblx0XHRcdG5ldyBTZWdtZW50KFswLCAxXSwgW2thcHBhLCAwIF0sIFsta2FwcGEsIDBdKVxuXHRcdF07XG5cblx0ZnVuY3Rpb24gY3JlYXRlUGF0aChzZWdtZW50cywgY2xvc2VkLCBhcmdzKSB7XG5cdFx0dmFyIHByb3BzID0gQmFzZS5nZXROYW1lZChhcmdzKSxcblx0XHRcdHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IGZhbHNlICYmIEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRwYXRoLl9hZGQoc2VnbWVudHMpO1xuXHRcdHBhdGguX2Nsb3NlZCA9IGNsb3NlZDtcblx0XHRyZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxsaXBzZShjZW50ZXIsIHJhZGl1cywgYXJncykge1xuXHRcdHZhciBzZWdtZW50cyA9IG5ldyBBcnJheSg0KTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBlbGxpcHNlU2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KFxuXHRcdFx0XHRzZWdtZW50Ll9wb2ludC5tdWx0aXBseShyYWRpdXMpLmFkZChjZW50ZXIpLFxuXHRcdFx0XHRzZWdtZW50Ll9oYW5kbGVJbi5tdWx0aXBseShyYWRpdXMpLFxuXHRcdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQubXVsdGlwbHkocmFkaXVzKVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRMaW5lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKFtcblx0XHRcdFx0bmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSksXG5cdFx0XHRcdG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpKVxuXHRcdFx0XSwgZmFsc2UsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgbmV3IFNpemUocmFkaXVzKSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0UmVjdGFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmd1bWVudHMsICdyZWN0YW5nbGUnKSxcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJywgMCxcblx0XHRcdFx0XHRcdHsgcmVhZE51bGw6IHRydWUgfSksXG5cdFx0XHRcdGJsID0gcmVjdC5nZXRCb3R0b21MZWZ0KHRydWUpLFxuXHRcdFx0XHR0bCA9IHJlY3QuZ2V0VG9wTGVmdCh0cnVlKSxcblx0XHRcdFx0dHIgPSByZWN0LmdldFRvcFJpZ2h0KHRydWUpLFxuXHRcdFx0XHRiciA9IHJlY3QuZ2V0Qm90dG9tUmlnaHQodHJ1ZSksXG5cdFx0XHRcdHNlZ21lbnRzO1xuXHRcdFx0aWYgKCFyYWRpdXMgfHwgcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHRcdHNlZ21lbnRzID0gW1xuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyKVxuXHRcdFx0XHRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5taW4ocmFkaXVzLCByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpKTtcblx0XHRcdFx0dmFyIHJ4ID0gcmFkaXVzLndpZHRoLFxuXHRcdFx0XHRcdHJ5ID0gcmFkaXVzLmhlaWdodCxcblx0XHRcdFx0XHRoeCA9IHJ4ICoga2FwcGEsXG5cdFx0XHRcdFx0aHkgPSByeSAqIGthcHBhO1xuXHRcdFx0XHRzZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibC5hZGQocngsIDApLCBudWxsLCBbLWh4LCAwXSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwuc3VidHJhY3QoMCwgcnkpLCBbMCwgaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bC5hZGQoMCwgcnkpLCBudWxsLCBbMCwgLWh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwuYWRkKHJ4LCAwKSwgWy1oeCwgMF0sIG51bGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyLnN1YnRyYWN0KHJ4LCAwKSwgbnVsbCwgW2h4LCAwXSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIuYWRkKDAsIHJ5KSwgWzAsIC1oeV0sIG51bGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KDAsIHJ5KSwgbnVsbCwgWzAsIGh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIuc3VidHJhY3QocngsIDApLCBbaHgsIDBdKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJvdW5kUmVjdGFuZ2xlOiAnI1JlY3RhbmdsZScsXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShlbGxpcHNlLmNlbnRlciwgZWxsaXBzZS5yYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdE92YWw6ICcjRWxsaXBzZScsXG5cblx0XHRBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGZyb20gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpLFxuXHRcdFx0XHR0aHJvdWdoID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3Rocm91Z2gnKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKSxcblx0XHRcdFx0cHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IGZhbHNlXG5cdFx0XHRcdFx0XHQmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRwYXRoLm1vdmVUbyhmcm9tKTtcblx0XHRcdHBhdGguYXJjVG8odGhyb3VnaCwgdG8pO1xuXHRcdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzKTtcblx0XHR9LFxuXG5cdFx0UmVndWxhclBvbHlnb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0c2lkZXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdzaWRlcycpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKSxcblx0XHRcdFx0c3RlcCA9IDM2MCAvIHNpZGVzLFxuXHRcdFx0XHR0aHJlZSA9ICEoc2lkZXMgJSAzKSxcblx0XHRcdFx0dmVjdG9yID0gbmV3IFBvaW50KDAsIHRocmVlID8gLXJhZGl1cyA6IHJhZGl1cyksXG5cdFx0XHRcdG9mZnNldCA9IHRocmVlID8gLTEgOiAwLjUsXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHNpZGVzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKFxuXHRcdFx0XHRcdHZlY3Rvci5yb3RhdGUoKGkgKyBvZmZzZXQpICogc3RlcCkpKTtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRTdGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHBvaW50cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3BvaW50cycpICogMixcblx0XHRcdFx0cmFkaXVzMSA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1czEnKSxcblx0XHRcdFx0cmFkaXVzMiA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1czInKSxcblx0XHRcdFx0c3RlcCA9IDM2MCAvIHBvaW50cyxcblx0XHRcdFx0dmVjdG9yID0gbmV3IFBvaW50KDAsIC0xKSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkocG9pbnRzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZCh2ZWN0b3Iucm90YXRlKHN0ZXAgKiBpKVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KGkgJSAyID8gcmFkaXVzMiA6IHJhZGl1czEpKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59fSk7XG5cbnZhciBDb21wb3VuZFBhdGggPSBQYXRoSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDb21wb3VuZFBhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y2hpbGRyZW46IFtdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29tcG91bmRQYXRoKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKSB7XG5cdFx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXRoRGF0YShhcmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24gaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUpIHtcblx0XHRpdGVtcyA9IGluc2VydENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSwgUGF0aCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSAhX3ByZXNlcnZlICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdGlmIChpdGVtLl9jbG9ja3dpc2UgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0aXRlbS5zZXRDbG9ja3dpc2UoaXRlbS5faW5kZXggPT09IDApO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjaGlsZHJlbltpXS5yZXZlcnNlKCk7XG5cdH0sXG5cblx0c21vb3RoOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLnNtb290aCgpO1xuXHR9LFxuXG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gY2hpbGQgJiYgY2hpbGQuaXNDbG9ja3dpc2UoKTtcblx0fSxcblxuXHRzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuXHRcdGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT09ICEhY2xvY2t3aXNlKVxuXHRcdFx0dGhpcy5yZXZlcnNlKCk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldExhc3RTZWdtZW50KCk7XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGN1cnZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y3VydmVzLnB1c2guYXBwbHkoY3VydmVzLCBjaGlsZHJlbltpXS5nZXRDdXJ2ZXMoKSk7XG5cdFx0cmV0dXJuIGN1cnZlcztcblx0fSxcblxuXHRnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RDdXJ2ZSgpO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0Rmlyc3RDdXJ2ZSgpO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0YXJlYSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRhcmVhICs9IGNoaWxkcmVuW2ldLmdldEFyZWEoKTtcblx0XHRyZXR1cm4gYXJlYTtcblx0fVxufSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0cGF0aHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdHBhdGhzLnB1c2goY2hpbGQuZ2V0UGF0aERhdGEoX21hdHJpeCAmJiAhbXguaXNJZGVudGl0eSgpXG5cdFx0XHRcdFx0PyBfbWF0cml4LmNoYWluKG14KSA6IG14LCBfcHJlY2lzaW9uKSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocy5qb2luKCcgJyk7XG5cdH1cbn0sIHtcblx0X2dldENoaWxkSGl0VGVzdE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5jbGFzcyA9PT0gUGF0aCB8fCBvcHRpb25zLnR5cGUgPT09ICdwYXRoJ1xuXHRcdFx0XHQ/IG9wdGlvbnNcblx0XHRcdFx0OiBuZXcgQmFzZShvcHRpb25zLCB7IGZpbGw6IGZhbHNlIH0pO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYgKHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBkb250U3RhcnQ6IHRydWUsIGRvbnRGaW5pc2g6IHRydWUgfSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpO1xuXHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCFwYXJhbS5jbGlwKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuXHRcdFx0aWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzZWxlY3RlZEl0ZW1zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRpZiAoIXNlbGVjdGVkSXRlbXNbY2hpbGQuX2lkXSlcblx0XHRcdFx0Y2hpbGQuX2RyYXdTZWxlY3RlZChjdHgsIG14LmlzSWRlbnRpdHkoKSA/IG1hdHJpeFxuXHRcdFx0XHRcdFx0OiBtYXRyaXguY2hhaW4obXgpKTtcblx0XHR9XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFBhdGgodGhhdCwgY2hlY2spIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGF0Ll9jaGlsZHJlbjtcblx0XHRpZiAoY2hlY2sgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG5cdFx0cmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0dmFyIGZpZWxkcyA9IHtcblx0XHRtb3ZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzKSxcblx0XHRcdFx0cGF0aCA9IGN1cnJlbnQgJiYgY3VycmVudC5pc0VtcHR5KCkgPyBjdXJyZW50IDogbmV3IFBhdGgoKTtcblx0XHRcdGlmIChwYXRoICE9PSBjdXJyZW50KVxuXHRcdFx0XHR0aGlzLmFkZENoaWxkKHBhdGgpO1xuXHRcdFx0cGF0aC5tb3ZlVG8uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSksXG5cdFx0XHRcdGxhc3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm1vdmVUbyhsYXN0ID8gcG9pbnQuYWRkKGxhc3QuX3BvaW50KSA6IHBvaW50KTtcblx0XHR9LFxuXG5cdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbihqb2luKSB7XG5cdFx0XHRnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKS5jbG9zZVBhdGgoam9pbik7XG5cdFx0fVxuXHR9O1xuXG5cdEJhc2UuZWFjaChbJ2xpbmVUbycsICdjdWJpY0N1cnZlVG8nLCAncXVhZHJhdGljQ3VydmVUbycsICdjdXJ2ZVRvJywgJ2FyY1RvJyxcblx0XHRcdCdsaW5lQnknLCAnY3ViaWNDdXJ2ZUJ5JywgJ3F1YWRyYXRpY0N1cnZlQnknLCAnY3VydmVCeScsICdhcmNCeSddLFxuXHRcdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGZpZWxkc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHBhdGggPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHRwYXRoW2tleV0uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0KTtcblxuXHRyZXR1cm4gZmllbGRzO1xufSk7XG5cblBhdGhJdGVtLmluamVjdChuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGNvbXB1dGVCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0b3IsIHN1YnRyYWN0KSB7XG5cdFx0ZnVuY3Rpb24gcHJlcGFyZVBhdGgocGF0aCkge1xuXHRcdFx0cmV0dXJuIHBhdGguY2xvbmUoZmFsc2UpLnJlZHVjZSgpLnJlb3JpZW50KCkudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdH1cblxuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSksXG5cdFx0XHRfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIpO1xuXHRcdGlmICghX3BhdGgxLmlzQ2xvY2t3aXNlKCkpXG5cdFx0XHRfcGF0aDEucmV2ZXJzZSgpO1xuXHRcdGlmIChfcGF0aDIgJiYgIShzdWJ0cmFjdCBeIF9wYXRoMi5pc0Nsb2Nrd2lzZSgpKSlcblx0XHRcdF9wYXRoMi5yZXZlcnNlKCk7XG5cdFx0c3BsaXRQYXRoKF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgbnVsbCwgdHJ1ZSkpO1xuXG5cdFx0dmFyIGNoYWluID0gW10sXG5cdFx0XHR3aW5kaW5ncyA9IFtdLFxuXHRcdFx0bGVuZ3RocyA9IFtdLFxuXHRcdFx0c2VnbWVudHMgPSBbXSxcblx0XHRcdG1vbm9DdXJ2ZXMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGNvbGxlY3QocGF0aHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gcGF0aHNbaV07XG5cdFx0XHRcdHNlZ21lbnRzLnB1c2guYXBwbHkoc2VnbWVudHMsIHBhdGguX3NlZ21lbnRzKTtcblx0XHRcdFx0bW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIHBhdGguX2dldE1vbm9DdXJ2ZXMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29sbGVjdChfcGF0aDEuX2NoaWxkcmVuIHx8IFtfcGF0aDFdKTtcblx0XHRpZiAoX3BhdGgyKVxuXHRcdFx0Y29sbGVjdChfcGF0aDIuX2NoaWxkcmVuIHx8IFtfcGF0aDJdKTtcblx0XHRzZWdtZW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBfYSA9IGEuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0X2IgPSBiLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRyZXR1cm4gIV9hICYmICFfYiB8fCBfYSAmJiBfYiA/IDAgOiBfYSA/IC0xIDogMTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll93aW5kaW5nICE9IG51bGwpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0Y2hhaW4ubGVuZ3RoID0gd2luZGluZ3MubGVuZ3RoID0gbGVuZ3Rocy5sZW5ndGggPSAwO1xuXHRcdFx0dmFyIHRvdGFsTGVuZ3RoID0gMCxcblx0XHRcdFx0c3RhcnRTZWcgPSBzZWdtZW50O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRjaGFpbi5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHRsZW5ndGhzLnB1c2godG90YWxMZW5ndGggKz0gc2VnbWVudC5nZXRDdXJ2ZSgpLmdldExlbmd0aCgpKTtcblx0XHRcdFx0c2VnbWVudCA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdFx0fSB3aGlsZSAoc2VnbWVudCAmJiAhc2VnbWVudC5faW50ZXJzZWN0aW9uICYmIHNlZ21lbnQgIT09IHN0YXJ0U2VnKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSB0b3RhbExlbmd0aCAqIE1hdGgucmFuZG9tKCksXG5cdFx0XHRcdFx0YW1vdW50ID0gbGVuZ3Rocy5sZW5ndGgsXG5cdFx0XHRcdFx0ayA9IDA7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAobGVuZ3Roc1trXSA+PSBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChrID4gMClcblx0XHRcdFx0XHRcdFx0bGVuZ3RoIC09IGxlbmd0aHNbayAtIDFdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICgrK2sgPCBhbW91bnQpO1xuXHRcdFx0XHR2YXIgY3VydmUgPSBjaGFpbltrXS5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRcdHBvaW50ID0gY3VydmUuZ2V0UG9pbnRBdChsZW5ndGgpLFxuXHRcdFx0XHRcdGhvciA9IGN1cnZlLmlzSG9yaXpvbnRhbCgpLFxuXHRcdFx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHRcdFx0aWYgKHBhdGguX3BhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aClcblx0XHRcdFx0XHRwYXRoID0gcGF0aC5fcGFyZW50O1xuXHRcdFx0XHR3aW5kaW5nc1tqXSA9IHN1YnRyYWN0ICYmIF9wYXRoMlxuXHRcdFx0XHRcdFx0JiYgKHBhdGggPT09IF9wYXRoMSAmJiBfcGF0aDIuX2dldFdpbmRpbmcocG9pbnQsIGhvcilcblx0XHRcdFx0XHRcdHx8IHBhdGggPT09IF9wYXRoMiAmJiAhX3BhdGgxLl9nZXRXaW5kaW5nKHBvaW50LCBob3IpKVxuXHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHQ6IGdldFdpbmRpbmcocG9pbnQsIG1vbm9DdXJ2ZXMsIGhvcik7XG5cdFx0XHR9XG5cdFx0XHR3aW5kaW5ncy5zb3J0KCk7XG5cdFx0XHR2YXIgd2luZGluZyA9IHdpbmRpbmdzWzFdO1xuXHRcdFx0Zm9yICh2YXIgaiA9IGNoYWluLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuXHRcdFx0XHRjaGFpbltqXS5fd2luZGluZyA9IHdpbmRpbmc7XG5cdFx0fVxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29tcG91bmRQYXRoKCk7XG5cdFx0cmVzdWx0LmFkZENoaWxkcmVuKHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKSwgdHJ1ZSk7XG5cdFx0X3BhdGgxLnJlbW92ZSgpO1xuXHRcdGlmIChfcGF0aDIpXG5cdFx0XHRfcGF0aDIucmVtb3ZlKCk7XG5cdFx0cmVzdWx0ID0gcmVzdWx0LnJlZHVjZSgpO1xuXHRcdHJlc3VsdC5zZXRTdHlsZShwYXRoMS5fc3R5bGUpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzcGxpdFBhdGgoaW50ZXJzZWN0aW9ucykge1xuXHRcdHZhciBUT0xFUkFOQ0UgPSAwLjAwMDAxLFxuXHRcdFx0bGluZWFyU2VnbWVudHM7XG5cblx0XHRmdW5jdGlvbiByZXNldExpbmVhcigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZWFyU2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gbGluZWFyU2VnbWVudHNbaV07XG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dC5zZXQoMCwgMCk7XG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZUluLnNldCgwLCAwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGggLSAxLCBjdXJ2ZSwgcHJldkxvYzsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBsb2MgPSBpbnRlcnNlY3Rpb25zW2ldLFxuXHRcdFx0XHR0ID0gbG9jLl9wYXJhbWV0ZXI7XG5cdFx0XHRpZiAocHJldkxvYyAmJiBwcmV2TG9jLl9jdXJ2ZSA9PT0gbG9jLl9jdXJ2ZVxuXHRcdFx0XHRcdCYmIHByZXZMb2MuX3BhcmFtZXRlciA+IDApIHtcblx0XHRcdFx0dCAvPSBwcmV2TG9jLl9wYXJhbWV0ZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAobGluZWFyU2VnbWVudHMpXG5cdFx0XHRcdFx0cmVzZXRMaW5lYXIoKTtcblx0XHRcdFx0Y3VydmUgPSBsb2MuX2N1cnZlO1xuXHRcdFx0XHRsaW5lYXJTZWdtZW50cyA9IGN1cnZlLmlzTGluZWFyKCkgJiYgW107XG5cdFx0XHR9XG5cdFx0XHR2YXIgbmV3Q3VydmUsXG5cdFx0XHRcdHNlZ21lbnQ7XG5cdFx0XHRpZiAobmV3Q3VydmUgPSBjdXJ2ZS5kaXZpZGUodCwgdHJ1ZSwgdHJ1ZSkpIHtcblx0XHRcdFx0c2VnbWVudCA9IG5ld0N1cnZlLl9zZWdtZW50MTtcblx0XHRcdFx0Y3VydmUgPSBuZXdDdXJ2ZS5nZXRQcmV2aW91cygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VnbWVudCA9IHQgPCBUT0xFUkFOQ0Vcblx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdDogdCA+IDEgLSBUT0xFUkFOQ0Vcblx0XHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQyXG5cdFx0XHRcdFx0XHQ6IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgdCkgPCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHQsIDEpXG5cdFx0XHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdFx0XHRcdDogY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fVxuXHRcdFx0c2VnbWVudC5faW50ZXJzZWN0aW9uID0gbG9jLmdldEludGVyc2VjdGlvbigpO1xuXHRcdFx0bG9jLl9zZWdtZW50ID0gc2VnbWVudDtcblx0XHRcdGlmIChsaW5lYXJTZWdtZW50cylcblx0XHRcdFx0bGluZWFyU2VnbWVudHMucHVzaChzZWdtZW50KTtcblx0XHRcdHByZXZMb2MgPSBsb2M7XG5cdFx0fVxuXHRcdGlmIChsaW5lYXJTZWdtZW50cylcblx0XHRcdHJlc2V0TGluZWFyKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGhvcml6b250YWwsIHRlc3RDb250YWlucykge1xuXHRcdHZhciBUT0xFUkFOQ0UgPSAwLjAwMDAxLFxuXHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueSxcblx0XHRcdHdpbmRMZWZ0ID0gMCxcblx0XHRcdHdpbmRSaWdodCA9IDAsXG5cdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRNQVggPSAxIC0gVE9MRVJBTkNFO1xuXHRcdGlmIChob3Jpem9udGFsKSB7XG5cdFx0XHR2YXIgeVRvcCA9IC1JbmZpbml0eSxcblx0XHRcdFx0eUJvdHRvbSA9IEluZmluaXR5LFxuXHRcdFx0XHR5QmVmb3JlID0geSAtIFRPTEVSQU5DRSxcblx0XHRcdFx0eUFmdGVyID0geSArIFRPTEVSQU5DRTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAwLCB4LCByb290cywgMCwgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgeTAgPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHJvb3RzW2pdLCAwKS55O1xuXHRcdFx0XHRcdFx0aWYgKHkwIDwgeUJlZm9yZSAmJiB5MCA+IHlUb3ApIHtcblx0XHRcdFx0XHRcdFx0eVRvcCA9IHkwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh5MCA+IHlBZnRlciAmJiB5MCA8IHlCb3R0b20pIHtcblx0XHRcdFx0XHRcdFx0eUJvdHRvbSA9IHkwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0eVRvcCA9ICh5VG9wICsgeSkgLyAyO1xuXHRcdFx0eUJvdHRvbSA9ICh5Qm90dG9tICsgeSkgLyAyO1xuXHRcdFx0aWYgKHlUb3AgPiAtSW5maW5pdHkpXG5cdFx0XHRcdHdpbmRMZWZ0ID0gZ2V0V2luZGluZyhuZXcgUG9pbnQoeCwgeVRvcCksIGN1cnZlcyk7XG5cdFx0XHRpZiAoeUJvdHRvbSA8IEluZmluaXR5KVxuXHRcdFx0XHR3aW5kUmlnaHQgPSBnZXRXaW5kaW5nKG5ldyBQb2ludCh4LCB5Qm90dG9tKSwgY3VydmVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHhCZWZvcmUgPSB4IC0gVE9MRVJBTkNFLFxuXHRcdFx0XHR4QWZ0ZXIgPSB4ICsgVE9MRVJBTkNFO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXSxcblx0XHRcdFx0XHR2YWx1ZXMgPSBjdXJ2ZS52YWx1ZXMsXG5cdFx0XHRcdFx0d2luZGluZyA9IGN1cnZlLndpbmRpbmcsXG5cdFx0XHRcdFx0bmV4dCA9IGN1cnZlLm5leHQ7XG5cdFx0XHRcdGlmICh3aW5kaW5nICYmICh3aW5kaW5nID09PSAxXG5cdFx0XHRcdFx0XHQmJiB5ID49IHZhbHVlc1sxXSAmJiB5IDw9IHZhbHVlc1s3XVxuXHRcdFx0XHRcdFx0fHwgeSA+PSB2YWx1ZXNbN10gJiYgeSA8PSB2YWx1ZXNbMV0pXG5cdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHksIHJvb3RzLCAwLFxuXHRcdFx0XHRcdFx0IW5leHQud2luZGluZyAmJiBuZXh0LnZhbHVlc1sxXSA9PT0geSA/IDEgOiBNQVgpID09PSAxKXtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdLFxuXHRcdFx0XHRcdFx0eDAgPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHQsIDApLngsXG5cdFx0XHRcdFx0XHRzbG9wZSA9IEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgdCwgMSkueTtcblx0XHRcdFx0XHRpZiAoYWJzKHNsb3BlKSA8IFRPTEVSQU5DRSAmJiAhQ3VydmUuaXNMaW5lYXIodmFsdWVzKVxuXHRcdFx0XHRcdFx0XHR8fCB0IDwgVE9MRVJBTkNFICYmIHNsb3BlICogQ3VydmUuZXZhbHVhdGUoXG5cdFx0XHRcdFx0XHRcdFx0Y3VydmUucHJldmlvdXMudmFsdWVzLCB0LCAxKS55IDwgMCkge1xuXHRcdFx0XHRcdFx0aWYgKHRlc3RDb250YWlucyAmJiB4MCA+PSB4QmVmb3JlICYmIHgwIDw9IHhBZnRlcikge1xuXHRcdFx0XHRcdFx0XHQrK3dpbmRMZWZ0O1xuXHRcdFx0XHRcdFx0XHQrK3dpbmRSaWdodDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHgwIDw9IHhCZWZvcmUpIHtcblx0XHRcdFx0XHRcdHdpbmRMZWZ0ICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh4MCA+PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdHdpbmRSaWdodCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gTWF0aC5tYXgoYWJzKHdpbmRMZWZ0KSwgYWJzKHdpbmRSaWdodCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0b3IsIHNlbGZPcCkge1xuXHRcdG9wZXJhdG9yID0gb3BlcmF0b3IgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdHZhciBwYXRocyA9IFtdLFxuXHRcdFx0WkVSTyA9IDFlLTMsXG5cdFx0XHRPTkUgPSAxIC0gMWUtMztcblx0XHRmb3IgKHZhciBpID0gMCwgc2VnLCBzdGFydFNlZywgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnID0gc3RhcnRTZWcgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWcuX3Zpc2l0ZWQgfHwgIW9wZXJhdG9yKHNlZy5fd2luZGluZykpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRcdGludGVyID0gc2VnLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdHN0YXJ0SW50ZXJTZWcgPSBpbnRlciAmJiBpbnRlci5fc2VnbWVudCxcblx0XHRcdFx0YWRkZWQgPSBmYWxzZSxcblx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdGRvIHtcblx0XHRcdFx0dmFyIGhhbmRsZUluID0gZGlyID4gMCA/IHNlZy5faGFuZGxlSW4gOiBzZWcuX2hhbmRsZU91dCxcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVPdXQgOiBzZWcuX2hhbmRsZUluLFxuXHRcdFx0XHRcdGludGVyU2VnO1xuXHRcdFx0XHRpZiAoYWRkZWQgJiYgKCFvcGVyYXRvcihzZWcuX3dpbmRpbmcpIHx8IHNlbGZPcClcblx0XHRcdFx0XHRcdCYmIChpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uKVxuXHRcdFx0XHRcdFx0JiYgKGludGVyU2VnID0gaW50ZXIuX3NlZ21lbnQpXG5cdFx0XHRcdFx0XHQmJiBpbnRlclNlZyAhPT0gc3RhcnRTZWcpIHtcblx0XHRcdFx0XHRpZiAoc2VsZk9wKSB7XG5cdFx0XHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSBpbnRlclNlZy5fdmlzaXRlZDtcblx0XHRcdFx0XHRcdHNlZyA9IGludGVyU2VnO1xuXHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGMxID0gc2VnLmdldEN1cnZlKCk7XG5cdFx0XHRcdFx0XHRpZiAoZGlyID4gMClcblx0XHRcdFx0XHRcdFx0YzEgPSBjMS5nZXRQcmV2aW91cygpO1xuXHRcdFx0XHRcdFx0dmFyIHQxID0gYzEuZ2V0VGFuZ2VudEF0KGRpciA8IDEgPyBaRVJPIDogT05FLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0YzQgPSBpbnRlclNlZy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRcdFx0XHRjMyA9IGM0LmdldFByZXZpb3VzKCksXG5cdFx0XHRcdFx0XHRcdHQzID0gYzMuZ2V0VGFuZ2VudEF0KE9ORSwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdHQ0ID0gYzQuZ2V0VGFuZ2VudEF0KFpFUk8sIHRydWUpLFxuXHRcdFx0XHRcdFx0XHR3MyA9IHQxLmNyb3NzKHQzKSxcblx0XHRcdFx0XHRcdFx0dzQgPSB0MS5jcm9zcyh0NCk7XG5cdFx0XHRcdFx0XHRpZiAodzMgKiB3NCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgY3VydmUgPSB3MyA8IHc0ID8gYzMgOiBjNCxcblx0XHRcdFx0XHRcdFx0XHRuZXh0Q3VydmUgPSBvcGVyYXRvcihjdXJ2ZS5fc2VnbWVudDEuX3dpbmRpbmcpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnZlXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHczIDwgdzQgPyBjNCA6IGMzLFxuXHRcdFx0XHRcdFx0XHRcdG5leHRTZWcgPSBuZXh0Q3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0XHRcdFx0XHRkaXIgPSBuZXh0Q3VydmUgPT09IGMzID8gLTEgOiAxO1xuXHRcdFx0XHRcdFx0XHRpZiAobmV4dFNlZy5fdmlzaXRlZCAmJiBzZWcuX3BhdGggIT09IG5leHRTZWcuX3BhdGhcblx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgIW9wZXJhdG9yKG5leHRTZWcuX3dpbmRpbmcpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSBpbnRlclNlZy5fdmlzaXRlZDtcblx0XHRcdFx0XHRcdFx0XHRzZWcgPSBpbnRlclNlZztcblx0XHRcdFx0XHRcdFx0XHRpZiAobmV4dFNlZy5fdmlzaXRlZClcblx0XHRcdFx0XHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGhhbmRsZU91dCA9IGRpciA+IDAgPyBzZWcuX2hhbmRsZU91dCA6IHNlZy5faGFuZGxlSW47XG5cdFx0XHRcdH1cblx0XHRcdFx0cGF0aC5hZGQobmV3IFNlZ21lbnQoc2VnLl9wb2ludCwgYWRkZWQgJiYgaGFuZGxlSW4sIGhhbmRsZU91dCkpO1xuXHRcdFx0XHRhZGRlZCA9IHRydWU7XG5cdFx0XHRcdHNlZy5fdmlzaXRlZCA9IHRydWU7XG5cdFx0XHRcdHNlZyA9IGRpciA+IDAgPyBzZWcuZ2V0TmV4dCgpIDogc2VnLiBnZXRQcmV2aW91cygpO1xuXHRcdFx0fSB3aGlsZSAoc2VnICYmICFzZWcuX3Zpc2l0ZWRcblx0XHRcdFx0XHQmJiBzZWcgIT09IHN0YXJ0U2VnICYmIHNlZyAhPT0gc3RhcnRJbnRlclNlZ1xuXHRcdFx0XHRcdCYmIChzZWcuX2ludGVyc2VjdGlvbiB8fCBvcGVyYXRvcihzZWcuX3dpbmRpbmcpKSk7XG5cdFx0XHRpZiAoc2VnICYmIChzZWcgPT09IHN0YXJ0U2VnIHx8IHNlZyA9PT0gc3RhcnRJbnRlclNlZykpIHtcblx0XHRcdFx0cGF0aC5maXJzdFNlZ21lbnQuc2V0SGFuZGxlSW4oKHNlZyA9PT0gc3RhcnRJbnRlclNlZ1xuXHRcdFx0XHRcdFx0PyBzdGFydEludGVyU2VnIDogc2VnKS5faGFuZGxlSW4pO1xuXHRcdFx0XHRwYXRoLnNldENsb3NlZCh0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgubGFzdFNlZ21lbnQuX2hhbmRsZU91dC5zZXQoMCwgMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGF0aC5fc2VnbWVudHMubGVuZ3RoID5cblx0XHRcdFx0XHQocGF0aC5fY2xvc2VkID8gcGF0aC5pc1BvbHlnb24oKSA/IDIgOiAwIDogMSkpXG5cdFx0XHRcdHBhdGhzLnB1c2gocGF0aCk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocztcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2dldFdpbmRpbmc6IGZ1bmN0aW9uKHBvaW50LCBob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpIHtcblx0XHRcdHJldHVybiBnZXRXaW5kaW5nKHBvaW50LCB0aGlzLl9nZXRNb25vQ3VydmVzKCksXG5cdFx0XHRcdFx0aG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKTtcblx0XHR9LFxuXG5cdFx0dW5pdGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCBmdW5jdGlvbih3KSB7XG5cdFx0XHRcdHJldHVybiB3ID09PSAxIHx8IHcgPT09IDA7XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsIGZ1bmN0aW9uKHcpIHtcblx0XHRcdFx0cmV0dXJuIHcgPT09IDI7XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgZnVuY3Rpb24odykge1xuXHRcdFx0XHRyZXR1cm4gdyA9PT0gMTtcblx0XHRcdH0sIHRydWUpO1xuXHRcdH0sXG5cblx0XHRleGNsdWRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEdyb3VwKFt0aGlzLnN1YnRyYWN0KHBhdGgpLCBwYXRoLnN1YnRyYWN0KHRoaXMpXSk7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBHcm91cChbdGhpcy5zdWJ0cmFjdChwYXRoKSwgdGhpcy5pbnRlcnNlY3QocGF0aCldKTtcblx0XHR9XG5cdH07XG59KTtcblxuUGF0aC5pbmplY3Qoe1xuXHRfZ2V0TW9ub0N1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1vbm9DdXJ2ZXMgPSB0aGlzLl9tb25vQ3VydmVzLFxuXHRcdFx0cHJldkN1cnZlO1xuXG5cdFx0ZnVuY3Rpb24gaW5zZXJ0Q3VydmUodikge1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzddLFxuXHRcdFx0XHRjdXJ2ZSA9IHtcblx0XHRcdFx0XHR2YWx1ZXM6IHYsXG5cdFx0XHRcdFx0d2luZGluZzogeTAgPT09IHkxXG5cdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdDogeTAgPiB5MVxuXHRcdFx0XHRcdFx0XHQ/IC0xXG5cdFx0XHRcdFx0XHRcdDogMSxcblx0XHRcdFx0XHRwcmV2aW91czogcHJldkN1cnZlLFxuXHRcdFx0XHRcdG5leHQ6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdGlmIChwcmV2Q3VydmUpXG5cdFx0XHRcdHByZXZDdXJ2ZS5uZXh0ID0gY3VydmU7XG5cdFx0XHRtb25vQ3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0cHJldkN1cnZlID0gY3VydmU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQ3VydmUodikge1xuXHRcdFx0aWYgKEN1cnZlLmdldExlbmd0aCh2KSA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzNdLFxuXHRcdFx0XHR5MiA9IHZbNV0sXG5cdFx0XHRcdHkzID0gdls3XTtcblx0XHRcdGlmIChDdXJ2ZS5pc0xpbmVhcih2KSkge1xuXHRcdFx0XHRpbnNlcnRDdXJ2ZSh2KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gMyAqICh5MSAtIHkyKSAtIHkwICsgeTMsXG5cdFx0XHRcdFx0YiA9IDIgKiAoeTAgKyB5MikgLSA0ICogeTEsXG5cdFx0XHRcdFx0YyA9IHkxIC0geTAsXG5cdFx0XHRcdFx0VE9MRVJBTkNFID0gMC4wMDAwMSxcblx0XHRcdFx0XHRyb290cyA9IFtdO1xuXHRcdFx0XHR2YXIgY291bnQgPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMsIFRPTEVSQU5DRSxcblx0XHRcdFx0XHRcdDEgLSBUT0xFUkFOQ0UpO1xuXHRcdFx0XHRpZiAoY291bnQgPT09IDApIHtcblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZSh2KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyb290cy5zb3J0KCk7XG5cdFx0XHRcdFx0dmFyIHQgPSByb290c1swXSxcblx0XHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYsIHQpO1xuXHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHRpZiAoY291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHR0ID0gKHJvb3RzWzFdIC0gdCkgLyAoMSAtIHQpO1xuXHRcdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUocGFydHNbMV0sIHQpO1xuXHRcdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1sxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIW1vbm9DdXJ2ZXMpIHtcblx0XHRcdG1vbm9DdXJ2ZXMgPSB0aGlzLl9tb25vQ3VydmVzID0gW107XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aGFuZGxlQ3VydmUoY3VydmVzW2ldLmdldFZhbHVlcygpKTtcblx0XHRcdGlmICghdGhpcy5fY2xvc2VkICYmIHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dmFyIHAxID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uX3BvaW50LFxuXHRcdFx0XHRcdHAyID0gc2VnbWVudHNbMF0uX3BvaW50LFxuXHRcdFx0XHRcdHAxeCA9IHAxLl94LCBwMXkgPSBwMS5feSxcblx0XHRcdFx0XHRwMnggPSBwMi5feCwgcDJ5ID0gcDIuX3k7XG5cdFx0XHRcdGhhbmRsZUN1cnZlKFtwMXgsIHAxeSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwMngsIHAyeV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1vbm9DdXJ2ZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2YXIgZmlyc3QgPSBtb25vQ3VydmVzWzBdLFxuXHRcdFx0XHRcdGxhc3QgPSBtb25vQ3VydmVzW21vbm9DdXJ2ZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGZpcnN0LnByZXZpb3VzID0gbGFzdDtcblx0XHRcdFx0bGFzdC5uZXh0ID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtb25vQ3VydmVzO1xuXHR9LFxuXG5cdGdldEludGVyaW9yUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0cG9pbnQgPSBib3VuZHMuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdGlmICghdGhpcy5jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9nZXRNb25vQ3VydmVzKCksXG5cdFx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRcdHkgPSBwb2ludC55LFxuXHRcdFx0XHR4SW50ZXJjZXB0cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBjdXJ2ZXNbaV0udmFsdWVzO1xuXHRcdFx0XHRpZiAoKGN1cnZlc1tpXS53aW5kaW5nID09PSAxXG5cdFx0XHRcdFx0XHQmJiB5ID49IHZhbHVlc1sxXSAmJiB5IDw9IHZhbHVlc1s3XVxuXHRcdFx0XHRcdFx0fHwgeSA+PSB2YWx1ZXNbN10gJiYgeSA8PSB2YWx1ZXNbMV0pXG5cdFx0XHRcdFx0XHQmJiBDdXJ2ZS5zb2x2ZUN1YmljKHZhbHVlcywgMSwgeSwgcm9vdHMsIDAsIDEpID4gMCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSByb290cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcblx0XHRcdFx0XHRcdHhJbnRlcmNlcHRzLnB1c2goQ3VydmUuZXZhbHVhdGUodmFsdWVzLCByb290c1tqXSwgMCkueCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHhJbnRlcmNlcHRzLmxlbmd0aCA+IDEpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRwb2ludC54ID0gKHhJbnRlcmNlcHRzWzBdICsgeEludGVyY2VwdHNbMV0pIC8gMjtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9LFxuXG5cdHJlb3JpZW50OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNldENsb2Nrd2lzZSh0cnVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbkNvbXBvdW5kUGF0aC5pbmplY3Qoe1xuXHRfZ2V0TW9ub0N1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRtb25vQ3VydmVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRtb25vQ3VydmVzLnB1c2guYXBwbHkobW9ub0N1cnZlcywgY2hpbGRyZW5baV0uX2dldE1vbm9DdXJ2ZXMoKSk7XG5cdFx0cmV0dXJuIG1vbm9DdXJ2ZXM7XG5cdH0sXG5cblx0cmVvcmllbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMucmVtb3ZlQ2hpbGRyZW4oKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBiLmdldEJvdW5kcygpLmdldEFyZWEoKSAtIGEuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpO1xuXHRcdH0pO1xuXHRcdHRoaXMuYWRkQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdHZhciBjbG9ja3dpc2UgPSBjaGlsZHJlblswXS5pc0Nsb2Nrd2lzZSgpO1xuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBjaGlsZHJlbltpXS5nZXRJbnRlcmlvclBvaW50KCksXG5cdFx0XHRcdGNvdW50ZXJzID0gMDtcblx0XHRcdGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW2pdLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRjb3VudGVycysrO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGRyZW5baV0uc2V0Q2xvY2t3aXNlKGNvdW50ZXJzICUgMiA9PT0gMCAmJiBjbG9ja3dpc2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbnZhciBQYXRoSXRlcmF0b3IgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGhJdGVyYXRvcicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgbWF4UmVjdXJzaW9uLCB0b2xlcmFuY2UsIG1hdHJpeCkge1xuXHRcdHZhciBjdXJ2ZXMgPSBbXSxcblx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRsZW5ndGggPSAwLFxuXHRcdFx0bWluRGlmZmVyZW5jZSA9IDEgLyAobWF4UmVjdXJzaW9uIHx8IDMyKSxcblx0XHRcdHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnRzWzBdLFxuXHRcdFx0c2VnbWVudDI7XG5cblx0XHRmdW5jdGlvbiBhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFZhbHVlcyhzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCk7XG5cdFx0XHRjdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHRjb21wdXRlUGFydHMoY3VydmUsIHNlZ21lbnQxLl9pbmRleCwgMCwgMSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29tcHV0ZVBhcnRzKGN1cnZlLCBpbmRleCwgbWluVCwgbWF4VCkge1xuXHRcdFx0aWYgKChtYXhUIC0gbWluVCkgPiBtaW5EaWZmZXJlbmNlXG5cdFx0XHRcdFx0JiYgIUN1cnZlLmlzRmxhdEVub3VnaChjdXJ2ZSwgdG9sZXJhbmNlIHx8IDAuMjUpKSB7XG5cdFx0XHRcdHZhciBzcGxpdCA9IEN1cnZlLnN1YmRpdmlkZShjdXJ2ZSksXG5cdFx0XHRcdFx0aGFsZlQgPSAobWluVCArIG1heFQpIC8gMjtcblx0XHRcdFx0Y29tcHV0ZVBhcnRzKHNwbGl0WzBdLCBpbmRleCwgbWluVCwgaGFsZlQpO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoc3BsaXRbMV0sIGluZGV4LCBoYWxmVCwgbWF4VCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgeCA9IGN1cnZlWzZdIC0gY3VydmVbMF0sXG5cdFx0XHRcdFx0eSA9IGN1cnZlWzddIC0gY3VydmVbMV0sXG5cdFx0XHRcdFx0ZGlzdCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0aWYgKGRpc3QgPiAwLjAwMDAxKSB7XG5cdFx0XHRcdFx0bGVuZ3RoICs9IGRpc3Q7XG5cdFx0XHRcdFx0cGFydHMucHVzaCh7XG5cdFx0XHRcdFx0XHRvZmZzZXQ6IGxlbmd0aCxcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXhULFxuXHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnbWVudDIgPSBzZWdtZW50c1tpXTtcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mik7XG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnQyO1xuXHRcdH1cblx0XHRpZiAocGF0aC5fY2xvc2VkKVxuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDIsIHNlZ21lbnRzWzBdKTtcblxuXHRcdHRoaXMuY3VydmVzID0gY3VydmVzO1xuXHRcdHRoaXMucGFydHMgPSBwYXJ0cztcblx0XHR0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0XHR0aGlzLmluZGV4ID0gMDtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0dmFyIGksIGogPSB0aGlzLmluZGV4O1xuXHRcdGZvciAoOzspIHtcblx0XHRcdGkgPSBqO1xuXHRcdFx0aWYgKGogPT0gMCB8fCB0aGlzLnBhcnRzWy0tal0ub2Zmc2V0IDwgb2Zmc2V0KVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Zm9yICh2YXIgbCA9IHRoaXMucGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbaV07XG5cdFx0XHRpZiAocGFydC5vZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBpO1xuXHRcdFx0XHR2YXIgcHJldiA9IHRoaXMucGFydHNbaSAtIDFdO1xuXHRcdFx0XHR2YXIgcHJldlZhbCA9IHByZXYgJiYgcHJldi5pbmRleCA9PSBwYXJ0LmluZGV4ID8gcHJldi52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0cHJldkxlbiA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByZXZWYWwgKyAocGFydC52YWx1ZSAtIHByZXZWYWwpXG5cdFx0XHRcdFx0XHQqIChvZmZzZXQgLSBwcmV2TGVuKSAvIChwYXJ0Lm9mZnNldCAtIHByZXZMZW4pLFxuXHRcdFx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBwYXJ0ID0gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB7XG5cdFx0XHR2YWx1ZTogMSxcblx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0fTtcblx0fSxcblxuXHRldmFsdWF0ZTogZnVuY3Rpb24ob2Zmc2V0LCB0eXBlKSB7XG5cdFx0dmFyIHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQpO1xuXHRcdHJldHVybiBDdXJ2ZS5ldmFsdWF0ZSh0aGlzLmN1cnZlc1twYXJhbS5pbmRleF0sIHBhcmFtLnZhbHVlLCB0eXBlKTtcblx0fSxcblxuXHRkcmF3UGFydDogZnVuY3Rpb24oY3R4LCBmcm9tLCB0bykge1xuXHRcdGZyb20gPSB0aGlzLmdldFBhcmFtZXRlckF0KGZyb20pO1xuXHRcdHRvID0gdGhpcy5nZXRQYXJhbWV0ZXJBdCh0byk7XG5cdFx0Zm9yICh2YXIgaSA9IGZyb20uaW5kZXg7IGkgPD0gdG8uaW5kZXg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0UGFydCh0aGlzLmN1cnZlc1tpXSxcblx0XHRcdFx0XHRpID09IGZyb20uaW5kZXggPyBmcm9tLnZhbHVlIDogMCxcblx0XHRcdFx0XHRpID09IHRvLmluZGV4ID8gdG8udmFsdWUgOiAxKTtcblx0XHRcdGlmIChpID09IGZyb20uaW5kZXgpXG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcblx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsnZ2V0UG9pbnQnLCAnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ10sXG5cdGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmV2YWx1YXRlKG9mZnNldCwgaW5kZXgpO1xuXHRcdH07XG5cdH0sIHt9KVxuKTtcblxudmFyIFBhdGhGaXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgsIGVycm9yKSB7XG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHByZXY7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnRzW2ldLnBvaW50LmNsb25lKCk7XG5cdFx0XHRpZiAoIXByZXYgfHwgIXByZXYuZXF1YWxzKHBvaW50KSkge1xuXHRcdFx0XHR0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcblx0XHRcdFx0cHJldiA9IHBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmVycm9yID0gZXJyb3I7XG5cdH0sXG5cblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXHRcdHRoaXMuc2VnbWVudHMgPSBsZW5ndGggPiAwID8gW25ldyBTZWdtZW50KHBvaW50c1swXSldIDogW107XG5cdFx0aWYgKGxlbmd0aCA+IDEpXG5cdFx0XHR0aGlzLmZpdEN1YmljKDAsIGxlbmd0aCAtIDEsXG5cdFx0XHRcdHBvaW50c1sxXS5zdWJ0cmFjdChwb2ludHNbMF0pLm5vcm1hbGl6ZSgpLFxuXHRcdFx0XHRwb2ludHNbbGVuZ3RoIC0gMl0uc3VidHJhY3QocG9pbnRzW2xlbmd0aCAtIDFdKS5ub3JtYWxpemUoKSk7XG5cdFx0cmV0dXJuIHRoaXMuc2VnbWVudHM7XG5cdH0sXG5cblx0Zml0Q3ViaWM6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB0YW4xLCB0YW4yKSB7XG5cdFx0aWYgKGxhc3QgLSBmaXJzdCA9PSAxKSB7XG5cdFx0XHR2YXIgcHQxID0gdGhpcy5wb2ludHNbZmlyc3RdLFxuXHRcdFx0XHRwdDIgPSB0aGlzLnBvaW50c1tsYXN0XSxcblx0XHRcdFx0ZGlzdCA9IHB0MS5nZXREaXN0YW5jZShwdDIpIC8gMztcblx0XHRcdHRoaXMuYWRkQ3VydmUoW3B0MSwgcHQxLmFkZCh0YW4xLm5vcm1hbGl6ZShkaXN0KSksXG5cdFx0XHRcdFx0cHQyLmFkZCh0YW4yLm5vcm1hbGl6ZShkaXN0KSksIHB0Ml0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdVByaW1lID0gdGhpcy5jaG9yZExlbmd0aFBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCksXG5cdFx0XHRtYXhFcnJvciA9IE1hdGgubWF4KHRoaXMuZXJyb3IsIHRoaXMuZXJyb3IgKiB0aGlzLmVycm9yKSxcblx0XHRcdHNwbGl0O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDQ7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZW5lcmF0ZUJlemllcihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKTtcblx0XHRcdHZhciBtYXggPSB0aGlzLmZpbmRNYXhFcnJvcihmaXJzdCwgbGFzdCwgY3VydmUsIHVQcmltZSk7XG5cdFx0XHRpZiAobWF4LmVycm9yIDwgdGhpcy5lcnJvcikge1xuXHRcdFx0XHR0aGlzLmFkZEN1cnZlKGN1cnZlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c3BsaXQgPSBtYXguaW5kZXg7XG5cdFx0XHRpZiAobWF4LmVycm9yID49IG1heEVycm9yKVxuXHRcdFx0XHRicmVhaztcblx0XHRcdHRoaXMucmVwYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QsIHVQcmltZSwgY3VydmUpO1xuXHRcdFx0bWF4RXJyb3IgPSBtYXguZXJyb3I7XG5cdFx0fVxuXHRcdHZhciBWMSA9IHRoaXMucG9pbnRzW3NwbGl0IC0gMV0uc3VidHJhY3QodGhpcy5wb2ludHNbc3BsaXRdKSxcblx0XHRcdFYyID0gdGhpcy5wb2ludHNbc3BsaXRdLnN1YnRyYWN0KHRoaXMucG9pbnRzW3NwbGl0ICsgMV0pLFxuXHRcdFx0dGFuQ2VudGVyID0gVjEuYWRkKFYyKS5kaXZpZGUoMikubm9ybWFsaXplKCk7XG5cdFx0dGhpcy5maXRDdWJpYyhmaXJzdCwgc3BsaXQsIHRhbjEsIHRhbkNlbnRlcik7XG5cdFx0dGhpcy5maXRDdWJpYyhzcGxpdCwgbGFzdCwgdGFuQ2VudGVyLm5lZ2F0ZSgpLCB0YW4yKTtcblx0fSxcblxuXHRhZGRDdXJ2ZTogZnVuY3Rpb24oY3VydmUpIHtcblx0XHR2YXIgcHJldiA9IHRoaXMuc2VnbWVudHNbdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0XHRwcmV2LnNldEhhbmRsZU91dChjdXJ2ZVsxXS5zdWJ0cmFjdChjdXJ2ZVswXSkpO1xuXHRcdHRoaXMuc2VnbWVudHMucHVzaChcblx0XHRcdFx0bmV3IFNlZ21lbnQoY3VydmVbM10sIGN1cnZlWzJdLnN1YnRyYWN0KGN1cnZlWzNdKSkpO1xuXHR9LFxuXG5cdGdlbmVyYXRlQmV6aWVyOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAxZS0xMSxcblx0XHRcdHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdHB0MiA9IHRoaXMucG9pbnRzW2xhc3RdLFxuXHRcdFx0QyA9IFtbMCwgMF0sIFswLCAwXV0sXG5cdFx0XHRYID0gWzAsIDBdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXN0IC0gZmlyc3QgKyAxOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdSA9IHVQcmltZVtpXSxcblx0XHRcdFx0dCA9IDEgLSB1LFxuXHRcdFx0XHRiID0gMyAqIHUgKiB0LFxuXHRcdFx0XHRiMCA9IHQgKiB0ICogdCxcblx0XHRcdFx0YjEgPSBiICogdCxcblx0XHRcdFx0YjIgPSBiICogdSxcblx0XHRcdFx0YjMgPSB1ICogdSAqIHUsXG5cdFx0XHRcdGExID0gdGFuMS5ub3JtYWxpemUoYjEpLFxuXHRcdFx0XHRhMiA9IHRhbjIubm9ybWFsaXplKGIyKSxcblx0XHRcdFx0dG1wID0gdGhpcy5wb2ludHNbZmlyc3QgKyBpXVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDEubXVsdGlwbHkoYjAgKyBiMSkpXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0Mi5tdWx0aXBseShiMiArIGIzKSk7XG5cdFx0XHRDWzBdWzBdICs9IGExLmRvdChhMSk7XG5cdFx0XHRDWzBdWzFdICs9IGExLmRvdChhMik7XG5cdFx0XHRDWzFdWzBdID0gQ1swXVsxXTtcblx0XHRcdENbMV1bMV0gKz0gYTIuZG90KGEyKTtcblx0XHRcdFhbMF0gKz0gYTEuZG90KHRtcCk7XG5cdFx0XHRYWzFdICs9IGEyLmRvdCh0bXApO1xuXHRcdH1cblxuXHRcdHZhciBkZXRDMEMxID0gQ1swXVswXSAqIENbMV1bMV0gLSBDWzFdWzBdICogQ1swXVsxXSxcblx0XHRcdGFscGhhMSwgYWxwaGEyO1xuXHRcdGlmIChNYXRoLmFicyhkZXRDMEMxKSA+IGVwc2lsb24pIHtcblx0XHRcdHZhciBkZXRDMFhcdD0gQ1swXVswXSAqIFhbMV1cdC0gQ1sxXVswXSAqIFhbMF0sXG5cdFx0XHRcdGRldFhDMVx0PSBYWzBdXHQgICogQ1sxXVsxXSAtIFhbMV1cdCAgKiBDWzBdWzFdO1xuXHRcdFx0YWxwaGExID0gZGV0WEMxIC8gZGV0QzBDMTtcblx0XHRcdGFscGhhMiA9IGRldEMwWCAvIGRldEMwQzE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjMCA9IENbMF1bMF0gKyBDWzBdWzFdLFxuXHRcdFx0XHRjMSA9IENbMV1bMF0gKyBDWzFdWzFdO1xuXHRcdFx0aWYgKE1hdGguYWJzKGMwKSA+IGVwc2lsb24pIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gWFswXSAvIGMwO1xuXHRcdFx0fSBlbHNlIGlmIChNYXRoLmFicyhjMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMV0gLyBjMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNlZ0xlbmd0aCA9IHB0Mi5nZXREaXN0YW5jZShwdDEpO1xuXHRcdGVwc2lsb24gKj0gc2VnTGVuZ3RoO1xuXHRcdGlmIChhbHBoYTEgPCBlcHNpbG9uIHx8IGFscGhhMiA8IGVwc2lsb24pIHtcblx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoYWxwaGExKSksXG5cdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoYWxwaGEyKSksIHB0Ml07XG5cdH0sXG5cblx0cmVwYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1LCBjdXJ2ZSkge1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcblx0XHRcdHVbaSAtIGZpcnN0XSA9IHRoaXMuZmluZFJvb3QoY3VydmUsIHRoaXMucG9pbnRzW2ldLCB1W2kgLSBmaXJzdF0pO1xuXHRcdH1cblx0fSxcblxuXHRmaW5kUm9vdDogZnVuY3Rpb24oY3VydmUsIHBvaW50LCB1KSB7XG5cdFx0dmFyIGN1cnZlMSA9IFtdLFxuXHRcdFx0Y3VydmUyID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTFbaV0gPSBjdXJ2ZVtpICsgMV0uc3VidHJhY3QoY3VydmVbaV0pLm11bHRpcGx5KDMpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcblx0XHRcdGN1cnZlMltpXSA9IGN1cnZlMVtpICsgMV0uc3VidHJhY3QoY3VydmUxW2ldKS5tdWx0aXBseSgyKTtcblx0XHR9XG5cdFx0dmFyIHB0ID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdSksXG5cdFx0XHRwdDEgPSB0aGlzLmV2YWx1YXRlKDIsIGN1cnZlMSwgdSksXG5cdFx0XHRwdDIgPSB0aGlzLmV2YWx1YXRlKDEsIGN1cnZlMiwgdSksXG5cdFx0XHRkaWZmID0gcHQuc3VidHJhY3QocG9pbnQpLFxuXHRcdFx0ZGYgPSBwdDEuZG90KHB0MSkgKyBkaWZmLmRvdChwdDIpO1xuXHRcdGlmIChNYXRoLmFicyhkZikgPCAwLjAwMDAxKVxuXHRcdFx0cmV0dXJuIHU7XG5cdFx0cmV0dXJuIHUgLSBkaWZmLmRvdChwdDEpIC8gZGY7XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKGRlZ3JlZSwgY3VydmUsIHQpIHtcblx0XHR2YXIgdG1wID0gY3VydmUuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XG5cdFx0XHRcdHRtcFtqXSA9IHRtcFtqXS5tdWx0aXBseSgxIC0gdCkuYWRkKHRtcFtqICsgMV0ubXVsdGlwbHkodCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdG1wWzBdO1xuXHR9LFxuXG5cdGNob3JkTGVuZ3RoUGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCkge1xuXHRcdHZhciB1ID0gWzBdO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB1W2kgLSBmaXJzdCAtIDFdXG5cdFx0XHRcdFx0KyB0aGlzLnBvaW50c1tpXS5nZXREaXN0YW5jZSh0aGlzLnBvaW50c1tpIC0gMV0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbSA9IGxhc3QgLSBmaXJzdDsgaSA8PSBtOyBpKyspIHtcblx0XHRcdHVbaV0gLz0gdVttXTtcblx0XHR9XG5cdFx0cmV0dXJuIHU7XG5cdH0sXG5cblx0ZmluZE1heEVycm9yOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgY3VydmUsIHUpIHtcblx0XHR2YXIgaW5kZXggPSBNYXRoLmZsb29yKChsYXN0IC0gZmlyc3QgKyAxKSAvIDIpLFxuXHRcdFx0bWF4RGlzdCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuXHRcdFx0dmFyIFAgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1W2kgLSBmaXJzdF0pO1xuXHRcdFx0dmFyIHYgPSBQLnN1YnRyYWN0KHRoaXMucG9pbnRzW2ldKTtcblx0XHRcdHZhciBkaXN0ID0gdi54ICogdi54ICsgdi55ICogdi55O1xuXHRcdFx0aWYgKGRpc3QgPj0gbWF4RGlzdCkge1xuXHRcdFx0XHRtYXhEaXN0ID0gZGlzdDtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXJyb3I6IG1heERpc3QsXG5cdFx0XHRpbmRleDogaW5kZXhcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIFRleHRJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdUZXh0SXRlbScsXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNvbnRlbnQ6IG51bGxcblx0fSxcblx0X2JvdW5kc0dldHRlcjogJ2dldEJvdW5kcycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVGV4dEl0ZW0oYXJnKSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnO1xuXHRcdHRoaXMuX2xpbmVzID0gW107XG5cdFx0dmFyIGhhc1Byb3BzID0gYXJnICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdCYmIGFyZy54ID09PSB1bmRlZmluZWQgJiYgYXJnLnkgPT09IHVuZGVmaW5lZDtcblx0XHR0aGlzLl9pbml0aWFsaXplKGhhc1Byb3BzICYmIGFyZywgIWhhc1Byb3BzICYmIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50ID09PSBpdGVtLl9jb250ZW50O1xuXHR9LFxuXG5cdF9jbG9uZTogZnVuY3Rpb24gX2Nsb25lKGNvcHkpIHtcblx0XHRjb3B5LnNldENvbnRlbnQodGhpcy5fY29udGVudCk7XG5cdFx0cmV0dXJuIF9jbG9uZS5iYXNlLmNhbGwodGhpcywgY29weSk7XG5cdH0sXG5cblx0Z2V0Q29udGVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG5cdH0sXG5cblx0c2V0Q29udGVudDogZnVuY3Rpb24oY29udGVudCkge1xuXHRcdHRoaXMuX2NvbnRlbnQgPSAnJyArIGNvbnRlbnQ7XG5cdFx0dGhpcy5fbGluZXMgPSB0aGlzLl9jb250ZW50LnNwbGl0KC9cXHJcXG58XFxufFxcci9tZyk7XG5cdFx0dGhpcy5fY2hhbmdlZCgyNjUpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRnZXRDaGFyYWN0ZXJTdHlsZTogJyNnZXRTdHlsZScsXG5cdHNldENoYXJhY3RlclN0eWxlOiAnI3NldFN0eWxlJyxcblxuXHRnZXRQYXJhZ3JhcGhTdHlsZTogJyNnZXRTdHlsZScsXG5cdHNldFBhcmFncmFwaFN0eWxlOiAnI3NldFN0eWxlJ1xufSk7XG5cbnZhciBQb2ludFRleHQgPSBUZXh0SXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludFRleHQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50VGV4dCgpIHtcblx0XHRUZXh0SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUobmV3IFBvaW50VGV4dChJdGVtLk5PX0lOU0VSVCksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXHRcdHJldHVybiBuZXcgTGlua2VkUG9pbnQocG9pbnQueCwgcG9pbnQueSwgdGhpcywgJ3NldFBvaW50Jyk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRyYW5zbGF0ZShwb2ludC5zdWJ0cmFjdCh0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHNoYWRvd0NvbG9yID0gY3R4LnNoYWRvd0NvbG9yO1xuXHRcdGN0eC5mb250ID0gc3R5bGUuZ2V0Rm9udFN0eWxlKCk7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3I7XG5cdFx0XHR2YXIgbGluZSA9IGxpbmVzW2ldO1xuXHRcdFx0aWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZVRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRjdHgudHJhbnNsYXRlKDAsIGxlYWRpbmcpO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0bGluZXMgPSB0aGlzLl9saW5lcyxcblx0XHRcdG51bUxpbmVzID0gbGluZXMubGVuZ3RoLFxuXHRcdFx0anVzdGlmaWNhdGlvbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKSxcblx0XHRcdGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG5cdFx0XHR3aWR0aCA9IHRoaXMuZ2V0VmlldygpLmdldFRleHRXaWR0aChzdHlsZS5nZXRGb250U3R5bGUoKSwgbGluZXMpLFxuXHRcdFx0eCA9IDA7XG5cdFx0aWYgKGp1c3RpZmljYXRpb24gIT09ICdsZWZ0Jylcblx0XHRcdHggLT0gd2lkdGggLyAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicgPyAyOiAxKTtcblx0XHR2YXIgYm91bmRzID0gbmV3IFJlY3RhbmdsZSh4LFxuXHRcdFx0XHRcdG51bUxpbmVzID8gLSAwLjc1ICogbGVhZGluZyA6IDAsXG5cdFx0XHRcdFx0d2lkdGgsIG51bUxpbmVzICogbGVhZGluZyk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKGJvdW5kcywgYm91bmRzKSA6IGJvdW5kcztcblx0fVxufSk7XG5cbnZhciBDb2xvciA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHR5cGVzID0ge1xuXHRcdGdyYXk6IFsnZ3JheSddLFxuXHRcdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRcdGhzYjogWydodWUnLCAnc2F0dXJhdGlvbicsICdicmlnaHRuZXNzJ10sXG5cdFx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRcdGdyYWRpZW50OiBbJ2dyYWRpZW50JywgJ29yaWdpbicsICdkZXN0aW5hdGlvbicsICdoaWdobGlnaHQnXVxuXHR9O1xuXG5cdHZhciBjb21wb25lbnRQYXJzZXJzID0ge30sXG5cdFx0Y29sb3JDYWNoZSA9IHt9LFxuXHRcdGNvbG9yQ3R4O1xuXG5cdGZ1bmN0aW9uIGZyb21DU1Moc3RyaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eIyhcXHd7MSwyfSkoXFx3ezEsMn0pKFxcd3sxLDJ9KSQvKSxcblx0XHRcdGNvbXBvbmVudHM7XG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRjb21wb25lbnRzID0gWzAsIDAsIDBdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gcGFyc2VJbnQodmFsdWUubGVuZ3RoID09IDFcblx0XHRcdFx0XHRcdD8gdmFsdWUgKyB2YWx1ZSA6IHZhbHVlLCAxNikgLyAyNTU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXnJnYmE/XFwoKC4qKVxcKSQvKSkge1xuXHRcdFx0Y29tcG9uZW50cyA9IG1hdGNoWzFdLnNwbGl0KCcsJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICtjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gaSA8IDMgPyB2YWx1ZSAvIDI1NSA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY2FjaGVkID0gY29sb3JDYWNoZVtzdHJpbmddO1xuXHRcdFx0aWYgKCFjYWNoZWQpIHtcblx0XHRcdFx0aWYgKCFjb2xvckN0eCkge1xuXHRcdFx0XHRcdGNvbG9yQ3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0XHRcdFx0XHRjb2xvckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSBzdHJpbmc7XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNvbG9yQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuXHRcdFx0XHRjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ10gPSBbXG5cdFx0XHRcdFx0ZGF0YVswXSAvIDI1NSxcblx0XHRcdFx0XHRkYXRhWzFdIC8gMjU1LFxuXHRcdFx0XHRcdGRhdGFbMl0gLyAyNTVcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBjYWNoZWQuc2xpY2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cblxuXHR2YXIgaHNiSW5kaWNlcyA9IFtcblx0XHRbMCwgMywgMV0sXG5cdFx0WzIsIDAsIDFdLFxuXHRcdFsxLCAwLCAzXSxcblx0XHRbMSwgMiwgMF0sXG5cdFx0WzMsIDEsIDBdLFxuXHRcdFswLCAxLCAyXVxuXHRdO1xuXG5cdHZhciBjb252ZXJ0ZXJzID0ge1xuXHRcdCdyZ2ItaHNiJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGggPSBkZWx0YSA9PT0gMCA/IDBcblx0XHRcdFx0XHQ6XHQoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0Olx0XHRcdCAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwO1xuXHRcdFx0cmV0dXJuIFtoLCBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXgsIG1heF07XG5cdFx0fSxcblxuXHRcdCdoc2ItcmdiJzogZnVuY3Rpb24oaCwgcywgYikge1xuXHRcdFx0aCA9ICgoKGggLyA2MCkgJSA2KSArIDYpICUgNjtcblx0XHRcdHZhciBpID0gTWF0aC5mbG9vcihoKSxcblx0XHRcdFx0ZiA9IGggLSBpLFxuXHRcdFx0XHRpID0gaHNiSW5kaWNlc1tpXSxcblx0XHRcdFx0diA9IFtcblx0XHRcdFx0XHRiLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMpLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiBmKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogKDEgLSBmKSlcblx0XHRcdFx0XTtcblx0XHRcdHJldHVybiBbdltpWzBdXSwgdltpWzFdXSwgdltpWzJdXV07XG5cdFx0fSxcblxuXHRcdCdyZ2ItaHNsJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGFjaHJvbWF0aWMgPSBkZWx0YSA9PT0gMCxcblx0XHRcdFx0aCA9IGFjaHJvbWF0aWMgPyAwXG5cdFx0XHRcdFx0Olx0KCBtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0XHRcdFx0OiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDJcblx0XHRcdFx0XHRcdDpcdFx0XHQgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MCxcblx0XHRcdFx0bCA9IChtYXggKyBtaW4pIC8gMixcblx0XHRcdFx0cyA9IGFjaHJvbWF0aWMgPyAwIDogbCA8IDAuNVxuXHRcdFx0XHRcdFx0PyBkZWx0YSAvIChtYXggKyBtaW4pXG5cdFx0XHRcdFx0XHQ6IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHRcdFx0cmV0dXJuIFtoLCBzLCBsXTtcblx0XHR9LFxuXG5cdFx0J2hzbC1yZ2InOiBmdW5jdGlvbihoLCBzLCBsKSB7XG5cdFx0XHRoID0gKCgoaCAvIDM2MCkgJSAxKSArIDEpICUgMTtcblx0XHRcdGlmIChzID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW2wsIGwsIGxdO1xuXHRcdFx0dmFyIHQzcyA9IFsgaCArIDEgLyAzLCBoLCBoIC0gMSAvIDMgXSxcblx0XHRcdFx0dDIgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzLFxuXHRcdFx0XHR0MSA9IDIgKiBsIC0gdDIsXG5cdFx0XHRcdGMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHZhciB0MyA9IHQzc1tpXTtcblx0XHRcdFx0aWYgKHQzIDwgMCkgdDMgKz0gMTtcblx0XHRcdFx0aWYgKHQzID4gMSkgdDMgLT0gMTtcblx0XHRcdFx0Y1tpXSA9IDYgKiB0MyA8IDFcblx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzXG5cdFx0XHRcdFx0OiAyICogdDMgPCAxXG5cdFx0XHRcdFx0XHQ/IHQyXG5cdFx0XHRcdFx0XHQ6IDMgKiB0MyA8IDJcblx0XHRcdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDMpICogNlxuXHRcdFx0XHRcdFx0XHQ6IHQxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JheSc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHJldHVybiBbciAqIDAuMjk4OSArIGcgKiAwLjU4NyArIGIgKiAwLjExNF07XG5cdFx0fSxcblxuXHRcdCdncmF5LXJnYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbZywgZywgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzbCc6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmFkaWVudC1yZ2InOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmFkaWVudCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2godHlwZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHR5cGUpIHtcblx0XHRjb21wb25lbnRQYXJzZXJzW3R5cGVdID0gW107XG5cdFx0QmFzZS5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0aGFzT3ZlcmxhcCA9IC9eKGh1ZXxzYXR1cmF0aW9uKSQvLnRlc3QobmFtZSksXG5cdFx0XHRcdHBhcnNlciA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV1baW5kZXhdID0gbmFtZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdD8gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGhpcy5fY29tcG9uZW50c1swXTtcblx0XHRcdFx0XHRcdHZhbHVlID0gR3JhZGllbnQucmVhZChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0OiBhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQpXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudC5fcmVtb3ZlT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZS5fYWRkT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0PyBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkTnVsbDogbmFtZSA9PT0gJ2hpZ2hsaWdodCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9uZTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gMCA6IHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG5cdFx0XHRcdFx0fHwgaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50c1tpbmRleF1cblx0XHRcdFx0XHRcdDogdGhpcy5fY29udmVydCh0eXBlKVtpbmRleF07XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gdHlwZVxuXHRcdFx0XHRcdFx0JiYgIShoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKSkpIHtcblx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSwgdGhpcyk7XG5cdH0sIHtcblx0XHRfY2xhc3M6ICdDb2xvcicsXG5cdFx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbG9yKGFyZykge1xuXHRcdFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRyZWFkID0gMCxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0Y29tcG9uZW50cyxcblx0XHRcdFx0YWxwaGEsXG5cdFx0XHRcdHZhbHVlcztcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0YXJncyA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1swXTtcblx0XHRcdH1cblx0XHRcdHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZztcblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyAmJiBhcmcgaW4gdHlwZXMpIHtcblx0XHRcdFx0dHlwZSA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1sxXTtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmc7XG5cdFx0XHRcdFx0YWxwaGEgPSBhcmdzWzJdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3MsIDEpO1xuXHRcdFx0XHRcdGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dmFsdWVzID0gYXJnVHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdD8gYXJnc1xuXHRcdFx0XHRcdFx0OiBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBhcmdcblx0XHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRcdFx0aWYgKCF0eXBlKVxuXHRcdFx0XHRcdFx0dHlwZSA9IHZhbHVlcy5sZW5ndGggPj0gM1xuXHRcdFx0XHRcdFx0XHRcdD8gJ3JnYidcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5Jztcblx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gdHlwZXNbdHlwZV0ubGVuZ3RoO1xuXHRcdFx0XHRcdGFscGhhID0gdmFsdWVzW2xlbmd0aF07XG5cdFx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdFx0cmVhZCArPSB2YWx1ZXMgPT09IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHQ/IGxlbmd0aCArIChhbHBoYSAhPSBudWxsID8gMSA6IDApXG5cdFx0XHRcdFx0XHRcdDogMTtcblx0XHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA+IGxlbmd0aClcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHNsaWNlLmNhbGwodmFsdWVzLCAwLCBsZW5ndGgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dHlwZSA9ICdyZ2InO1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBmcm9tQ1NTKGFyZyk7XG5cdFx0XHRcdFx0aWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzLmxlbmd0aC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGlmIChhcmcuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gYXJnLl90eXBlO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBhcmcuX2FscGhhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gR3JhZGllbnQpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnZ3JhZGllbnQnO1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gYXJncztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdodWUnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHQ/ICdsaWdodG5lc3MnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2hzbCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdoc2InXG5cdFx0XHRcdFx0XHRcdDogJ2dyYWRpZW50JyBpbiBhcmcgfHwgJ3N0b3BzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdHx8ICdyYWRpYWwnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyAnZ3JheSdcblx0XHRcdFx0XHRcdFx0XHRcdDogJ3JnYic7XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdFx0XHRwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXTtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IGFyZ1twcm9wZXJ0aWVzW2ldXTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID09IG51bGwgJiYgaSA9PT0gMCAmJiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0XHQmJiAnc3RvcHMnIGluIGFyZykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RvcHM6IGFyZy5zdG9wcyxcblx0XHRcdFx0XHRcdFx0XHRcdHJhZGlhbDogYXJnLnJhZGlhbFxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5hbHBoYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkICYmIHR5cGUpXG5cdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZSB8fCAncmdiJztcblx0XHRcdGlmICh0eXBlID09PSAnZ3JhZGllbnQnKVxuXHRcdFx0XHR0aGlzLl9pZCA9IENvbG9yLl9pZCA9IChDb2xvci5faWQgfHwgMCkgKyAxO1xuXHRcdFx0aWYgKCFjb21wb25lbnRzKSB7XG5cdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdHZhciBwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0aGlzLl90eXBlXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZXMgJiYgdmFsdWVzW2ldKTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdGhpcy5fdHlwZV07XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdFx0fSxcblxuXHRcdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCk7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoXG5cdFx0XHRcdFx0L14oZ3JheXxyZ2IpJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyBjb21wb25lbnRzXG5cdFx0XHRcdFx0XHQ6IFt0aGlzLl90eXBlXS5jb25jYXQoY29tcG9uZW50cyksXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSxcblxuXHRcdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoNjUpO1xuXHRcdH0sXG5cblx0XHRfY29udmVydDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGNvbnZlcnRlcjtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG5cdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzLnNsaWNlKClcblx0XHRcdFx0XHQ6IChjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLScgKyB0eXBlXSlcblx0XHRcdFx0XHRcdD8gY29udmVydGVyLmFwcGx5KHRoaXMsIHRoaXMuX2NvbXBvbmVudHMpXG5cdFx0XHRcdFx0XHQ6IGNvbnZlcnRlcnNbJ3JnYi0nICsgdHlwZV0uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1t0aGlzLl90eXBlICsgJy1yZ2InXS5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMpKTtcblx0XHR9LFxuXG5cdFx0Y29udmVydDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0eXBlLCB0aGlzLl9jb252ZXJ0KHR5cGUpLCB0aGlzLl9hbHBoYSk7XG5cdFx0fSxcblxuXHRcdGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdFx0fSxcblxuXHRcdHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0fSxcblxuXHRcdGdldENvbXBvbmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRpZiAodGhpcy5fYWxwaGEgIT0gbnVsbClcblx0XHRcdFx0Y29tcG9uZW50cy5wdXNoKHRoaXMuX2FscGhhKTtcblx0XHRcdHJldHVybiBjb21wb25lbnRzO1xuXHRcdH0sXG5cblx0XHRnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbCA/IHRoaXMuX2FscGhhIDogMTtcblx0XHR9LFxuXG5cdFx0c2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhID09IG51bGwgPyBudWxsIDogTWF0aC5taW4oTWF0aC5tYXgoYWxwaGEsIDApLCAxKTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHR9LFxuXG5cdFx0aGFzQWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGw7XG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRcdHZhciBjb2wgPSBCYXNlLmlzUGxhaW5WYWx1ZShjb2xvciwgdHJ1ZSlcblx0XHRcdFx0XHQ/IENvbG9yLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHRcdDogY29sb3I7XG5cdFx0XHRyZXR1cm4gY29sID09PSB0aGlzIHx8IGNvbCAmJiB0aGlzLl9jbGFzcyA9PT0gY29sLl9jbGFzc1xuXHRcdFx0XHRcdCYmIHRoaXMuX3R5cGUgPT09IGNvbC5fdHlwZVxuXHRcdFx0XHRcdCYmIHRoaXMuX2FscGhhID09PSBjb2wuX2FscGhhXG5cdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fY29tcG9uZW50cywgY29sLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdHx8IGZhbHNlO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcGVydGllcyA9IHRoaXMuX3Byb3BlcnRpZXMsXG5cdFx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRcdGlzR3JhZGllbnQgPSB0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnLFxuXHRcdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl9jb21wb25lbnRzW2ldO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKHByb3BlcnRpZXNbaV0gKyAnOiAnXG5cdFx0XHRcdFx0XHRcdCsgKGlzR3JhZGllbnQgPyB2YWx1ZSA6IGYubnVtYmVyKHZhbHVlKSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdHBhcnRzLnB1c2goJ2FscGhhOiAnICsgZi5udW1iZXIodGhpcy5fYWxwaGEpKTtcblx0XHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdFx0fSxcblxuXHRcdHRvQ1NTOiBmdW5jdGlvbihoZXgpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29udmVydCgncmdiJyksXG5cdFx0XHRcdGFscGhhID0gaGV4IHx8IHRoaXMuX2FscGhhID09IG51bGwgPyAxIDogdGhpcy5fYWxwaGE7XG5cdFx0XHRmdW5jdGlvbiBjb252ZXJ0KHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCgodmFsIDwgMCA/IDAgOiB2YWwgPiAxID8gMSA6IHZhbCkgKiAyNTUpO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IFtcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzBdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzFdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzJdKVxuXHRcdFx0XTtcblx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaChhbHBoYSA8IDAgPyAwIDogYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGhleFxuXHRcdFx0XHRcdD8gJyMnICsgKCgxIDw8IDI0KSArIChjb21wb25lbnRzWzBdIDw8IDE2KVxuXHRcdFx0XHRcdFx0KyAoY29tcG9uZW50c1sxXSA8PCA4KVxuXHRcdFx0XHRcdFx0KyBjb21wb25lbnRzWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSlcblx0XHRcdFx0XHQ6IChjb21wb25lbnRzLmxlbmd0aCA9PSA0ID8gJ3JnYmEoJyA6ICdyZ2IoJylcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50cy5qb2luKCcsJykgKyAnKSc7XG5cdFx0fSxcblxuXHRcdHRvQ2FudmFzU3R5bGU6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0aWYgKHRoaXMuX2NhbnZhc1N0eWxlKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGU7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gJ2dyYWRpZW50Jylcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gdGhpcy50b0NTUygpO1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRncmFkaWVudCA9IGNvbXBvbmVudHNbMF0sXG5cdFx0XHRcdHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzLFxuXHRcdFx0XHRvcmlnaW4gPSBjb21wb25lbnRzWzFdLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbXBvbmVudHNbMl0sXG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50O1xuXHRcdFx0aWYgKGdyYWRpZW50Ll9yYWRpYWwpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IGRlc3RpbmF0aW9uLmdldERpc3RhbmNlKG9yaWdpbiksXG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBoaWdobGlnaHQuc3VidHJhY3Qob3JpZ2luKTtcblx0XHRcdFx0XHRpZiAodmVjdG9yLmdldExlbmd0aCgpID4gcmFkaXVzKVxuXHRcdFx0XHRcdFx0aGlnaGxpZ2h0ID0gb3JpZ2luLmFkZCh2ZWN0b3Iubm9ybWFsaXplKHJhZGl1cyAtIDAuMSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdGFydCA9IGhpZ2hsaWdodCB8fCBvcmlnaW47XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksXG5cdFx0XHRcdFx0XHQwLCBvcmlnaW4ueCwgb3JpZ2luLnksIHJhZGl1cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChvcmlnaW4ueCwgb3JpZ2luLnksXG5cdFx0XHRcdFx0XHRkZXN0aW5hdGlvbi54LCBkZXN0aW5hdGlvbi55KTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gc3RvcHNbaV07XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLl9yYW1wUG9pbnQsXG5cdFx0XHRcdFx0XHRzdG9wLl9jb2xvci50b0NhbnZhc1N0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gY2FudmFzR3JhZGllbnQ7XG5cdFx0fSxcblxuXHRcdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdF90eXBlczogdHlwZXMsXG5cblx0XHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb2xvcihyYW5kb20oKSwgcmFuZG9tKCksIHJhbmRvbSgpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdGFkZDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKyBiO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0sXG5cblx0XHRtdWx0aXBseTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKiBiO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC8gYjtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaChvcGVyYXRvcnMsIGZ1bmN0aW9uKG9wZXJhdG9yLCBuYW1lKSB7XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0Y29tcG9uZW50czEgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRjb21wb25lbnRzMiA9IGNvbG9yLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzMS5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNvbXBvbmVudHMyW2ldID0gb3BlcmF0b3IoY29tcG9uZW50czFbaV0sIGNvbXBvbmVudHMyW2ldKTtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50czIsXG5cdFx0XHRcdFx0dGhpcy5fYWxwaGEgIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IG9wZXJhdG9yKHRoaXMuX2FscGhhLCBjb2xvci5nZXRBbHBoYSgpKVxuXHRcdFx0XHRcdFx0XHQ6IG51bGwpO1xuXHRcdH07XG5cdH0sIHtcblx0fSk7XG59KTtcblxuQmFzZS5lYWNoKENvbG9yLl90eXBlcywgZnVuY3Rpb24ocHJvcGVydGllcywgdHlwZSkge1xuXHR2YXIgY3RvciA9IHRoaXNbQmFzZS5jYXBpdGFsaXplKHR5cGUpICsgJ0NvbG9yJ10gPSBmdW5jdGlvbihhcmcpIHtcblx0XHRcdHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZyxcblx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdD8gYXJnXG5cdFx0XHRcdFx0OiBhcmdUeXBlID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0XHQ6IGFyZ3VtZW50cztcblx0XHRcdHJldHVybiBjb21wb25lbnRzXG5cdFx0XHRcdFx0PyBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50cylcblx0XHRcdFx0XHQ6IG5ldyBDb2xvcihhcmcpO1xuXHRcdH07XG5cdGlmICh0eXBlLmxlbmd0aCA9PSAzKSB7XG5cdFx0dmFyIGFjcm9ueW0gPSB0eXBlLnRvVXBwZXJDYXNlKCk7XG5cdFx0Q29sb3JbYWNyb255bV0gPSB0aGlzW2Fjcm9ueW0gKyAnQ29sb3InXSA9IGN0b3I7XG5cdH1cbn0sIEJhc2UuZXhwb3J0cyk7XG5cbnZhciBHcmFkaWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JhZGllbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50KHN0b3BzLCByYWRpYWwpIHtcblx0XHR0aGlzLl9pZCA9IEdyYWRpZW50Ll9pZCA9IChHcmFkaWVudC5faWQgfHwgMCkgKyAxO1xuXHRcdGlmIChzdG9wcyAmJiB0aGlzLl9zZXQoc3RvcHMpKVxuXHRcdFx0c3RvcHMgPSByYWRpYWwgPSBudWxsO1xuXHRcdGlmICghdGhpcy5fc3RvcHMpXG5cdFx0XHR0aGlzLnNldFN0b3BzKHN0b3BzIHx8IFsnd2hpdGUnLCAnYmxhY2snXSk7XG5cdFx0aWYgKHRoaXMuX3JhZGlhbCA9PSBudWxsKVxuXHRcdFx0dGhpcy5zZXRSYWRpYWwodHlwZW9mIHJhZGlhbCA9PT0gJ3N0cmluZycgJiYgcmFkaWFsID09PSAncmFkaWFsJ1xuXHRcdFx0XHRcdHx8IHJhZGlhbCB8fCBmYWxzZSk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fc3RvcHMsIHRoaXMuX3JhZGlhbF0sXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fb3duZXJzICYmIHRoaXMuX293bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9vd25lcnNbaV0uX2NoYW5nZWQoKTtcblx0fSxcblxuXHRfYWRkT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0aWYgKCF0aGlzLl9vd25lcnMpXG5cdFx0XHR0aGlzLl9vd25lcnMgPSBbXTtcblx0XHR0aGlzLl9vd25lcnMucHVzaChjb2xvcik7XG5cdH0sXG5cblx0X3JlbW92ZU93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX293bmVycyA/IHRoaXMuX293bmVycy5pbmRleE9mKGNvbG9yKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0dGhpcy5fb3duZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRpZiAodGhpcy5fb3duZXJzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhpcy5fb3duZXJzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0b3BzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzdG9wc1tpXSA9IHRoaXMuX3N0b3BzW2ldLmNsb25lKCk7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudChzdG9wcyk7XG5cdH0sXG5cblx0Z2V0U3RvcHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdG9wcztcblx0fSxcblxuXHRzZXRTdG9wczogZnVuY3Rpb24oc3RvcHMpIHtcblx0XHRpZiAodGhpcy5zdG9wcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX3N0b3BzW2ldLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKHN0b3BzLmxlbmd0aCA8IDIpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J0dyYWRpZW50IHN0b3AgbGlzdCBuZWVkcyB0byBjb250YWluIGF0IGxlYXN0IHR3byBzdG9wcy4nKTtcblx0XHR0aGlzLl9zdG9wcyA9IEdyYWRpZW50U3RvcC5yZWFkQWxsKHN0b3BzLCAwLCB7IGNsb25lOiB0cnVlIH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc3RvcCA9IHRoaXMuX3N0b3BzW2ldO1xuXHRcdFx0c3RvcC5fb3duZXIgPSB0aGlzO1xuXHRcdFx0aWYgKHN0b3AuX2RlZmF1bHRSYW1wKVxuXHRcdFx0XHRzdG9wLnNldFJhbXBQb2ludChpIC8gKGwgLSAxKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRSYWRpYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpYWw7XG5cdH0sXG5cblx0c2V0UmFkaWFsOiBmdW5jdGlvbihyYWRpYWwpIHtcblx0XHR0aGlzLl9yYWRpYWwgPSByYWRpYWw7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oZ3JhZGllbnQpIHtcblx0XHRpZiAoZ3JhZGllbnQgPT09IHRoaXMpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAoZ3JhZGllbnQgJiYgdGhpcy5fY2xhc3MgPT09IGdyYWRpZW50Ll9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdG9wcy5sZW5ndGggPT09IGdyYWRpZW50Ll9zdG9wcy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fc3RvcHNbaV0uZXF1YWxzKGdyYWRpZW50Ll9zdG9wc1tpXSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBHcmFkaWVudFN0b3AgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50U3RvcCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnRTdG9wKGFyZzAsIGFyZzEpIHtcblx0XHRpZiAoYXJnMCkge1xuXHRcdFx0dmFyIGNvbG9yLCByYW1wUG9pbnQ7XG5cdFx0XHRpZiAoYXJnMSA9PT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwWzBdO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcwWzFdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmNvbG9yKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMC5jb2xvcjtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMC5yYW1wUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2xvciA9IGFyZzA7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldENvbG9yKGNvbG9yKTtcblx0XHRcdHRoaXMuc2V0UmFtcFBvaW50KHJhbXBQb2ludCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50U3RvcCh0aGlzLl9jb2xvci5jbG9uZSgpLCB0aGlzLl9yYW1wUG9pbnQpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NvbG9yLCB0aGlzLl9yYW1wUG9pbnRdLCBvcHRpb25zLCB0cnVlLFxuXHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX293bmVyKVxuXHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoNjUpO1xuXHR9LFxuXG5cdGdldFJhbXBQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhbXBQb2ludDtcblx0fSxcblxuXHRzZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKHJhbXBQb2ludCkge1xuXHRcdHRoaXMuX2RlZmF1bHRSYW1wID0gcmFtcFBvaW50ID09IG51bGw7XG5cdFx0dGhpcy5fcmFtcFBvaW50ID0gcmFtcFBvaW50IHx8IDA7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29sb3I7XG5cdH0sXG5cblx0c2V0Q29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dGhpcy5fY29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2NvbG9yID09PSBjb2xvcilcblx0XHRcdHRoaXMuX2NvbG9yID0gY29sb3IuY2xvbmUoKTtcblx0XHR0aGlzLl9jb2xvci5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN0b3ApIHtcblx0XHRyZXR1cm4gc3RvcCA9PT0gdGhpcyB8fCBzdG9wICYmIHRoaXMuX2NsYXNzID09PSBzdG9wLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9jb2xvci5lcXVhbHMoc3RvcC5fY29sb3IpXG5cdFx0XHRcdCYmIHRoaXMuX3JhbXBQb2ludCA9PSBzdG9wLl9yYW1wUG9pbnRcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgU3R5bGUgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0XHRmaWxsQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VDb2xvcjogdW5kZWZpbmVkLFxuXHRcdHN0cm9rZVdpZHRoOiAxLFxuXHRcdHN0cm9rZUNhcDogJ2J1dHQnLFxuXHRcdHN0cm9rZUpvaW46ICdtaXRlcicsXG5cdFx0c3Ryb2tlU2NhbGluZzogdHJ1ZSxcblx0XHRtaXRlckxpbWl0OiAxMCxcblx0XHRkYXNoT2Zmc2V0OiAwLFxuXHRcdGRhc2hBcnJheTogW10sXG5cdFx0d2luZGluZ1J1bGU6ICdub256ZXJvJyxcblx0XHRzaGFkb3dDb2xvcjogdW5kZWZpbmVkLFxuXHRcdHNoYWRvd0JsdXI6IDAsXG5cdFx0c2hhZG93T2Zmc2V0OiBuZXcgUG9pbnQoKSxcblx0XHRzZWxlY3RlZENvbG9yOiB1bmRlZmluZWQsXG5cdFx0Zm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuXHRcdGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuXHRcdGZvbnRTaXplOiAxMixcblx0XHRmb250OiAnc2Fucy1zZXJpZicsXG5cdFx0bGVhZGluZzogbnVsbCxcblx0XHRqdXN0aWZpY2F0aW9uOiAnbGVmdCdcblx0fTtcblxuXHR2YXIgZmxhZ3MgPSB7XG5cdFx0c3Ryb2tlV2lkdGg6IDk3LFxuXHRcdHN0cm9rZUNhcDogOTcsXG5cdFx0c3Ryb2tlSm9pbjogOTcsXG5cdFx0c3Ryb2tlU2NhbGluZzogMTA1LFxuXHRcdG1pdGVyTGltaXQ6IDk3LFxuXHRcdGZvbnRGYW1pbHk6IDksXG5cdFx0Zm9udFdlaWdodDogOSxcblx0XHRmb250U2l6ZTogOSxcblx0XHRmb250OiA5LFxuXHRcdGxlYWRpbmc6IDksXG5cdFx0anVzdGlmaWNhdGlvbjogOVxuXHR9O1xuXG5cdHZhciBpdGVtID0geyBiZWFuczogdHJ1ZSB9LFxuXHRcdGZpZWxkcyA9IHtcblx0XHRcdF9kZWZhdWx0czogZGVmYXVsdHMsXG5cdFx0XHRfdGV4dERlZmF1bHRzOiBuZXcgQmFzZShkZWZhdWx0cywge1xuXHRcdFx0XHRmaWxsQ29sb3I6IG5ldyBDb2xvcigpXG5cdFx0XHR9KSxcblx0XHRcdGJlYW5zOiB0cnVlXG5cdFx0fTtcblxuXHRCYXNlLmVhY2goZGVmYXVsdHMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgaXNDb2xvciA9IC9Db2xvciQvLnRlc3Qoa2V5KSxcblx0XHRcdGlzUG9pbnQgPSBrZXkgPT09ICdzaGFkb3dPZmZzZXQnLFxuXHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0ZmxhZyA9IGZsYWdzW2tleV0sXG5cdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQsXG5cdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQ7XG5cblx0XHRmaWVsZHNbc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW47XG5cdFx0XHRpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMFxuXHRcdFx0XHRcdCYmICEob3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGNoaWxkcmVuW2ldLl9zdHlsZVtzZXRdKHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvbGQgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKG9sZCAhPSB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChpc0NvbG9yKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkKVxuXHRcdFx0XHRcdFx0XHRvbGQuX293bmVyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUuX293bmVyKVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0dmFsdWUuX293bmVyID0gb3duZXI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKG93bmVyKVxuXHRcdFx0XHRcdFx0b3duZXIuX2NoYW5nZWQoZmxhZyB8fCA2NSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZmllbGRzW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG5cdFx0XHRcdHZhbHVlO1xuXHRcdFx0aWYgKCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgX2RvbnRNZXJnZVxuXHRcdFx0XHRcdHx8IG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY2xvbmUpXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY3RvciA9IGlzQ29sb3IgPyBDb2xvciA6IGlzUG9pbnQgPyBQb2ludCA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKGN0b3IgJiYgISh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gY3RvcikpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBjdG9yLnJlYWQoW3ZhbHVlXSwgMCxcblx0XHRcdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlLCBjbG9uZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiBpc0NvbG9yKVxuXHRcdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkVmFsdWUgPSBjaGlsZHJlbltpXS5fc3R5bGVbZ2V0XSgpO1xuXHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2hpbGRWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNoaWxkVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRpdGVtW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XShfZG9udE1lcmdlKTtcblx0XHR9O1xuXG5cdFx0aXRlbVtzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdH07XG5cdH0pO1xuXG5cdEl0ZW0uaW5qZWN0KGl0ZW0pO1xuXHRyZXR1cm4gZmllbGRzO1xufSwge1xuXHRfY2xhc3M6ICdTdHlsZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3R5bGUoc3R5bGUsIF9vd25lciwgX3Byb2plY3QpIHtcblx0XHR0aGlzLl92YWx1ZXMgPSB7fTtcblx0XHR0aGlzLl9vd25lciA9IF9vd25lcjtcblx0XHR0aGlzLl9wcm9qZWN0ID0gX293bmVyICYmIF9vd25lci5fcHJvamVjdCB8fCBfcHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuXHRcdGlmIChfb3duZXIgaW5zdGFuY2VvZiBUZXh0SXRlbSlcblx0XHRcdHRoaXMuX2RlZmF1bHRzID0gdGhpcy5fdGV4dERlZmF1bHRzO1xuXHRcdGlmIChzdHlsZSlcblx0XHRcdHRoaXMuc2V0KHN0eWxlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuXHRcdFx0dmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRyZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzc1xuXHRcdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl92YWx1ZXMsIHN0eWxlLl92YWx1ZXMpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0RmlsbENvbG9yKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldFN0cm9rZUNvbG9yKCkgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0U2hhZG93Q29sb3IoKSAmJiB0aGlzLmdldFNoYWRvd0JsdXIoKSA+IDA7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdGdldEZvbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdHJldHVybiB0aGlzLmdldEZvbnRXZWlnaHQoKVxuXHRcdFx0XHQrICcgJyArIGZvbnRTaXplICsgKC9bYS16XS9pLnRlc3QoZm9udFNpemUgKyAnJykgPyAnICcgOiAncHggJylcblx0XHRcdFx0KyB0aGlzLmdldEZvbnRGYW1pbHkoKTtcblx0fSxcblxuXHRnZXRGb250OiAnI2dldEZvbnRGYW1pbHknLFxuXHRzZXRGb250OiAnI3NldEZvbnRGYW1pbHknLFxuXG5cdGdldExlYWRpbmc6IGZ1bmN0aW9uIGdldExlYWRpbmcoKSB7XG5cdFx0dmFyIGxlYWRpbmcgPSBnZXRMZWFkaW5nLmJhc2UuY2FsbCh0aGlzKSxcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdGlmICgvcHR8ZW18JXxweC8udGVzdChmb250U2l6ZSkpXG5cdFx0XHRmb250U2l6ZSA9IHRoaXMuZ2V0VmlldygpLmdldFBpeGVsU2l6ZShmb250U2l6ZSk7XG5cdFx0cmV0dXJuIGxlYWRpbmcgIT0gbnVsbCA/IGxlYWRpbmcgOiBmb250U2l6ZSAqIDEuMjtcblx0fVxuXG59KTtcblxudmFyIERvbUVsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGhhbmRsZVByZWZpeChlbCwgbmFtZSwgc2V0LCB2YWx1ZSkge1xuXHRcdHZhciBwcmVmaXhlcyA9IFsnJywgJ3dlYmtpdCcsICdtb3onLCAnTW96JywgJ21zJywgJ28nXSxcblx0XHRcdHN1ZmZpeCA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV0sXG5cdFx0XHRcdGtleSA9IHByZWZpeCA/IHByZWZpeCArIHN1ZmZpeCA6IG5hbWU7XG5cdFx0XHRpZiAoa2V5IGluIGVsKSB7XG5cdFx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0XHRlbFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXRTdHlsZXM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwgJiYgZWwubm9kZVR5cGUgIT09IDkgPyBlbC5vd25lckRvY3VtZW50IDogZWwsXG5cdFx0XHRcdHZpZXcgPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0cmV0dXJuIHZpZXcgJiYgdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG5cdFx0fSxcblxuXHRcdGdldEJvdW5kczogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcblx0XHRcdFx0Ym9keSA9IGRvYy5ib2R5LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0cmVjdDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVjdCA9IHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5cdFx0XHR9XG5cdFx0XHR2YXIgeCA9IHJlY3QubGVmdCAtIChodG1sLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDApLFxuXHRcdFx0XHR5ID0gcmVjdC50b3AgLSAoaHRtbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCk7XG5cdFx0XHRpZiAoIXZpZXdwb3J0KSB7XG5cdFx0XHRcdHZhciB2aWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0XHR4ICs9IHZpZXcucGFnZVhPZmZzZXQgfHwgaHRtbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdFx0eSArPSB2aWV3LnBhZ2VZT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdH0sXG5cblx0XHRnZXRWaWV3cG9ydEJvdW5kczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHR2aWV3ID0gZG9jLmRlZmF1bHRWaWV3LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsXG5cdFx0XHRcdHZpZXcuaW5uZXJXaWR0aCB8fCBodG1sLmNsaWVudFdpZHRoLFxuXHRcdFx0XHR2aWV3LmlubmVySGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB2aWV3cG9ydCkuZ2V0UG9pbnQoKTtcblx0XHR9LFxuXG5cdFx0Z2V0U2l6ZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkuZ2V0U2l6ZSgpO1xuXHRcdH0sXG5cblx0XHRpc0ludmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldFNpemUoZWwpLmVxdWFscyhuZXcgU2l6ZSgwLCAwKSk7XG5cdFx0fSxcblxuXHRcdGlzSW5WaWV3OiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuICFEb21FbGVtZW50LmlzSW52aXNpYmxlKGVsKVxuXHRcdFx0XHRcdCYmIERvbUVsZW1lbnQuZ2V0Vmlld3BvcnRCb3VuZHMoZWwpLmludGVyc2VjdHMoXG5cdFx0XHRcdFx0XHREb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkpO1xuXHRcdH0sXG5cblx0XHRnZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUpIHtcblx0XHRcdHJldHVybiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUpO1xuXHRcdH0sXG5cblx0XHRzZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKVxuXHRcdFx0XHRcdGhhbmRsZVByZWZpeChlbCwga2V5LCB0cnVlLCBuYW1lW2tleV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBuYW1lLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIERvbUV2ZW50ID0ge1xuXHRhZGQ6IGZ1bmN0aW9uKGVsLCBldmVudHMpIHtcblx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHBvcyA9IGV2ZW50LnRhcmdldFRvdWNoZXNcblx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aFxuXHRcdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXVxuXHRcdFx0XHRcdDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cblx0XHRcdFx0OiBldmVudDtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG5cdFx0XHRwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG5cdFx0KTtcblx0fSxcblxuXHRnZXRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXHR9LFxuXG5cdGdldFJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiBEb21FdmVudC5nZXRQb2ludChldmVudCkuc3VidHJhY3QoRG9tRWxlbWVudC5nZXRPZmZzZXQoXG5cdFx0XHRcdHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG59O1xuXG5Eb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBuYXRpdmVSZXF1ZXN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcblx0XHRcdERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQod2luZG93LCAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyksXG5cdFx0cmVxdWVzdGVkID0gZmFsc2UsXG5cdFx0Y2FsbGJhY2tzID0gW10sXG5cdFx0Zm9jdXNlZCA9IHRydWUsXG5cdFx0dGltZXI7XG5cblx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyApIHtcblx0XHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvY3VzZWQgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGJsdXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb2N1c2VkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVDYWxsYmFja3MoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGNhbGxiYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGVudHJ5ID0gY2FsbGJhY2tzW2ldLFxuXHRcdFx0XHRmdW5jID0gZW50cnlbMF0sXG5cdFx0XHRcdGVsID0gZW50cnlbMV07XG5cdFx0XHRpZiAoIWVsIHx8IChQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShlbCwgJ2tlZXBhbGl2ZScpID09ICd0cnVlJ1xuXHRcdFx0XHRcdHx8IGZvY3VzZWQpICYmIERvbUVsZW1lbnQuaXNJblZpZXcoZWwpKSB7XG5cdFx0XHRcdGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGZ1bmMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG5hdGl2ZVJlcXVlc3QpIHtcblx0XHRcdGlmIChjYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuXHRcdGNhbGxiYWNrcy5wdXNoKFtjYWxsYmFjaywgZWxlbWVudF0pO1xuXHRcdGlmIChuYXRpdmVSZXF1ZXN0KSB7XG5cdFx0XHRpZiAoIXJlcXVlc3RlZCkge1xuXHRcdFx0XHRuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG5cdFx0XHRcdHJlcXVlc3RlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghdGltZXIpIHtcblx0XHRcdHRpbWVyID0gc2V0SW50ZXJ2YWwoaGFuZGxlQ2FsbGJhY2tzLCAxMDAwIC8gNjApO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBWaWV3ID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRfY2xhc3M6ICdWaWV3JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBWaWV3KHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHR0aGlzLl9zY29wZSA9IHByb2plY3QuX3Njb3BlO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXHRcdHZhciBzaXplO1xuXHRcdGlmICggIW5vQ2FudmFzICkge1xuXHRcdFx0aWYgKCF0aGlzLl9waXhlbFJhdGlvKVxuXHRcdFx0XHR0aGlzLl9waXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblx0XHRcdHRoaXMuX2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0XHRpZiAodGhpcy5faWQgPT0gbnVsbClcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5faWQgPSAndmlldy0nICsgVmlldy5faWQrKyk7XG5cdFx0XHREb21FdmVudC5hZGQoZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0XHR2YXIgbm9uZSA9ICdub25lJztcblx0XHRcdERvbUVsZW1lbnQuc2V0UHJlZml4ZWQoZWxlbWVudC5zdHlsZSwge1xuXHRcdFx0XHR1c2VyU2VsZWN0OiBub25lLFxuXHRcdFx0XHR0b3VjaEFjdGlvbjogbm9uZSxcblx0XHRcdFx0dG91Y2hDYWxsb3V0OiBub25lLFxuXHRcdFx0XHRjb250ZW50Wm9vbWluZzogbm9uZSxcblx0XHRcdFx0dXNlckRyYWc6IG5vbmUsXG5cdFx0XHRcdHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcblx0XHRcdH0pO1xuXHRcdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gRG9tRWxlbWVudC5nZXRPZmZzZXQoZWxlbWVudCwgdHJ1ZSksXG5cdFx0XHRcdFx0dGhhdCA9IHRoaXM7XG5cdFx0XHRcdHNpemUgPSBEb21FbGVtZW50LmdldFZpZXdwb3J0Qm91bmRzKGVsZW1lbnQpXG5cdFx0XHRcdFx0XHQuZ2V0U2l6ZSgpLnN1YnRyYWN0KG9mZnNldCk7XG5cdFx0XHRcdHRoaXMuX3dpbmRvd0V2ZW50cyA9IHtcblx0XHRcdFx0XHRyZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCFEb21FbGVtZW50LmlzSW52aXNpYmxlKGVsZW1lbnQpKVxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50LCB0cnVlKTtcblx0XHRcdFx0XHRcdHRoYXQuc2V0Vmlld1NpemUoRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbGVtZW50KVxuXHRcdFx0XHRcdFx0XHRcdC5nZXRTaXplKCkuc3VidHJhY3Qob2Zmc2V0KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHREb21FdmVudC5hZGQod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2l6ZSA9IERvbUVsZW1lbnQuZ2V0U2l6ZShlbGVtZW50KTtcblx0XHRcdFx0aWYgKHNpemUuaXNOYU4oKSB8fCBzaXplLmlzWmVybygpKSB7XG5cdFx0XHRcdFx0dmFyIGdldFNpemUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudFtuYW1lXVxuXHRcdFx0XHRcdFx0XHRcdHx8IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpLCAxMCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0U2l6ZSgnd2lkdGgnKSwgZ2V0U2l6ZSgnaGVpZ2h0JykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZXRWaWV3U2l6ZShzaXplKTtcblx0XHRcdGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAnc3RhdHMnKVxuXHRcdFx0XHRcdCYmIHR5cGVvZiBTdGF0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0dGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoKTtcblx0XHRcdFx0dmFyIHN0YXRzID0gdGhpcy5fc3RhdHMuZG9tRWxlbWVudCxcblx0XHRcdFx0XHRzdHlsZSA9IHN0YXRzLnN0eWxlLFxuXHRcdFx0XHRcdG9mZnNldCA9IERvbUVsZW1lbnQuZ2V0T2Zmc2V0KGVsZW1lbnQpO1xuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRcdHN0eWxlLmxlZnQgPSBvZmZzZXQueCArICdweCc7XG5cdFx0XHRcdHN0eWxlLnRvcCA9IG9mZnNldC55ICsgJ3B4Jztcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cyk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl9waXhlbFJhdGlvKVxuXHRcdFx0XHR0aGlzLl9waXhlbFJhdGlvID0gMTtcblx0XHRcdHRoaXMuX2lkID0gJ3ZpZXctJyArIFZpZXcuX2lkKys7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQpO1xuXHRcdH1cblx0XHRWaWV3Ll92aWV3cy5wdXNoKHRoaXMpO1xuXHRcdFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdHRoaXMuX3ZpZXdTaXplID0gc2l6ZTtcblx0XHQodGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpKS5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3pvb20gPSAxO1xuXHRcdGlmICghVmlldy5fZm9jdXNlZClcblx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0aGlzO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1Db3VudCA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Byb2plY3QpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKFZpZXcuX2ZvY3VzZWQgPT09IHRoaXMpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gbnVsbDtcblx0XHRWaWV3Ll92aWV3cy5zcGxpY2UoVmlldy5fdmlld3MuaW5kZXhPZih0aGlzKSwgMSk7XG5cdFx0ZGVsZXRlIFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF07XG5cdFx0aWYgKHRoaXMuX3Byb2plY3QuX3ZpZXcgPT09IHRoaXMpXG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll92aWV3ID0gbnVsbDtcblx0XHREb21FdmVudC5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzKTtcblx0XHR0aGlzLl9lbGVtZW50ID0gdGhpcy5fcHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5vZmYoJ2ZyYW1lJyk7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfZXZlbnRzOiB7XG5cdFx0b25GcmFtZToge1xuXHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGxheSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvblJlc2l6ZToge31cblx0fSxcblxuXHRfYW5pbWF0ZTogZmFsc2UsXG5cdF90aW1lOiAwLFxuXHRfY291bnQ6IDAsXG5cblx0X3JlcXVlc3RGcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdERvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcblx0XHRcdHRoYXQuX3JlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKCF0aGF0Ll9hbmltYXRlKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR0aGF0Ll9yZXF1ZXN0RnJhbWUoKTtcblx0XHRcdHRoYXQuX2hhbmRsZUZyYW1lKCk7XG5cdFx0fSwgdGhpcy5fZWxlbWVudCk7XG5cdFx0dGhpcy5fcmVxdWVzdGVkID0gdHJ1ZTtcblx0fSxcblxuXHRfaGFuZGxlRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHBhcGVyID0gdGhpcy5fc2NvcGU7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCkgLyAxMDAwLFxuXHRcdFx0ZGVsdGEgPSB0aGlzLl9iZWZvcmUgPyBub3cgLSB0aGlzLl9iZWZvcmUgOiAwO1xuXHRcdHRoaXMuX2JlZm9yZSA9IG5vdztcblx0XHR0aGlzLl9oYW5kbGluZ0ZyYW1lID0gdHJ1ZTtcblx0XHR0aGlzLmVtaXQoJ2ZyYW1lJywgbmV3IEJhc2Uoe1xuXHRcdFx0ZGVsdGE6IGRlbHRhLFxuXHRcdFx0dGltZTogdGhpcy5fdGltZSArPSBkZWx0YSxcblx0XHRcdGNvdW50OiB0aGlzLl9jb3VudCsrXG5cdFx0fSkpO1xuXHRcdGlmICh0aGlzLl9zdGF0cylcblx0XHRcdHRoaXMuX3N0YXRzLnVwZGF0ZSgpO1xuXHRcdHRoaXMuX2hhbmRsaW5nRnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlSXRlbTogZnVuY3Rpb24oaXRlbSwgYW5pbWF0ZSkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2ZyYW1lSXRlbXM7XG5cdFx0aWYgKGFuaW1hdGUpIHtcblx0XHRcdGl0ZW1zW2l0ZW0uX2lkXSA9IHtcblx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0dGltZTogMCxcblx0XHRcdFx0Y291bnQ6IDBcblx0XHRcdH07XG5cdFx0XHRpZiAoKyt0aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMSlcblx0XHRcdFx0dGhpcy5vbignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIGl0ZW1zW2l0ZW0uX2lkXTtcblx0XHRcdGlmICgtLXRoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAwKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlRnJhbWVJdGVtczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2ZyYW1lSXRlbXMpIHtcblx0XHRcdHZhciBlbnRyeSA9IHRoaXMuX2ZyYW1lSXRlbXNbaV07XG5cdFx0XHRlbnRyeS5pdGVtLmVtaXQoJ2ZyYW1lJywgbmV3IEJhc2UoZXZlbnQsIHtcblx0XHRcdFx0dGltZTogZW50cnkudGltZSArPSBldmVudC5kZWx0YSxcblx0XHRcdFx0Y291bnQ6IGVudHJ5LmNvdW50Kytcblx0XHRcdH0pKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdGlmICh0aGlzLl9oYW5kbGluZ0ZyYW1lKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmICh0aGlzLl9hbmltYXRlKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVGcmFtZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHRpZiAoZmxhZ3MgJiAxKVxuXHRcdFx0dGhpcy5fcHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHRoaXMuX21hdHJpeC5jb25jYXRlbmF0ZShtYXRyaXgpO1xuXHRcdHRoaXMuX2JvdW5kcyA9IG51bGw7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG5cdH0sXG5cblx0Z2V0UmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW8gKiA3Mjtcblx0fSxcblxuXHRnZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRWaWV3U2l6ZScpO1xuXHR9LFxuXG5cdHNldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0ZGVsdGEgPSBzaXplLnN1YnRyYWN0KHRoaXMuX3ZpZXdTaXplKTtcblx0XHRpZiAoZGVsdGEuaXNaZXJvKCkpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fdmlld1NpemUuc2V0KHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHR0aGlzLl9zZXRWaWV3U2l6ZShzaXplKTtcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHRcdHRoaXMuZW1pdCgncmVzaXplJywge1xuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdGRlbHRhOiBkZWx0YVxuXHRcdH0pO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9zZXRWaWV3U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcblx0XHRlbGVtZW50LndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRlbGVtZW50LmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9tYXRyaXguaW52ZXJ0ZWQoKS5fdHJhbnNmb3JtQm91bmRzKFxuXHRcdFx0XHRcdG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksIHRoaXMuX3ZpZXdTaXplKSk7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRTaXplKCk7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcblx0fSxcblxuXHRzZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zY3JvbGxCeShjZW50ZXIuc3VidHJhY3QodGhpcy5nZXRDZW50ZXIoKSkpO1xuXHR9LFxuXG5cdGdldFpvb206IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl96b29tO1xuXHR9LFxuXG5cdHNldFpvb206IGZ1bmN0aW9uKHpvb20pIHtcblx0XHR0aGlzLl90cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnNjYWxlKHpvb20gLyB0aGlzLl96b29tLFxuXHRcdFx0dGhpcy5nZXRDZW50ZXIoKSkpO1xuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xuXHR9LFxuXG5cdGlzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIERvbUVsZW1lbnQuaXNJblZpZXcodGhpcy5fZWxlbWVudCk7XG5cdH0sXG5cblx0c2Nyb2xsQnk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3RyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5uZWdhdGUoKSkpO1xuXHR9LFxuXG5cdHBsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2FuaW1hdGUgPSB0cnVlO1xuXHRcdGlmICghdGhpcy5fcmVxdWVzdGVkKVxuXHRcdFx0dGhpcy5fcmVxdWVzdEZyYW1lKCk7XG5cdH0sXG5cblx0cGF1c2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdHByb2plY3RUb1ZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0dmlld1RvUHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9XG5cbn0sIHtcblx0c3RhdGljczoge1xuXHRcdF92aWV3czogW10sXG5cdFx0X3ZpZXdzQnlJZDoge30sXG5cdFx0X2lkOiAwLFxuXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbihwcm9qZWN0LCBlbGVtZW50KSB7XG5cdFx0XHRpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCk7XG5cdFx0XHRyZXR1cm4gbmV3IENhbnZhc1ZpZXcocHJvamVjdCwgZWxlbWVudCk7XG5cdFx0fVxuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdGlmICggbm9DYW52YXMgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHRvb2wsXG5cdFx0cHJldkZvY3VzLFxuXHRcdHRlbXBGb2N1cyxcblx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGdldFZpZXcoZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KTtcblx0XHRyZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBWaWV3Ll92aWV3c0J5SWRbdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKV07XG5cdH1cblxuXHRmdW5jdGlvbiB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSB7XG5cdFx0cmV0dXJuIHZpZXcudmlld1RvUHJvamVjdChEb21FdmVudC5nZXRPZmZzZXQoZXZlbnQsIHZpZXcuX2VsZW1lbnQpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUZvY3VzKCkge1xuXHRcdGlmICghVmlldy5fZm9jdXNlZCB8fCAhVmlldy5fZm9jdXNlZC5pc1Zpc2libGUoKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBWaWV3Ll92aWV3cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBWaWV3Ll92aWV3c1tpXTtcblx0XHRcdFx0aWYgKHZpZXcgJiYgdmlldy5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB2aWV3O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHBvaW50LCBldmVudCkge1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZW1vdmUnLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZhciB0b29sID0gdmlldy5fc2NvcGUudG9vbDtcblx0XHRpZiAodG9vbCkge1xuXHRcdFx0dG9vbC5faGFuZGxlRXZlbnQoZHJhZ2dpbmcgJiYgdG9vbC5yZXNwb25kcygnbW91c2VkcmFnJylcblx0XHRcdFx0XHQ/ICdtb3VzZWRyYWcnIDogJ21vdXNlbW92ZScsIHBvaW50LCBldmVudCk7XG5cdFx0fVxuXHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0cmV0dXJuIHRvb2w7XG5cdH1cblxuXHR2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcblx0XHRtb3VzZWRvd24sIG1vdXNlbW92ZSwgbW91c2V1cDtcblx0aWYgKG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuXHRcdG1vdXNlZG93biA9ICdwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJztcblx0XHRtb3VzZW1vdmUgPSAncG9pbnRlcm1vdmUgTVNQb2ludGVyTW92ZSc7XG5cdFx0bW91c2V1cCA9ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xuXHR9IGVsc2Uge1xuXHRcdG1vdXNlZG93biA9ICd0b3VjaHN0YXJ0Jztcblx0XHRtb3VzZW1vdmUgPSAndG91Y2htb3ZlJztcblx0XHRtb3VzZXVwID0gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJztcblx0XHRpZiAoISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChcblx0XHRcdFx0L21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kpKSkge1xuXHRcdFx0bW91c2Vkb3duICs9ICcgbW91c2Vkb3duJztcblx0XHRcdG1vdXNlbW92ZSArPSAnIG1vdXNlbW92ZSc7XG5cdFx0XHRtb3VzZXVwICs9ICcgbW91c2V1cCc7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHZpZXdFdmVudHMgPSB7XG5cdFx0J3NlbGVjdHN0YXJ0IGRyYWdzdGFydCc6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZiAoZHJhZ2dpbmcpXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBkb2NFdmVudHMgPSB7XG5cdFx0bW91c2VvdXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRcdHRhcmdldCA9IERvbUV2ZW50LmdldFJlbGF0ZWRUYXJnZXQoZXZlbnQpO1xuXHRcdFx0aWYgKHZpZXcgJiYgKCF0YXJnZXQgfHwgdGFyZ2V0Lm5vZGVOYW1lID09PSAnSFRNTCcpKVxuXHRcdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCksIGV2ZW50KTtcblx0XHR9LFxuXG5cdFx0c2Nyb2xsOiB1cGRhdGVGb2N1c1xuXHR9O1xuXG5cdHZpZXdFdmVudHNbbW91c2Vkb3duXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gZ2V0VmlldyhldmVudCksXG5cdFx0XHRwb2ludCA9IHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpO1xuXHRcdGRyYWdnaW5nID0gdHJ1ZTtcblx0XHR2aWV3Ll9oYW5kbGVFdmVudCgnbW91c2Vkb3duJywgcG9pbnQsIGV2ZW50KTtcblx0XHRpZiAodG9vbCA9IHZpZXcuX3Njb3BlLnRvb2wpXG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudCgnbW91c2Vkb3duJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZW1vdmVdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCFkcmFnZ2luZykge1xuXHRcdFx0dmFyIHRhcmdldCA9IGdldFZpZXcoZXZlbnQpO1xuXHRcdFx0aWYgKHRhcmdldCkge1xuXHRcdFx0XHRpZiAodmlldyAhPT0gdGFyZ2V0KVxuXHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuXHRcdFx0XHRwcmV2Rm9jdXMgPSB2aWV3O1xuXHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHRhcmdldDtcblx0XHRcdH0gZWxzZSBpZiAodGVtcEZvY3VzICYmIHRlbXBGb2N1cyA9PT0gdmlldykge1xuXHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHByZXZGb2N1cztcblx0XHRcdFx0dXBkYXRlRm9jdXMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdHZhciBwb2ludCA9IHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpO1xuXHRcdFx0aWYgKGRyYWdnaW5nIHx8IHZpZXcuZ2V0Qm91bmRzKCkuY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHR0b29sID0gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHBvaW50LCBldmVudCk7XG5cdFx0fVxuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZXVwXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXHRcdGlmICghdmlldyB8fCAhZHJhZ2dpbmcpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0ZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHR2aWV3Ll9oYW5kbGVFdmVudCgnbW91c2V1cCcsIHBvaW50LCBldmVudCk7XG5cdFx0aWYgKHRvb2wpXG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudCgnbW91c2V1cCcsIHBvaW50LCBldmVudCk7XG5cdFx0dmlldy51cGRhdGUoKTtcblx0fTtcblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIGRvY0V2ZW50cyk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGxvYWQ6IHVwZGF0ZUZvY3VzXG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0X3ZpZXdFdmVudHM6IHZpZXdFdmVudHMsXG5cblx0XHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKCkge30sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHR1cGRhdGVGb2N1czogdXBkYXRlRm9jdXNcblx0XHR9XG5cdH07XG59KTtcblxudmFyIENhbnZhc1ZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cdF9jbGFzczogJ0NhbnZhc1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENhbnZhc1ZpZXcocHJvamVjdCwgY2FudmFzKSB7XG5cdFx0aWYgKCAhbm9DYW52YXMgKSB7XG5cdFx0XHRpZiAoIShjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpIHtcblx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0aWYgKHNpemUuaXNaZXJvKCkpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBDYW52YXNWaWV3IHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50OiAnXG5cdFx0XHRcdFx0XHRcdCsgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdH1cblx0XHR0aGlzLl9ldmVudENvdW50ZXJzID0ge307XG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IDE7XG5cdFx0aWYgKCFub0NhbnZhcyAmJiAhL15vZmZ8ZmFsc2UkLy50ZXN0KFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGNhbnZhcywgJ2hpZHBpJykpKSB7XG5cdFx0XHR2YXIgZGV2aWNlUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0XHRiYWNraW5nU3RvcmVSYXRpbyA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQodGhpcy5fY29udGV4dCxcblx0XHRcdFx0XHRcdCdiYWNraW5nU3RvcmVQaXhlbFJhdGlvJykgfHwgMTtcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBkZXZpY2VSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuXHRcdH1cblx0XHRWaWV3LmNhbGwodGhpcywgcHJvamVjdCwgY2FudmFzKTtcblx0fSxcblxuXHRfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgd2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQsXG5cdFx0XHRwaXhlbFJhdGlvID0gdGhpcy5fcGl4ZWxSYXRpbyxcblx0XHRcdGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuXHRcdFx0c3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXHRcdGVsZW1lbnQud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0ZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXHRcdGlmIChwaXhlbFJhdGlvICE9PSAxKSB7XG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHRcdHN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cdFx0XHR0aGlzLl9jb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQaXhlbFNpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQ7XG5cdFx0Y3R4LmZvbnQgPSBzaXplICsgJyBzZXJpZic7XG5cdFx0c2l6ZSA9IHBhcnNlRmxvYXQoY3R4LmZvbnQpO1xuXHRcdGN0eC5mb250ID0gcHJldkZvbnQ7XG5cdFx0cmV0dXJuIHNpemU7XG5cdH0sXG5cblx0Z2V0VGV4dFdpZHRoOiBmdW5jdGlvbihmb250LCBsaW5lcykge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0cHJldkZvbnQgPSBjdHguZm9udCxcblx0XHRcdHdpZHRoID0gMDtcblx0XHRjdHguZm9udCA9IGZvbnQ7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoKTtcblx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdHJldHVybiB3aWR0aDtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAoIXByb2plY3QgfHwgIXByb2plY3QuX25lZWRzVXBkYXRlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0c2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCArIDEsIHNpemUuaGVpZ2h0ICsgMSk7XG5cdFx0cHJvamVjdC5kcmF3KGN0eCwgdGhpcy5fbWF0cml4LCB0aGlzLl9waXhlbFJhdGlvKTtcblx0XHRwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGRvd25Qb2ludCxcblx0XHRsYXN0UG9pbnQsXG5cdFx0b3ZlclBvaW50LFxuXHRcdGRvd25JdGVtLFxuXHRcdGxhc3RJdGVtLFxuXHRcdG92ZXJJdGVtLFxuXHRcdGRyYWdJdGVtLFxuXHRcdGRibENsaWNrLFxuXHRcdGNsaWNrVGltZTtcblxuXHRmdW5jdGlvbiBjYWxsRXZlbnQodmlldywgdHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGxhc3RQb2ludCkge1xuXHRcdHZhciBpdGVtID0gdGFyZ2V0LFxuXHRcdFx0bW91c2VFdmVudDtcblxuXHRcdGZ1bmN0aW9uIGNhbGwob2JqKSB7XG5cdFx0XHRpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRcdGlmICghbW91c2VFdmVudCkge1xuXHRcdFx0XHRcdG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGFzdFBvaW50ID8gcG9pbnQuc3VidHJhY3QobGFzdFBvaW50KSA6IG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvYmouZW1pdCh0eXBlLCBtb3VzZUV2ZW50KSAmJiBtb3VzZUV2ZW50LmlzU3RvcHBlZCkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKGNhbGwoaXRlbSkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdGlmIChjYWxsKHZpZXcpKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBldmVudCkge1xuXHRcdFx0aWYgKCF0aGlzLl9ldmVudENvdW50ZXJzW3R5cGVdKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdGhpdCA9IHByb2plY3QuaGl0VGVzdChwb2ludCwge1xuXHRcdFx0XHRcdHRvbGVyYW5jZTogMCxcblx0XHRcdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0XHRcdHN0cm9rZTogdHJ1ZVxuXHRcdFx0XHR9KSxcblx0XHRcdFx0aXRlbSA9IGhpdCAmJiBoaXQuaXRlbSxcblx0XHRcdFx0c3RvcHBlZCA9IGZhbHNlO1xuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG5cdFx0XHRcdGRibENsaWNrID0gbGFzdEl0ZW0gPT0gaXRlbSAmJiAoRGF0ZS5ub3coKSAtIGNsaWNrVGltZSA8IDMwMCk7XG5cdFx0XHRcdGRvd25JdGVtID0gbGFzdEl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRkb3duUG9pbnQgPSBsYXN0UG9pbnQgPSBvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0ZHJhZ0l0ZW0gPSAhc3RvcHBlZCAmJiBpdGVtO1xuXHRcdFx0XHR3aGlsZSAoZHJhZ0l0ZW0gJiYgIWRyYWdJdGVtLnJlc3BvbmRzKCdtb3VzZWRyYWcnKSlcblx0XHRcdFx0XHRkcmFnSXRlbSA9IGRyYWdJdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtLCBkb3duUG9pbnQpO1xuXHRcdFx0XHRpZiAoZHJhZ0l0ZW0pIHtcblx0XHRcdFx0XHRpZiAobGFzdFBvaW50ICYmICFsYXN0UG9pbnQuZXF1YWxzKHBvaW50KSlcblx0XHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VkcmFnJywgZXZlbnQsIHBvaW50LCBkcmFnSXRlbSxcblx0XHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQpO1xuXHRcdFx0XHRcdGlmIChpdGVtICE9PSBkcmFnSXRlbSkge1xuXHRcdFx0XHRcdFx0b3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCwgaXRlbSxcblx0XHRcdFx0XHRcdFx0XHRvdmVyUG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN0b3BwZWQgJiYgaXRlbSAmJiBpdGVtID09PSBkb3duSXRlbSkge1xuXHRcdFx0XHRcdGNsaWNrVGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsIGRibENsaWNrICYmIGRvd25JdGVtLnJlc3BvbmRzKCdkb3VibGVjbGljaycpXG5cdFx0XHRcdFx0XHRcdD8gJ2RvdWJsZWNsaWNrJyA6ICdjbGljaycsIGV2ZW50LCBkb3duUG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHRcdGRibENsaWNrID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZG93bkl0ZW0gPSBkcmFnSXRlbSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0aWYgKGRyYWdJdGVtKVxuXHRcdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCxcblx0XHRcdFx0XHRcdFx0ZHJhZ0l0ZW0sIGxhc3RQb2ludCk7XG5cdFx0XHRcdGlmICghc3RvcHBlZCkge1xuXHRcdFx0XHRcdGlmIChpdGVtICE9PSBvdmVySXRlbSlcblx0XHRcdFx0XHRcdG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtLFxuXHRcdFx0XHRcdFx0XHRvdmVyUG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RQb2ludCA9IG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pIHtcblx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlbGVhdmUnLCBldmVudCwgcG9pbnQsIG92ZXJJdGVtKTtcblx0XHRcdFx0XHRvdmVySXRlbSA9IGl0ZW07XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWVudGVyJywgZXZlbnQsIHBvaW50LCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdG9wcGVkO1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgRXZlbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0V2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBFdmVudChldmVudCkge1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fSxcblxuXHRpc1ByZXZlbnRlZDogZmFsc2UsXG5cdGlzU3RvcHBlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0dGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdGdldE1vZGlmaWVyczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEtleS5tb2RpZmllcnM7XG5cdH1cbn0pO1xuXG52YXIgS2V5RXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdLZXlFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gS2V5RXZlbnQoZG93biwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KSB7XG5cdFx0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0dGhpcy50eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCc7XG5cdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0dGhpcy5jaGFyYWN0ZXIgPSBjaGFyYWN0ZXI7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBrZXk6ICdcIiArIHRoaXMua2V5XG5cdFx0XHRcdCsgXCInLCBjaGFyYWN0ZXI6ICdcIiArIHRoaXMuY2hhcmFjdGVyXG5cdFx0XHRcdCsgXCInLCBtb2RpZmllcnM6IFwiICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrIFwiIH1cIjtcblx0fVxufSk7XG5cbnZhciBLZXkgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdGlmICggbm9DYW52YXMgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHNwZWNpYWxLZXlzID0ge1xuXHRcdDg6ICdiYWNrc3BhY2UnLFxuXHRcdDk6ICd0YWInLFxuXHRcdDEzOiAnZW50ZXInLFxuXHRcdDE2OiAnc2hpZnQnLFxuXHRcdDE3OiAnY29udHJvbCcsXG5cdFx0MTg6ICdvcHRpb24nLFxuXHRcdDE5OiAncGF1c2UnLFxuXHRcdDIwOiAnY2Fwcy1sb2NrJyxcblx0XHQyNzogJ2VzY2FwZScsXG5cdFx0MzI6ICdzcGFjZScsXG5cdFx0MzU6ICdlbmQnLFxuXHRcdDM2OiAnaG9tZScsXG5cdFx0Mzc6ICdsZWZ0Jyxcblx0XHQzODogJ3VwJyxcblx0XHQzOTogJ3JpZ2h0Jyxcblx0XHQ0MDogJ2Rvd24nLFxuXHRcdDQ2OiAnZGVsZXRlJyxcblx0XHQ5MTogJ2NvbW1hbmQnLFxuXHRcdDkzOiAnY29tbWFuZCcsXG5cdFx0MjI0OiAnY29tbWFuZCdcblx0fSxcblxuXHRzcGVjaWFsQ2hhcnMgPSB7XG5cdFx0OTogdHJ1ZSxcblx0XHQxMzogdHJ1ZSxcblx0XHQzMjogdHJ1ZVxuXHR9LFxuXG5cdG1vZGlmaWVycyA9IG5ldyBCYXNlKHtcblx0XHRzaGlmdDogZmFsc2UsXG5cdFx0Y29udHJvbDogZmFsc2UsXG5cdFx0b3B0aW9uOiBmYWxzZSxcblx0XHRjb21tYW5kOiBmYWxzZSxcblx0XHRjYXBzTG9jazogZmFsc2UsXG5cdFx0c3BhY2U6IGZhbHNlXG5cdH0pLFxuXG5cdGNoYXJDb2RlTWFwID0ge30sXG5cdGtleU1hcCA9IHt9LFxuXHRkb3duQ29kZTtcblxuXHRmdW5jdGlvbiBoYW5kbGVLZXkoZG93biwga2V5Q29kZSwgY2hhckNvZGUsIGV2ZW50KSB7XG5cdFx0dmFyIGNoYXJhY3RlciA9IGNoYXJDb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkgOiAnJyxcblx0XHRcdHNwZWNpYWxLZXkgPSBzcGVjaWFsS2V5c1trZXlDb2RlXSxcblx0XHRcdGtleSA9IHNwZWNpYWxLZXkgfHwgY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCksXG5cdFx0XHR0eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsXG5cdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdHNjb3BlID0gdmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpICYmIHZpZXcuX3Njb3BlLFxuXHRcdFx0dG9vbCA9IHNjb3BlICYmIHNjb3BlLnRvb2wsXG5cdFx0XHRuYW1lO1xuXHRcdGtleU1hcFtrZXldID0gZG93bjtcblx0XHRpZiAoc3BlY2lhbEtleSAmJiAobmFtZSA9IEJhc2UuY2FtZWxpemUoc3BlY2lhbEtleSkpIGluIG1vZGlmaWVycylcblx0XHRcdG1vZGlmaWVyc1tuYW1lXSA9IGRvd247XG5cdFx0aWYgKGRvd24pIHtcblx0XHRcdGNoYXJDb2RlTWFwW2tleUNvZGVdID0gY2hhckNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBjaGFyQ29kZU1hcFtrZXlDb2RlXTtcblx0XHR9XG5cdFx0aWYgKHRvb2wgJiYgdG9vbC5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0cGFwZXIgPSBzY29wZTtcblx0XHRcdHRvb2wuZW1pdCh0eXBlLCBuZXcgS2V5RXZlbnQoZG93biwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KSk7XG5cdFx0XHRpZiAodmlldylcblx0XHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHR9XG5cdH1cblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIHtcblx0XHRrZXlkb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlO1xuXHRcdFx0aWYgKGNvZGUgaW4gc3BlY2lhbEtleXMgfHwgbW9kaWZpZXJzLmNvbW1hbmQpIHtcblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGNvZGUsXG5cdFx0XHRcdFx0XHRjb2RlIGluIHNwZWNpYWxDaGFycyB8fCBtb2RpZmllcnMuY29tbWFuZCA/IGNvZGUgOiAwLFxuXHRcdFx0XHRcdFx0ZXZlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG93bkNvZGUgPSBjb2RlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRrZXlwcmVzczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChkb3duQ29kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGhhbmRsZUtleSh0cnVlLCBkb3duQ29kZSwgZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSwgZXZlbnQpO1xuXHRcdFx0XHRkb3duQ29kZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlO1xuXHRcdFx0aWYgKGNvZGUgaW4gY2hhckNvZGVNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwgY29kZSwgY2hhckNvZGVNYXBbY29kZV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRibHVyOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Zm9yICh2YXIgY29kZSBpbiBjaGFyQ29kZU1hcClcblx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBjb2RlLCBjaGFyQ29kZU1hcFtjb2RlXSwgZXZlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRtb2RpZmllcnM6IG1vZGlmaWVycyxcblxuXHRcdGlzRG93bjogZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRyZXR1cm4gISFrZXlNYXBba2V5XTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgTW91c2VFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ01vdXNlRXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGRlbHRhKSB7XG5cdFx0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLnBvaW50ID0gcG9pbnQ7XG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0dGhpcy5kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZVxuXHRcdFx0XHQrIFwiJywgcG9pbnQ6IFwiICsgdGhpcy5wb2ludFxuXHRcdFx0XHQrICcsIHRhcmdldDogJyArIHRoaXMudGFyZ2V0XG5cdFx0XHRcdCsgKHRoaXMuZGVsdGEgPyAnLCBkZWx0YTogJyArIHRoaXMuZGVsdGEgOiAnJylcblx0XHRcdFx0KyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgJyB9Jztcblx0fVxufSk7XG5cbnZhciBUb29sRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdUb29sRXZlbnQnLFxuXHRfaXRlbTogbnVsbCxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sRXZlbnQodG9vbCwgdHlwZSwgZXZlbnQpIHtcblx0XHR0aGlzLnRvb2wgPSB0b29sO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHR9LFxuXG5cdF9jaG9vc2VQb2ludDogZnVuY3Rpb24ocG9pbnQsIHRvb2xQb2ludCkge1xuXHRcdHJldHVybiBwb2ludCA/IHBvaW50IDogdG9vbFBvaW50ID8gdG9vbFBvaW50LmNsb25lKCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fcG9pbnQsIHRoaXMudG9vbC5fcG9pbnQpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cdH0sXG5cblx0Z2V0TGFzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fbGFzdFBvaW50LCB0aGlzLnRvb2wuX2xhc3RQb2ludCk7XG5cdH0sXG5cblx0c2V0TGFzdFBvaW50OiBmdW5jdGlvbihsYXN0UG9pbnQpIHtcblx0XHR0aGlzLl9sYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG5cdH0sXG5cblx0Z2V0RG93blBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fZG93blBvaW50LCB0aGlzLnRvb2wuX2Rvd25Qb2ludCk7XG5cdH0sXG5cblx0c2V0RG93blBvaW50OiBmdW5jdGlvbihkb3duUG9pbnQpIHtcblx0XHR0aGlzLl9kb3duUG9pbnQgPSBkb3duUG9pbnQ7XG5cdH0sXG5cblx0Z2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fbWlkZGxlUG9pbnQgJiYgdGhpcy50b29sLl9sYXN0UG9pbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvb2wuX3BvaW50LmFkZCh0aGlzLnRvb2wuX2xhc3RQb2ludCkuZGl2aWRlKDIpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWlkZGxlUG9pbnQ7XG5cdH0sXG5cblx0c2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uKG1pZGRsZVBvaW50KSB7XG5cdFx0dGhpcy5fbWlkZGxlUG9pbnQgPSBtaWRkbGVQb2ludDtcblx0fSxcblxuXHRnZXREZWx0YTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9kZWx0YSAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludFxuXHRcdFx0XHQ/IHRoaXMudG9vbC5fcG9pbnQuc3VidHJhY3QodGhpcy50b29sLl9sYXN0UG9pbnQpXG5cdFx0XHRcdDogdGhpcy5fZGVsdGE7XG5cdH0sXG5cblx0c2V0RGVsdGE6IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdFx0dGhpcy5fZGVsdGEgPSBkZWx0YTtcblx0fSxcblxuXHRnZXRDb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSlcblx0XHRcdFx0PyB0aGlzLnRvb2wuX2Rvd25Db3VudFxuXHRcdFx0XHQ6IHRoaXMudG9vbC5fY291bnQ7XG5cdH0sXG5cblx0c2V0Q291bnQ6IGZ1bmN0aW9uKGNvdW50KSB7XG5cdFx0dGhpcy50b29sWy9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSkgPyAnZG93bkNvdW50JyA6ICdjb3VudCddXG5cdFx0XHQ9IGNvdW50O1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5faXRlbSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMudG9vbC5fc2NvcGUucHJvamVjdC5oaXRUZXN0KHRoaXMuZ2V0UG9pbnQoKSk7XG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdHZhciBpdGVtID0gcmVzdWx0Lml0ZW0sXG5cdFx0XHRcdFx0cGFyZW50ID0gaXRlbS5fcGFyZW50O1xuXHRcdFx0XHR3aGlsZSAoL14oR3JvdXB8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcykpIHtcblx0XHRcdFx0XHRpdGVtID0gcGFyZW50O1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faXRlbTtcblx0fSxcblxuXHRzZXRJdGVtOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAneyB0eXBlOiAnICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgJywgcG9pbnQ6ICcgKyB0aGlzLmdldFBvaW50KClcblx0XHRcdFx0KyAnLCBjb3VudDogJyArIHRoaXMuZ2V0Q291bnQoKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2wgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdUb29sJyxcblx0X2xpc3Q6ICd0b29scycsXG5cdF9yZWZlcmVuY2U6ICd0b29sJyxcblx0X2V2ZW50czogWyAnb25BY3RpdmF0ZScsICdvbkRlYWN0aXZhdGUnLCAnb25FZGl0T3B0aW9ucycsXG5cdFx0XHQnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uTW91c2VNb3ZlJyxcblx0XHRcdCdvbktleURvd24nLCAnb25LZXlVcCcgXSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sKHByb3BzKSB7XG5cdFx0UGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9maXJzdE1vdmUgPSB0cnVlO1xuXHRcdHRoaXMuX2NvdW50ID0gMDtcblx0XHR0aGlzLl9kb3duQ291bnQgPSAwO1xuXHRcdHRoaXMuX3NldChwcm9wcyk7XG5cdH0sXG5cblx0Z2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5EaXN0YW5jZTtcblx0fSxcblxuXHRzZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24obWluRGlzdGFuY2UpIHtcblx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdGlmICh0aGlzLl9taW5EaXN0YW5jZSAhPSBudWxsICYmIHRoaXMuX21heERpc3RhbmNlICE9IG51bGxcblx0XHRcdFx0JiYgdGhpcy5fbWluRGlzdGFuY2UgPiB0aGlzLl9tYXhEaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSB0aGlzLl9taW5EaXN0YW5jZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXhEaXN0YW5jZTtcblx0fSxcblxuXHRzZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcblx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdGlmICh0aGlzLl9taW5EaXN0YW5jZSAhPSBudWxsICYmIHRoaXMuX21heERpc3RhbmNlICE9IG51bGxcblx0XHRcdFx0JiYgdGhpcy5fbWF4RGlzdGFuY2UgPCB0aGlzLl9taW5EaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlID09IHRoaXMuX21heERpc3RhbmNlXG5cdFx0XHQ/IHRoaXMuX21pbkRpc3RhbmNlIDogbnVsbDtcblx0fSxcblxuXHRzZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbihkaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0fSxcblxuXHRfdXBkYXRlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UsIHN0YXJ0LFxuXHRcdFx0bmVlZHNDaGFuZ2UsIG1hdGNoTWF4RGlzdGFuY2UpIHtcblx0XHRpZiAoIXN0YXJ0KSB7XG5cdFx0XHRpZiAobWluRGlzdGFuY2UgIT0gbnVsbCB8fCBtYXhEaXN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBtaW5EaXN0ID0gbWluRGlzdGFuY2UgIT0gbnVsbCA/IG1pbkRpc3RhbmNlIDogMCxcblx0XHRcdFx0XHR2ZWN0b3IgPSBwb2ludC5zdWJ0cmFjdCh0aGlzLl9wb2ludCksXG5cdFx0XHRcdFx0ZGlzdGFuY2UgPSB2ZWN0b3IuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3QpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR2YXIgbWF4RGlzdCA9IG1heERpc3RhbmNlICE9IG51bGwgPyBtYXhEaXN0YW5jZSA6IDA7XG5cdFx0XHRcdGlmIChtYXhEaXN0ICE9IDApIHtcblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiBtYXhEaXN0KSB7XG5cdFx0XHRcdFx0XHRwb2ludCA9IHRoaXMuX3BvaW50LmFkZCh2ZWN0b3Iubm9ybWFsaXplKG1heERpc3QpKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG1hdGNoTWF4RGlzdGFuY2UpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChuZWVkc0NoYW5nZSAmJiBwb2ludC5lcXVhbHModGhpcy5fcG9pbnQpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHRoaXMuX2xhc3RQb2ludCA9IHN0YXJ0ICYmIHR5cGUgPT0gJ21vdXNlbW92ZScgPyBwb2ludCA6IHRoaXMuX3BvaW50O1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdHRoaXMuX2xhc3RQb2ludCA9IHRoaXMuX2Rvd25Qb2ludDtcblx0XHRcdHRoaXMuX2Rvd25Qb2ludCA9IHRoaXMuX3BvaW50O1xuXHRcdFx0dGhpcy5fZG93bkNvdW50Kys7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdHRoaXMuX2xhc3RQb2ludCA9IHRoaXMuX2Rvd25Qb2ludDtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR0aGlzLl9jb3VudCA9IHN0YXJ0ID8gMCA6IHRoaXMuX2NvdW50ICsgMTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBzZXRzID0gcGFwZXIucHJvamVjdC5fcmVtb3ZlU2V0cztcblx0XHRpZiAoc2V0cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXVwJylcblx0XHRcdFx0c2V0cy5tb3VzZWRyYWcgPSBudWxsO1xuXHRcdFx0dmFyIHNldCA9IHNldHNbdHlwZV07XG5cdFx0XHRpZiAoc2V0KSB7XG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHNldCkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gc2V0W2lkXTtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gc2V0cykge1xuXHRcdFx0XHRcdFx0dmFyIG90aGVyID0gc2V0c1trZXldO1xuXHRcdFx0XHRcdFx0aWYgKG90aGVyICYmIG90aGVyICE9IHNldClcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIG90aGVyW2l0ZW0uX2lkXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRzW3R5cGVdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucmVzcG9uZHModHlwZSlcblx0XHRcdFx0JiYgdGhpcy5lbWl0KHR5cGUsIG5ldyBUb29sRXZlbnQodGhpcywgdHlwZSwgZXZlbnQpKTtcblx0fSxcblxuXHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBldmVudCkge1xuXHRcdHBhcGVyID0gdGhpcy5fc2NvcGU7XG5cdFx0dmFyIGNhbGxlZCA9IGZhbHNlO1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgbnVsbCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZWRyYWcnOlxuXHRcdFx0dmFyIG5lZWRzQ2hhbmdlID0gZmFsc2UsXG5cdFx0XHRcdG1hdGNoTWF4RGlzdGFuY2UgPSBmYWxzZTtcblx0XHRcdHdoaWxlICh0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCBmYWxzZSwgbmVlZHNDaGFuZ2UsIG1hdGNoTWF4RGlzdGFuY2UpKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0XHRuZWVkc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdG1hdGNoTWF4RGlzdGFuY2UgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRpZiAoIXBvaW50LmVxdWFscyh0aGlzLl9wb2ludClcblx0XHRcdFx0XHQmJiB0aGlzLl91cGRhdGVFdmVudCgnbW91c2VkcmFnJywgcG9pbnQsIHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCgnbW91c2VkcmFnJywgZXZlbnQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLFxuXHRcdFx0XHRcdGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fZmlyc3RNb3ZlID0gdHJ1ZTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHR3aGlsZSAodGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgdGhpcy5fZmlyc3RNb3ZlLCB0cnVlLCBmYWxzZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0TW92ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmIChjYWxsZWQpXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHJldHVybiBjYWxsZWQ7XG5cdH1cblxufSk7XG5cbnZhciBIdHRwID0ge1xuXHRyZXF1ZXN0OiBmdW5jdGlvbihtZXRob2QsIHVybCwgY2FsbGJhY2spIHtcblx0XHR2YXIgeGhyID0gbmV3ICh3aW5kb3cuQWN0aXZlWE9iamVjdCB8fCBYTUxIdHRwUmVxdWVzdCkoXG5cdFx0XHRcdFx0J01pY3Jvc29mdC5YTUxIVFRQJyk7XG5cdFx0eGhyLm9wZW4obWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCwgdHJ1ZSk7XG5cdFx0aWYgKCdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1cztcblx0XHRcdFx0aWYgKHN0YXR1cyA9PT0gMCB8fCBzdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoeGhyLCB4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkICcgKyB1cmwgKyAnIChFcnJvciAnXG5cdFx0XHRcdFx0XHRcdCsgc3RhdHVzICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIHhoci5zZW5kKG51bGwpO1xuXHR9XG59O1xuXG52YXIgQ2FudmFzUHJvdmlkZXIgPSB7XG5cdGNhbnZhc2VzOiBbXSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgY2FudmFzLFxuXHRcdFx0Y2xlYXIgPSB0cnVlO1xuXHRcdGlmICh0eXBlb2Ygd2lkdGggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRoZWlnaHQgPSB3aWR0aC5oZWlnaHQ7XG5cdFx0XHR3aWR0aCA9IHdpZHRoLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoIG5vQ2FudmFzICkge1xuXHRcdFx0cmV0dXJuIHsgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7fSB9O1xuXHRcdH1cblx0XHRpZiAodGhpcy5jYW52YXNlcy5sZW5ndGgpIHtcblx0XHRcdGNhbnZhcyA9IHRoaXMuY2FudmFzZXMucG9wKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdH1cblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0aWYgKGNhbnZhcy53aWR0aCA9PT0gd2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG5cdFx0XHRpZiAoY2xlYXIpXG5cdFx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGggKyAxLCBoZWlnaHQgKyAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHJldHVybiBjYW52YXM7XG5cdH0sXG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHJldHVybiB0aGlzLmdldENhbnZhcyh3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdHJlbGVhc2U6IGZ1bmN0aW9uKG9iaikge1xuXHRcdHZhciBjYW52YXMgPSBvYmouY2FudmFzID8gb2JqLmNhbnZhcyA6IG9iajtcblx0XHRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5yZXN0b3JlKCk7XG5cdFx0dGhpcy5jYW52YXNlcy5wdXNoKGNhbnZhcyk7XG5cdH1cbn07XG5cbnZhciBCbGVuZE1vZGUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdGlmICggbm9DYW52YXMgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdHNyLCBzZywgc2IsIHNhLFxuXHRcdGJyLCBiZywgYmIsIGJhLFxuXHRcdGRyLCBkZywgZGI7XG5cblx0ZnVuY3Rpb24gZ2V0THVtKHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gMC4yOTg5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYjtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEx1bShyLCBnLCBiLCBsKSB7XG5cdFx0dmFyIGQgPSBsIC0gZ2V0THVtKHIsIGcsIGIpO1xuXHRcdGRyID0gciArIGQ7XG5cdFx0ZGcgPSBnICsgZDtcblx0XHRkYiA9IGIgKyBkO1xuXHRcdHZhciBsID0gZ2V0THVtKGRyLCBkZywgZGIpLFxuXHRcdFx0bW4gPSBtaW4oZHIsIGRnLCBkYiksXG5cdFx0XHRteCA9IG1heChkciwgZGcsIGRiKTtcblx0XHRpZiAobW4gPCAwKSB7XG5cdFx0XHR2YXIgbG1uID0gbCAtIG1uO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsIC8gbG1uO1xuXHRcdH1cblx0XHRpZiAobXggPiAyNTUpIHtcblx0XHRcdHZhciBsbiA9IDI1NSAtIGwsXG5cdFx0XHRcdG14bCA9IG14IC0gbDtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsbiAvIG14bDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTYXQociwgZywgYikge1xuXHRcdHJldHVybiBtYXgociwgZywgYikgLSBtaW4ociwgZywgYik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTYXQociwgZywgYiwgcykge1xuXHRcdHZhciBjb2wgPSBbciwgZywgYl0sXG5cdFx0XHRteCA9IG1heChyLCBnLCBiKSxcblx0XHRcdG1uID0gbWluKHIsIGcsIGIpLFxuXHRcdFx0bWQ7XG5cdFx0bW4gPSBtbiA9PT0gciA/IDAgOiBtbiA9PT0gZyA/IDEgOiAyO1xuXHRcdG14ID0gbXggPT09IHIgPyAwIDogbXggPT09IGcgPyAxIDogMjtcblx0XHRtZCA9IG1pbihtbiwgbXgpID09PSAwID8gbWF4KG1uLCBteCkgPT09IDEgPyAyIDogMSA6IDA7XG5cdFx0aWYgKGNvbFtteF0gPiBjb2xbbW5dKSB7XG5cdFx0XHRjb2xbbWRdID0gKGNvbFttZF0gLSBjb2xbbW5dKSAqIHMgLyAoY29sW214XSAtIGNvbFttbl0pO1xuXHRcdFx0Y29sW214XSA9IHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbFttZF0gPSBjb2xbbXhdID0gMDtcblx0XHR9XG5cdFx0Y29sW21uXSA9IDA7XG5cdFx0ZHIgPSBjb2xbMF07XG5cdFx0ZGcgPSBjb2xbMV07XG5cdFx0ZGIgPSBjb2xbMl07XG5cdH1cblxuXHR2YXIgbW9kZXMgPSB7XG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAqIHNyIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyAqIHNnIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiAqIHNiIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyIC0gKGJyICogc3IgLyAyNTUpO1xuXHRcdFx0ZGcgPSBiZyArIHNnIC0gKGJnICogc2cgLyAyNTUpO1xuXHRcdFx0ZGIgPSBiYiArIHNiIC0gKGJiICogc2IgLyAyNTUpO1xuXHRcdH0sXG5cblx0XHRvdmVybGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCAxMjggPyAyICogYnIgKiBzciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgPCAxMjggPyAyICogYmcgKiBzZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgPCAxMjggPyAyICogYmIgKiBzYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J3NvZnQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0ID0gc3IgKiBiciAvIDI1NTtcblx0XHRcdGRyID0gdCArIGJyICogKDI1NSAtICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2cgKiBiZyAvIDI1NTtcblx0XHRcdGRnID0gdCArIGJnICogKDI1NSAtICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2IgKiBiYiAvIDI1NTtcblx0XHRcdGRiID0gdCArIGJiICogKDI1NSAtICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdoYXJkLWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IHNyIDwgMTI4ID8gMiAqIHNyICogYnIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNyKSAqICgyNTUgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IHNnIDwgMTI4ID8gMiAqIHNnICogYmcgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNnKSAqICgyNTUgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IHNiIDwgMTI4ID8gMiAqIHNiICogYmIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNiKSAqICgyNTUgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1kb2RnZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMCA/IDAgOiBzciA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYnIgLyAoMjU1IC0gc3IpKTtcblx0XHRcdGRnID0gYmcgPT09IDAgPyAwIDogc2cgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJnIC8gKDI1NSAtIHNnKSk7XG5cdFx0XHRkYiA9IGJiID09PSAwID8gMCA6IHNiID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiYiAvICgyNTUgLSBzYikpO1xuXHRcdH0sXG5cblx0XHQnY29sb3ItYnVybic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMjU1ID8gMjU1IDogc3IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBicikgKiAyNTUgLyBzcik7XG5cdFx0XHRkZyA9IGJnID09PSAyNTUgPyAyNTUgOiBzZyA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJnKSAqIDI1NSAvIHNnKTtcblx0XHRcdGRiID0gYmIgPT09IDI1NSA/IDI1NSA6IHNiID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmIpICogMjU1IC8gc2IpO1xuXHRcdH0sXG5cblx0XHRkYXJrZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPCBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiIDwgc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRsaWdodGVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPiBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnID4gc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA+IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0ZGlmZmVyZW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIC0gc3I7XG5cdFx0XHRpZiAoZHIgPCAwKVxuXHRcdFx0XHRkciA9IC1kcjtcblx0XHRcdGRnID0gYmcgLSBzZztcblx0XHRcdGlmIChkZyA8IDApXG5cdFx0XHRcdGRnID0gLWRnO1xuXHRcdFx0ZGIgPSBiYiAtIHNiO1xuXHRcdFx0aWYgKGRiIDwgMClcblx0XHRcdFx0ZGIgPSAtZGI7XG5cdFx0fSxcblxuXHRcdGV4Y2x1c2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgKiAoMjU1IC0gYnIgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICsgc2cgKiAoMjU1IC0gYmcgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICsgc2IgKiAoMjU1IC0gYmIgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdGh1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoc3IsIHNnLCBzYiwgZ2V0U2F0KGJyLCBiZywgYmIpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRzYXR1cmF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChiciwgYmcsIGJiLCBnZXRTYXQoc3IsIHNnLCBzYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGx1bWlub3NpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKGJyLCBiZywgYmIsIGdldEx1bShzciwgc2csIHNiKSk7XG5cdFx0fSxcblxuXHRcdGNvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShzciwgc2csIHNiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtaW4oYnIgKyBzciwgMjU1KTtcblx0XHRcdGRnID0gbWluKGJnICsgc2csIDI1NSk7XG5cdFx0XHRkYiA9IG1pbihiYiArIHNiLCAyNTUpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1heChiciAtIHNyLCAwKTtcblx0XHRcdGRnID0gbWF4KGJnIC0gc2csIDApO1xuXHRcdFx0ZGIgPSBtYXgoYmIgLSBzYiwgMCk7XG5cdFx0fSxcblxuXHRcdGF2ZXJhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAoYnIgKyBzcikgLyAyO1xuXHRcdFx0ZGcgPSAoYmcgKyBzZykgLyAyO1xuXHRcdFx0ZGIgPSAoYmIgKyBzYikgLyAyO1xuXHRcdH0sXG5cblx0XHRuZWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IDI1NSAtIGFicygyNTUgLSBzciAtIGJyKTtcblx0XHRcdGRnID0gMjU1IC0gYWJzKDI1NSAtIHNnIC0gYmcpO1xuXHRcdFx0ZGIgPSAyNTUgLSBhYnMoMjU1IC0gc2IgLSBiYik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBuYXRpdmVNb2RlcyA9IHRoaXMubmF0aXZlTW9kZXMgPSBCYXNlLmVhY2goW1xuXHRcdCdzb3VyY2Utb3ZlcicsICdzb3VyY2UtaW4nLCAnc291cmNlLW91dCcsICdzb3VyY2UtYXRvcCcsXG5cdFx0J2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24taW4nLCAnZGVzdGluYXRpb24tb3V0Jyxcblx0XHQnZGVzdGluYXRpb24tYXRvcCcsICdsaWdodGVyJywgJ2RhcmtlcicsICdjb3B5JywgJ3hvcidcblx0XSwgZnVuY3Rpb24obW9kZSkge1xuXHRcdHRoaXNbbW9kZV0gPSB0cnVlO1xuXHR9LCB7fSk7XG5cblx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdEJhc2UuZWFjaChtb2RlcywgZnVuY3Rpb24oZnVuYywgbW9kZSkge1xuXHRcdHZhciBkYXJrZW4gPSBtb2RlID09PSAnZGFya2VuJyxcblx0XHRcdG9rID0gZmFsc2U7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR0cnkge1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjMzAwJyA6ICcjYTAwJztcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0aWYgKGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPT09IG1vZGUpIHtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjYTAwJyA6ICcjMzAwJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHRvayA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVswXSAhPT0gZGFya2VuID8gMTcwIDogNTE7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG5hdGl2ZU1vZGVzW21vZGVdID0gb2s7XG5cdH0pO1xuXHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cblx0dGhpcy5wcm9jZXNzID0gZnVuY3Rpb24obW9kZSwgc3JjQ29udGV4dCwgZHN0Q29udGV4dCwgYWxwaGEsIG9mZnNldCkge1xuXHRcdHZhciBzcmNDYW52YXMgPSBzcmNDb250ZXh0LmNhbnZhcyxcblx0XHRcdG5vcm1hbCA9IG1vZGUgPT09ICdub3JtYWwnO1xuXHRcdGlmIChub3JtYWwgfHwgbmF0aXZlTW9kZXNbbW9kZV0pIHtcblx0XHRcdGRzdENvbnRleHQuc2F2ZSgpO1xuXHRcdFx0ZHN0Q29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHRkc3RDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdFx0XHRpZiAoIW5vcm1hbClcblx0XHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0ZHN0Q29udGV4dC5kcmF3SW1hZ2Uoc3JjQ2FudmFzLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXHRcdFx0ZHN0Q29udGV4dC5yZXN0b3JlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwcm9jZXNzID0gbW9kZXNbbW9kZV07XG5cdFx0XHRpZiAoIXByb2Nlc3MpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBkc3REYXRhID0gZHN0Q29udGV4dC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LFxuXHRcdFx0XHRcdHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCksXG5cdFx0XHRcdGRzdCA9IGRzdERhdGEuZGF0YSxcblx0XHRcdFx0c3JjID0gc3JjQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLmRhdGE7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGRzdC5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcblx0XHRcdFx0c3IgPSBzcmNbaV07XG5cdFx0XHRcdGJyID0gZHN0W2ldO1xuXHRcdFx0XHRzZyA9IHNyY1tpICsgMV07XG5cdFx0XHRcdGJnID0gZHN0W2kgKyAxXTtcblx0XHRcdFx0c2IgPSBzcmNbaSArIDJdO1xuXHRcdFx0XHRiYiA9IGRzdFtpICsgMl07XG5cdFx0XHRcdHNhID0gc3JjW2kgKyAzXTtcblx0XHRcdFx0YmEgPSBkc3RbaSArIDNdO1xuXHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdHZhciBhMSA9IHNhICogYWxwaGEgLyAyNTUsXG5cdFx0XHRcdFx0YTIgPSAxIC0gYTE7XG5cdFx0XHRcdGRzdFtpXSA9IGExICogZHIgKyBhMiAqIGJyO1xuXHRcdFx0XHRkc3RbaSArIDFdID0gYTEgKiBkZyArIGEyICogYmc7XG5cdFx0XHRcdGRzdFtpICsgMl0gPSBhMSAqIGRiICsgYTIgKiBiYjtcblx0XHRcdFx0ZHN0W2kgKyAzXSA9IHNhICogYWxwaGEgKyBhMiAqIGJhO1xuXHRcdFx0fVxuXHRcdFx0ZHN0Q29udGV4dC5wdXRJbWFnZURhdGEoZHN0RGF0YSwgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgU1ZHU3R5bGVzID0gQmFzZS5lYWNoKHtcblx0ZmlsbENvbG9yOiBbJ2ZpbGwnLCAnY29sb3InXSxcblx0c3Ryb2tlQ29sb3I6IFsnc3Ryb2tlJywgJ2NvbG9yJ10sXG5cdHN0cm9rZVdpZHRoOiBbJ3N0cm9rZS13aWR0aCcsICdudW1iZXInXSxcblx0c3Ryb2tlQ2FwOiBbJ3N0cm9rZS1saW5lY2FwJywgJ3N0cmluZyddLFxuXHRzdHJva2VKb2luOiBbJ3N0cm9rZS1saW5lam9pbicsICdzdHJpbmcnXSxcblx0c3Ryb2tlU2NhbGluZzogWyd2ZWN0b3ItZWZmZWN0JywgJ2xvb2t1cCcsIHtcblx0XHR0cnVlOiAnbm9uZScsXG5cdFx0ZmFsc2U6ICdub24tc2NhbGluZy1zdHJva2UnXG5cdH0sIGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0cmV0dXJuICF2YWx1ZVxuXHRcdFx0XHQmJiAoaXRlbSBpbnN0YW5jZW9mIFBhdGhJdGVtXG5cdFx0XHRcdFx0fHwgaXRlbSBpbnN0YW5jZW9mIFNoYXBlXG5cdFx0XHRcdFx0fHwgaXRlbSBpbnN0YW5jZW9mIFRleHRJdGVtKTtcblx0fV0sXG5cdG1pdGVyTGltaXQ6IFsnc3Ryb2tlLW1pdGVybGltaXQnLCAnbnVtYmVyJ10sXG5cdGRhc2hBcnJheTogWydzdHJva2UtZGFzaGFycmF5JywgJ2FycmF5J10sXG5cdGRhc2hPZmZzZXQ6IFsnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnbnVtYmVyJ10sXG5cdGZvbnRGYW1pbHk6IFsnZm9udC1mYW1pbHknLCAnc3RyaW5nJ10sXG5cdGZvbnRXZWlnaHQ6IFsnZm9udC13ZWlnaHQnLCAnc3RyaW5nJ10sXG5cdGZvbnRTaXplOiBbJ2ZvbnQtc2l6ZScsICdudW1iZXInXSxcblx0anVzdGlmaWNhdGlvbjogWyd0ZXh0LWFuY2hvcicsICdsb29rdXAnLCB7XG5cdFx0bGVmdDogJ3N0YXJ0Jyxcblx0XHRjZW50ZXI6ICdtaWRkbGUnLFxuXHRcdHJpZ2h0OiAnZW5kJ1xuXHR9XSxcblx0b3BhY2l0eTogWydvcGFjaXR5JywgJ251bWJlciddLFxuXHRibGVuZE1vZGU6IFsnbWl4LWJsZW5kLW1vZGUnLCAnc3RyaW5nJ11cbn0sIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRsb29rdXAgPSBlbnRyeVsyXTtcblx0dGhpc1trZXldID0ge1xuXHRcdHR5cGU6IGVudHJ5WzFdLFxuXHRcdHByb3BlcnR5OiBrZXksXG5cdFx0YXR0cmlidXRlOiBlbnRyeVswXSxcblx0XHR0b1NWRzogbG9va3VwLFxuXHRcdGZyb21TVkc6IGxvb2t1cCAmJiBCYXNlLmVhY2gobG9va3VwLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0dGhpc1t2YWx1ZV0gPSBuYW1lO1xuXHRcdH0sIHt9KSxcblx0XHRleHBvcnRGaWx0ZXI6IGVudHJ5WzNdLFxuXHRcdGdldDogJ2dldCcgKyBwYXJ0LFxuXHRcdHNldDogJ3NldCcgKyBwYXJ0XG5cdH07XG59LCB7fSk7XG5cbnZhciBTVkdOYW1lc3BhY2VzID0ge1xuXHRocmVmOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cdHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucydcbn07XG5cbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGZvcm1hdHRlcjtcblxuXHRmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHR2YXIgdmFsID0gYXR0cnNba2V5XSxcblx0XHRcdFx0bmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1trZXldO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuXHRcdFx0XHR2YWwgPSBmb3JtYXR0ZXIubnVtYmVyKHZhbCk7XG5cdFx0XHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBrZXksIHZhbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSB7XG5cdFx0cmV0dXJuIHNldEF0dHJpYnV0ZXMoXG5cdFx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnKSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKG1hdHJpeCwgY29vcmRpbmF0ZXMsIGNlbnRlcikge1xuXHRcdHZhciBhdHRycyA9IG5ldyBCYXNlKCksXG5cdFx0XHR0cmFucyA9IG1hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXHRcdGlmIChjb29yZGluYXRlcykge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4LnNoaWZ0bGVzcygpO1xuXHRcdFx0dmFyIHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRyYW5zKTtcblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeCcgOiAneCddID0gcG9pbnQueDtcblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeScgOiAneSddID0gcG9pbnQueTtcblx0XHRcdHRyYW5zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRcdGlmIChkZWNvbXBvc2VkICYmICFkZWNvbXBvc2VkLnNoZWFyaW5nKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0XHRcdGFuZ2xlID0gZGVjb21wb3NlZC5yb3RhdGlvbixcblx0XHRcdFx0XHRzY2FsZSA9IGRlY29tcG9zZWQuc2NhbGluZztcblx0XHRcdFx0aWYgKHRyYW5zICYmICF0cmFucy5pc1plcm8oKSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCd0cmFuc2xhdGUoJyArIGZvcm1hdHRlci5wb2ludCh0cmFucykgKyAnKScpO1xuXHRcdFx0XHRpZiAoYW5nbGUpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgncm90YXRlKCcgKyBmb3JtYXR0ZXIubnVtYmVyKGFuZ2xlKSArICcpJyk7XG5cdFx0XHRcdGlmICghTnVtZXJpY2FsLmlzWmVybyhzY2FsZS54IC0gMSlcblx0XHRcdFx0XHRcdHx8ICFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnkgLSAxKSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdzY2FsZSgnICsgZm9ybWF0dGVyLnBvaW50KHNjYWxlKSArJyknKTtcblx0XHRcdFx0YXR0cnMudHJhbnNmb3JtID0gcGFydHMuam9pbignICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMudHJhbnNmb3JtID0gJ21hdHJpeCgnICsgbWF0cml4LmdldFZhbHVlcygpLmpvaW4oJywnKSArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGF0dHJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0R3JvdXAoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpLFxuXHRcdFx0Y2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbjtcblx0XHR2YXIgbm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ2cnLCBhdHRycyk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IGV4cG9ydFNWRyhjaGlsZCwgb3B0aW9ucyk7XG5cdFx0XHRpZiAoY2hpbGROb2RlKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5pc0NsaXBNYXNrKCkpIHtcblx0XHRcdFx0XHR2YXIgY2xpcCA9IGNyZWF0ZUVsZW1lbnQoJ2NsaXBQYXRoJyk7XG5cdFx0XHRcdFx0Y2xpcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHRcdHNldERlZmluaXRpb24oY2hpbGQsIGNsaXAsICdjbGlwJyk7XG5cdFx0XHRcdFx0c2V0QXR0cmlidXRlcyhub2RlLCB7XG5cdFx0XHRcdFx0XHQnY2xpcC1wYXRoJzogJ3VybCgjJyArIGNsaXAuaWQgKyAnKSdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRSYXN0ZXIoaXRlbSkge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLFxuXHRcdFx0c2l6ZSA9IGl0ZW0uZ2V0U2l6ZSgpO1xuXHRcdGF0dHJzLnggLT0gc2l6ZS53aWR0aCAvIDI7XG5cdFx0YXR0cnMueSAtPSBzaXplLmhlaWdodCAvIDI7XG5cdFx0YXR0cnMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGF0dHJzLmhyZWYgPSBpdGVtLnRvRGF0YVVSTCgpO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCdpbWFnZScsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zLm1hdGNoU2hhcGVzKSB7XG5cdFx0XHR2YXIgc2hhcGUgPSBpdGVtLnRvU2hhcGUoZmFsc2UpO1xuXHRcdFx0aWYgKHNoYXBlKVxuXHRcdFx0XHRyZXR1cm4gZXhwb3J0U2hhcGUoc2hhcGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHR2YXIgc2VnbWVudHMgPSBpdGVtLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXHRcdGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRpZiAoaXRlbS5pc1BvbHlnb24oKSkge1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA+PSAzKSB7XG5cdFx0XHRcdHR5cGUgPSBpdGVtLl9jbG9zZWQgPyAncG9seWdvbicgOiAncG9seWxpbmUnO1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goZm9ybWF0dGVyLnBvaW50KHNlZ21lbnRzW2ldLl9wb2ludCkpO1xuXHRcdFx0XHRhdHRycy5wb2ludHMgPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gJ2xpbmUnO1xuXHRcdFx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXS5fcG9pbnQsXG5cdFx0XHRcdFx0bGFzdCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludDtcblx0XHRcdFx0YXR0cnMuc2V0KHtcblx0XHRcdFx0XHR4MTogZmlyc3QueCxcblx0XHRcdFx0XHR5MTogZmlyc3QueSxcblx0XHRcdFx0XHR4MjogbGFzdC54LFxuXHRcdFx0XHRcdHkyOiBsYXN0Lnlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHR5cGUgPSAncGF0aCc7XG5cdFx0XHRhdHRycy5kID0gaXRlbS5nZXRQYXRoRGF0YShudWxsLCBvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KHR5cGUsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFNoYXBlKGl0ZW0pIHtcblx0XHR2YXIgdHlwZSA9IGl0ZW0uX3R5cGUsXG5cdFx0XHRyYWRpdXMgPSBpdGVtLl9yYWRpdXMsXG5cdFx0XHRhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUsIHR5cGUgIT09ICdyZWN0YW5nbGUnKTtcblx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdHR5cGUgPSAncmVjdCc7XG5cdFx0XHR2YXIgc2l6ZSA9IGl0ZW0uX3NpemUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRhdHRycy54IC09IHdpZHRoIC8gMjtcblx0XHRcdGF0dHJzLnkgLT0gaGVpZ2h0IC8gMjtcblx0XHRcdGF0dHJzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRhdHRycy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRyYWRpdXMgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0YXR0cnMuciA9IHJhZGl1cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzLnJ4ID0gcmFkaXVzLndpZHRoO1xuXHRcdFx0XHRhdHRycy5yeSA9IHJhZGl1cy5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KHR5cGUsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydENvbXBvdW5kUGF0aChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCk7XG5cdFx0dmFyIGRhdGEgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRpZiAoZGF0YSlcblx0XHRcdGF0dHJzLmQgPSBkYXRhO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCdwYXRoJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UGxhY2VkU3ltYm9sKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdHN5bWJvbCA9IGl0ZW0uZ2V0U3ltYm9sKCksXG5cdFx0XHRzeW1ib2xOb2RlID0gZ2V0RGVmaW5pdGlvbihzeW1ib2wsICdzeW1ib2wnKSxcblx0XHRcdGRlZmluaXRpb24gPSBzeW1ib2wuZ2V0RGVmaW5pdGlvbigpLFxuXHRcdFx0Ym91bmRzID0gZGVmaW5pdGlvbi5nZXRCb3VuZHMoKTtcblx0XHRpZiAoIXN5bWJvbE5vZGUpIHtcblx0XHRcdHN5bWJvbE5vZGUgPSBjcmVhdGVFbGVtZW50KCdzeW1ib2wnLCB7XG5cdFx0XHRcdHZpZXdCb3g6IGZvcm1hdHRlci5yZWN0YW5nbGUoYm91bmRzKVxuXHRcdFx0fSk7XG5cdFx0XHRzeW1ib2xOb2RlLmFwcGVuZENoaWxkKGV4cG9ydFNWRyhkZWZpbml0aW9uLCBvcHRpb25zKSk7XG5cdFx0XHRzZXREZWZpbml0aW9uKHN5bWJvbCwgc3ltYm9sTm9kZSwgJ3N5bWJvbCcpO1xuXHRcdH1cblx0XHRhdHRycy5ocmVmID0gJyMnICsgc3ltYm9sTm9kZS5pZDtcblx0XHRhdHRycy54ICs9IGJvdW5kcy54O1xuXHRcdGF0dHJzLnkgKz0gYm91bmRzLnk7XG5cdFx0YXR0cnMud2lkdGggPSBmb3JtYXR0ZXIubnVtYmVyKGJvdW5kcy53aWR0aCk7XG5cdFx0YXR0cnMuaGVpZ2h0ID0gZm9ybWF0dGVyLm51bWJlcihib3VuZHMuaGVpZ2h0KTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgndXNlJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0R3JhZGllbnQoY29sb3IpIHtcblx0XHR2YXIgZ3JhZGllbnROb2RlID0gZ2V0RGVmaW5pdGlvbihjb2xvciwgJ2NvbG9yJyk7XG5cdFx0aWYgKCFncmFkaWVudE5vZGUpIHtcblx0XHRcdHZhciBncmFkaWVudCA9IGNvbG9yLmdldEdyYWRpZW50KCksXG5cdFx0XHRcdHJhZGlhbCA9IGdyYWRpZW50Ll9yYWRpYWwsXG5cdFx0XHRcdG9yaWdpbiA9IGNvbG9yLmdldE9yaWdpbigpLnRyYW5zZm9ybSgpLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbG9yLmdldERlc3RpbmF0aW9uKCkudHJhbnNmb3JtKCksXG5cdFx0XHRcdGF0dHJzO1xuXHRcdFx0aWYgKHJhZGlhbCkge1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHRjeDogb3JpZ2luLngsXG5cdFx0XHRcdFx0Y3k6IG9yaWdpbi55LFxuXHRcdFx0XHRcdHI6IG9yaWdpbi5nZXREaXN0YW5jZShkZXN0aW5hdGlvbilcblx0XHRcdFx0fTtcblx0XHRcdFx0dmFyIGhpZ2hsaWdodCA9IGNvbG9yLmdldEhpZ2hsaWdodCgpO1xuXHRcdFx0XHRpZiAoaGlnaGxpZ2h0KSB7XG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gaGlnaGxpZ2h0LnRyYW5zZm9ybSgpO1xuXHRcdFx0XHRcdGF0dHJzLmZ4ID0gaGlnaGxpZ2h0Lng7XG5cdFx0XHRcdFx0YXR0cnMuZnkgPSBoaWdobGlnaHQueTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0eDE6IG9yaWdpbi54LFxuXHRcdFx0XHRcdHkxOiBvcmlnaW4ueSxcblx0XHRcdFx0XHR4MjogZGVzdGluYXRpb24ueCxcblx0XHRcdFx0XHR5MjogZGVzdGluYXRpb24ueVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0YXR0cnMuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG5cdFx0XHRncmFkaWVudE5vZGUgPSBjcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdChyYWRpYWwgPyAncmFkaWFsJyA6ICdsaW5lYXInKSArICdHcmFkaWVudCcsIGF0dHJzKTtcblx0XHRcdHZhciBzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gc3RvcHNbaV0sXG5cdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcC5fY29sb3IsXG5cdFx0XHRcdFx0YWxwaGEgPSBzdG9wQ29sb3IuZ2V0QWxwaGEoKTtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0b2Zmc2V0OiBzdG9wLl9yYW1wUG9pbnQsXG5cdFx0XHRcdFx0J3N0b3AtY29sb3InOiBzdG9wQ29sb3IudG9DU1ModHJ1ZSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRhdHRyc1snc3RvcC1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0Z3JhZGllbnROb2RlLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3N0b3AnLCBhdHRycykpO1xuXHRcdFx0fVxuXHRcdFx0c2V0RGVmaW5pdGlvbihjb2xvciwgZ3JhZGllbnROb2RlLCAnY29sb3InKTtcblx0XHR9XG5cdFx0cmV0dXJuICd1cmwoIycgKyBncmFkaWVudE5vZGUuaWQgKyAnKSc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRUZXh0KGl0ZW0pIHtcblx0XHR2YXIgbm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3RleHQnLCBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSk7XG5cdFx0bm9kZS50ZXh0Q29udGVudCA9IGl0ZW0uX2NvbnRlbnQ7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHR2YXIgZXhwb3J0ZXJzID0ge1xuXHRcdEdyb3VwOiBleHBvcnRHcm91cCxcblx0XHRMYXllcjogZXhwb3J0R3JvdXAsXG5cdFx0UmFzdGVyOiBleHBvcnRSYXN0ZXIsXG5cdFx0UGF0aDogZXhwb3J0UGF0aCxcblx0XHRTaGFwZTogZXhwb3J0U2hhcGUsXG5cdFx0Q29tcG91bmRQYXRoOiBleHBvcnRDb21wb3VuZFBhdGgsXG5cdFx0UGxhY2VkU3ltYm9sOiBleHBvcnRQbGFjZWRTeW1ib2wsXG5cdFx0UG9pbnRUZXh0OiBleHBvcnRUZXh0XG5cdH07XG5cblx0ZnVuY3Rpb24gYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpIHtcblx0XHR2YXIgYXR0cnMgPSB7fSxcblx0XHRcdHBhcmVudCA9ICFpc1Jvb3QgJiYgaXRlbS5nZXRQYXJlbnQoKTtcblxuXHRcdGlmIChpdGVtLl9uYW1lICE9IG51bGwpXG5cdFx0XHRhdHRycy5pZCA9IGl0ZW0uX25hbWU7XG5cblx0XHRCYXNlLmVhY2goU1ZHU3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuXHRcdFx0dmFyIGdldCA9IGVudHJ5LmdldCxcblx0XHRcdFx0dHlwZSA9IGVudHJ5LnR5cGUsXG5cdFx0XHRcdHZhbHVlID0gaXRlbVtnZXRdKCk7XG5cdFx0XHRpZiAoZW50cnkuZXhwb3J0RmlsdGVyXG5cdFx0XHRcdFx0PyBlbnRyeS5leHBvcnRGaWx0ZXIoaXRlbSwgdmFsdWUpXG5cdFx0XHRcdFx0OiAhcGFyZW50IHx8ICFCYXNlLmVxdWFscyhwYXJlbnRbZ2V0XSgpLCB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjb2xvcicgJiYgdmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciBhbHBoYSA9IHZhbHVlLmdldEFscGhhKCk7XG5cdFx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRcdGF0dHJzW2VudHJ5LmF0dHJpYnV0ZSArICctb3BhY2l0eSddID0gYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlXSA9IHZhbHVlID09IG51bGxcblx0XHRcdFx0XHQ/ICdub25lJ1xuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdD8gZm9ybWF0dGVyLm51bWJlcih2YWx1ZSlcblx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2NvbG9yJ1xuXHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmdyYWRpZW50XG5cdFx0XHRcdFx0XHRcdFx0PyBleHBvcnRHcmFkaWVudCh2YWx1ZSwgaXRlbSlcblx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlLnRvQ1NTKHRydWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2FycmF5J1xuXHRcdFx0XHRcdFx0XHRcdD8gdmFsdWUuam9pbignLCcpXG5cdFx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyBlbnRyeS50b1NWR1t2YWx1ZV1cblx0XHRcdFx0XHRcdFx0XHRcdDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoYXR0cnMub3BhY2l0eSA9PT0gMSlcblx0XHRcdGRlbGV0ZSBhdHRycy5vcGFjaXR5O1xuXG5cdFx0aWYgKCFpdGVtLl92aXNpYmxlKVxuXHRcdFx0YXR0cnMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG5cdFx0cmV0dXJuIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zO1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0sIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7IGlkczoge30sIHN2Z3M6IHt9IH07XG5cdFx0cmV0dXJuIGl0ZW0gJiYgZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgaXRlbS5faWRdO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0RGVmaW5pdGlvbihpdGVtLCBub2RlLCB0eXBlKSB7XG5cdFx0aWYgKCFkZWZpbml0aW9ucylcblx0XHRcdGdldERlZmluaXRpb24oKTtcblx0XHR2YXIgaWQgPSBkZWZpbml0aW9ucy5pZHNbdHlwZV0gPSAoZGVmaW5pdGlvbnMuaWRzW3R5cGVdIHx8IDApICsgMTtcblx0XHRub2RlLmlkID0gdHlwZSArICctJyArIGlkO1xuXHRcdGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJyArIGl0ZW0uX2lkXSA9IG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHN2ZyA9IG5vZGUsXG5cdFx0XHRkZWZzID0gbnVsbDtcblx0XHRpZiAoZGVmaW5pdGlvbnMpIHtcblx0XHRcdHN2ZyA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycgJiYgbm9kZTtcblx0XHRcdGZvciAodmFyIGkgaW4gZGVmaW5pdGlvbnMuc3Zncykge1xuXHRcdFx0XHRpZiAoIWRlZnMpIHtcblx0XHRcdFx0XHRpZiAoIXN2Zykge1xuXHRcdFx0XHRcdFx0c3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG5cdFx0XHRcdFx0XHRzdmcuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZnMgPSBzdmcuaW5zZXJ0QmVmb3JlKGNyZWF0ZUVsZW1lbnQoJ2RlZnMnKSxcblx0XHRcdFx0XHRcdFx0c3ZnLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZnMuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMuc3Znc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbml0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zLmFzU3RyaW5nXG5cdFx0XHRcdD8gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpXG5cdFx0XHRcdDogc3ZnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U1ZHKGl0ZW0sIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdHZhciBleHBvcnRlciA9IGV4cG9ydGVyc1tpdGVtLl9jbGFzc10sXG5cdFx0XHRub2RlID0gZXhwb3J0ZXIgJiYgZXhwb3J0ZXIoaXRlbSwgb3B0aW9ucyk7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdHZhciBvbkV4cG9ydCA9IG9wdGlvbnMub25FeHBvcnQ7XG5cdFx0XHRpZiAob25FeHBvcnQpXG5cdFx0XHRcdG5vZGUgPSBvbkV4cG9ydChpdGVtLCBub2RlLCBvcHRpb25zKSB8fCBub2RlO1xuXHRcdFx0dmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShpdGVtLl9kYXRhKTtcblx0XHRcdGlmIChkYXRhICYmIGRhdGEgICE9PSAne30nKVxuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJywgZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlICYmIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxuXG5cdEl0ZW0uaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIGV4cG9ydERlZmluaXRpb25zKGV4cG9ydFNWRyh0aGlzLCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcm9qZWN0LmluamVjdCh7XG5cdFx0ZXhwb3J0U1ZHOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdHZhciBsYXllcnMgPSB0aGlzLmxheWVycyxcblx0XHRcdFx0dmlldyA9IHRoaXMuZ2V0VmlldygpLFxuXHRcdFx0XHRzaXplID0gdmlldy5nZXRWaWV3U2l6ZSgpLFxuXHRcdFx0XHRub2RlID0gY3JlYXRlRWxlbWVudCgnc3ZnJywge1xuXHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0eTogMCxcblx0XHRcdFx0XHR3aWR0aDogc2l6ZS53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuXHRcdFx0XHRcdHZlcnNpb246ICcxLjEnLFxuXHRcdFx0XHRcdHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdFx0XHRcdCd4bWxuczp4bGluayc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0cGFyZW50ID0gbm9kZSxcblx0XHRcdFx0bWF0cml4ID0gdmlldy5fbWF0cml4O1xuXHRcdFx0aWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKVxuXHRcdFx0XHRwYXJlbnQgPSBub2RlLmFwcGVuZENoaWxkKFxuXHRcdFx0XHRcdFx0Y3JlYXRlRWxlbWVudCgnZycsIGdldFRyYW5zZm9ybShtYXRyaXgpKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChleHBvcnRTVkcobGF5ZXJzW2ldLCBvcHRpb25zLCB0cnVlKSk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBnZXRWYWx1ZShub2RlLCBuYW1lLCBpc1N0cmluZywgYWxsb3dOdWxsKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IFNWR05hbWVzcGFjZXNbbmFtZV0sXG5cdFx0XHR2YWx1ZSA9IG5hbWVzcGFjZVxuXHRcdFx0XHQ/IG5vZGUuZ2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKVxuXHRcdFx0XHQ6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXHRcdGlmICh2YWx1ZSA9PT0gJ251bGwnKVxuXHRcdFx0dmFsdWUgPSBudWxsO1xuXHRcdHJldHVybiB2YWx1ZSA9PSBudWxsXG5cdFx0XHRcdD8gYWxsb3dOdWxsXG5cdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdFx0PyAnJ1xuXHRcdFx0XHRcdFx0OiAwXG5cdFx0XHRcdDogaXNTdHJpbmdcblx0XHRcdFx0XHQ/IHZhbHVlXG5cdFx0XHRcdFx0OiBwYXJzZUZsb2F0KHZhbHVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBvaW50KG5vZGUsIHgsIHksIGFsbG93TnVsbCkge1xuXHRcdHggPSBnZXRWYWx1ZShub2RlLCB4LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHR5ID0gZ2V0VmFsdWUobm9kZSwgeSwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFBvaW50KHgsIHkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2l6ZShub2RlLCB3LCBoLCBhbGxvd051bGwpIHtcblx0XHR3ID0gZ2V0VmFsdWUobm9kZSwgdywgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0aCA9IGdldFZhbHVlKG5vZGUsIGgsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHJldHVybiBhbGxvd051bGwgJiYgKHcgPT0gbnVsbCB8fCBoID09IG51bGwpID8gbnVsbFxuXHRcdFx0XHQ6IG5ldyBTaXplKHcsIGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlLCB0eXBlLCBsb29rdXApIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09ICdub25lJ1xuXHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0OiB0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdD8gcGFyc2VGbG9hdCh2YWx1ZSlcblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheSdcblx0XHRcdFx0XHRcdD8gdmFsdWUgPyB2YWx1ZS5zcGxpdCgvW1xccyxdKy9nKS5tYXAocGFyc2VGbG9hdCkgOiBbXVxuXHRcdFx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InXG5cdFx0XHRcdFx0XHRcdD8gZ2V0RGVmaW5pdGlvbih2YWx1ZSkgfHwgdmFsdWVcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJ1xuXHRcdFx0XHRcdFx0XHRcdD8gbG9va3VwW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG5cdFx0XHRpc0NsaXAgPSB0eXBlID09PSAnY2xpcHBhdGgnLFxuXHRcdFx0aXRlbSA9IG5ldyBHcm91cCgpLFxuXHRcdFx0cHJvamVjdCA9IGl0ZW0uX3Byb2plY3QsXG5cdFx0XHRjdXJyZW50U3R5bGUgPSBwcm9qZWN0Ll9jdXJyZW50U3R5bGUsXG5cdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdGlmICghaXNDbGlwKSB7XG5cdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdFx0XHRwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBpdGVtLl9zdHlsZS5jbG9uZSgpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IG5vZGVzW2ldLFxuXHRcdFx0XHRjaGlsZDtcblx0XHRcdGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDFcblx0XHRcdFx0XHQmJiAoY2hpbGQgPSBpbXBvcnRTVkcoY2hpbGROb2RlLCBvcHRpb25zLCBmYWxzZSkpXG5cdFx0XHRcdFx0JiYgIShjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbCkpXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdH1cblx0XHRpdGVtLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHRpZiAoaXNDbGlwKVxuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLnJlZHVjZSgpLCBub2RlLCBpc1Jvb3QpO1xuXHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcblx0XHRpZiAoaXNDbGlwIHx8IHR5cGUgPT09ICdkZWZzJykge1xuXHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBvbHkobm9kZSwgdHlwZSkge1xuXHRcdHZhciBjb29yZHMgPSBub2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJykubWF0Y2goXG5cdFx0XHRcdFx0L1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb29yZHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2ldKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMpO1xuXHRcdGlmICh0eXBlID09PSAncG9seWdvbicpXG5cdFx0XHRwYXRoLmNsb3NlUGF0aCgpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UGF0aChub2RlKSB7XG5cdFx0dmFyIGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSgnZCcpLFxuXHRcdFx0cGFyYW0gPSB7IHBhdGhEYXRhOiBkYXRhIH07XG5cdFx0cmV0dXJuIChkYXRhLm1hdGNoKC9tL2dpKSB8fCBbXSkubGVuZ3RoID4gMSB8fCAvelxcUysvaS50ZXN0KGRhdGEpXG5cdFx0XHRcdD8gbmV3IENvbXBvdW5kUGF0aChwYXJhbSlcblx0XHRcdFx0OiBuZXcgUGF0aChwYXJhbSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcmFkaWVudChub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdGlzUmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50Jyxcblx0XHRcdGdyYWRpZW50O1xuXHRcdGlmIChpZCkge1xuXHRcdFx0Z3JhZGllbnQgPSBkZWZpbml0aW9uc1tpZF0uZ2V0R3JhZGllbnQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0XHRzdG9wcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG5cdFx0XHR9XG5cdFx0XHRncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgaXNSYWRpYWwpO1xuXHRcdH1cblx0XHR2YXIgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0O1xuXHRcdGlmIChpc1JhZGlhbCkge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5Jyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IG9yaWdpbi5hZGQoZ2V0VmFsdWUobm9kZSwgJ3InKSwgMCk7XG5cdFx0XHRoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IGdldFBvaW50KG5vZGUsICd4MicsICd5MicpO1xuXHRcdH1cblx0XHRhcHBseUF0dHJpYnV0ZXMoXG5cdFx0XHRuZXcgQ29sb3IoZ3JhZGllbnQsIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCksIG5vZGUpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGltcG9ydGVycyA9IHtcblx0XHQnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoY2hpbGQsIG9wdGlvbnMsIGlzUm9vdCk7XG5cdFx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRcdG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnOiBpbXBvcnRHcm91cCxcblx0XHRzdmc6IGltcG9ydEdyb3VwLFxuXHRcdGNsaXBwYXRoOiBpbXBvcnRHcm91cCxcblx0XHRwb2x5Z29uOiBpbXBvcnRQb2x5LFxuXHRcdHBvbHlsaW5lOiBpbXBvcnRQb2x5LFxuXHRcdHBhdGg6IGltcG9ydFBhdGgsXG5cdFx0bGluZWFyZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXHRcdHJhZGlhbGdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblxuXHRcdGltYWdlOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSk7XG5cdFx0XHRyYXN0ZXIub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnKTtcblx0XHRcdFx0dGhpcy5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChcblx0XHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4JywgJ3knKS5hZGQoc2l6ZS5kaXZpZGUoMikpKTtcblx0XHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJhc3Rlcjtcblx0XHR9LFxuXG5cdFx0c3ltYm9sOiBmdW5jdGlvbihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHJldHVybiBuZXcgU3ltYm9sKGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCksIHRydWUpO1xuXHRcdH0sXG5cblx0XHRkZWZzOiBpbXBvcnRHcm91cCxcblxuXHRcdHVzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdFx0ZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW2lkXSxcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChub2RlLCAneCcsICd5Jyk7XG5cdFx0XHRyZXR1cm4gZGVmaW5pdGlvblxuXHRcdFx0XHRcdD8gZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFN5bWJvbFxuXHRcdFx0XHRcdFx0PyBkZWZpbml0aW9uLnBsYWNlKHBvaW50KVxuXHRcdFx0XHRcdFx0OiBkZWZpbml0aW9uLmNsb25lKCkudHJhbnNsYXRlKHBvaW50KVxuXHRcdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXG5cdFx0Y2lyY2xlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLkNpcmNsZShnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0XHRnZXRWYWx1ZShub2RlLCAncicpKTtcblx0XHR9LFxuXG5cdFx0ZWxsaXBzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5FbGxpcHNlKHtcblx0XHRcdFx0Y2VudGVyOiBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0cmFkaXVzOiBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0cmVjdDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0JyksXG5cdFx0XHRcdHJhZGl1cyA9IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5Jyk7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLlJlY3RhbmdsZShuZXcgUmVjdGFuZ2xlKHBvaW50LCBzaXplKSwgcmFkaXVzKTtcblx0XHR9LFxuXG5cdFx0bGluZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQYXRoLkxpbmUoZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyksXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJykpO1xuXHRcdH0sXG5cblx0XHR0ZXh0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgdGV4dCA9IG5ldyBQb2ludFRleHQoZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpXG5cdFx0XHRcdFx0LmFkZChnZXRQb2ludChub2RlLCAnZHgnLCAnZHknKSkpO1xuXHRcdFx0dGV4dC5zZXRDb250ZW50KG5vZGUudGV4dENvbnRlbnQudHJpbSgpIHx8ICcnKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSkge1xuXHRcdHZhciB0cmFuc2Zvcm1zID0gKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8ICcnKS5zcGxpdCgvXFwpXFxzKi9nKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRyYW5zZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tpXTtcblx0XHRcdGlmICghdHJhbnNmb3JtKVxuXHRcdFx0XHRicmVhaztcblx0XHRcdHZhciBwYXJ0cyA9IHRyYW5zZm9ybS5zcGxpdCgvXFwoXFxzKi8pLFxuXHRcdFx0XHRjb21tYW5kID0gcGFydHNbMF0sXG5cdFx0XHRcdHYgPSBwYXJ0c1sxXS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGogPSAwLCBtID0gdi5sZW5ndGg7IGogPCBtOyBqKyspXG5cdFx0XHRcdHZbal0gPSBwYXJzZUZsb2F0KHZbal0pO1xuXHRcdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRtYXRyaXguY29uY2F0ZW5hdGUoXG5cdFx0XHRcdFx0XHRuZXcgTWF0cml4KHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRtYXRyaXgucm90YXRlKHZbMF0sIHZbMV0sIHZbMl0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdG1hdHJpeC50cmFuc2xhdGUodlswXSwgdlsxXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRtYXRyaXguc2NhbGUodik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2tld1gnOlxuXHRcdFx0XHRtYXRyaXguc2tldyh2WzBdLCAwKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdza2V3WSc6XG5cdFx0XHRcdG1hdHJpeC5za2V3KDAsIHZbMF0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5T3BhY2l0eShpdGVtLCB2YWx1ZSwgbmFtZSkge1xuXHRcdHZhciBjb2xvciA9IGl0ZW1bbmFtZSA9PT0gJ2ZpbGwtb3BhY2l0eScgPyAnZ2V0RmlsbENvbG9yJ1xuXHRcdFx0XHQ6ICdnZXRTdHJva2VDb2xvciddKCk7XG5cdFx0aWYgKGNvbG9yKVxuXHRcdFx0Y29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHR9XG5cblx0dmFyIGF0dHJpYnV0ZXMgPSBCYXNlLmVhY2goU1ZHU3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuXHRcdHRoaXNbZW50cnkuYXR0cmlidXRlXSA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtW2VudHJ5LnNldF0oY29udmVydFZhbHVlKHZhbHVlLCBlbnRyeS50eXBlLCBlbnRyeS5mcm9tU1ZHKSk7XG5cdFx0XHRpZiAoZW50cnkudHlwZSA9PT0gJ2NvbG9yJyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0dmFyIGNvbG9yID0gaXRlbVtlbnRyeS5nZXRdKCk7XG5cdFx0XHRcdGlmIChjb2xvcilcblx0XHRcdFx0XHRjb2xvci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0aXRlbS5nZXRQb3NpdGlvbih0cnVlKS5uZWdhdGUoKSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sIHtcblx0XHRpZDogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGRlZmluaXRpb25zW3ZhbHVlXSA9IGl0ZW07XG5cdFx0XHRpZiAoaXRlbS5zZXROYW1lKVxuXHRcdFx0XHRpdGVtLnNldE5hbWUodmFsdWUpO1xuXHRcdH0sXG5cblx0XHQnY2xpcC1wYXRoJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdHZhciBjbGlwID0gZ2V0RGVmaW5pdGlvbih2YWx1ZSk7XG5cdFx0XHRpZiAoY2xpcCkge1xuXHRcdFx0XHRjbGlwID0gY2xpcC5jbG9uZSgpO1xuXHRcdFx0XHRjbGlwLnNldENsaXBNYXNrKHRydWUpO1xuXHRcdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRcdFx0aXRlbS5pbnNlcnRDaGlsZCgwLCBjbGlwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEdyb3VwKGNsaXAsIGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdyYWRpZW50VHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcblx0XHR0cmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXG5cdFx0J2ZpbGwtb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblx0XHQnc3Ryb2tlLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG5cblx0XHR2aXNpYmlsaXR5OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aXRlbS5zZXRWaXNpYmxlKHZhbHVlID09PSAndmlzaWJsZScpO1xuXHRcdH0sXG5cblx0XHRkaXNwbGF5OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aXRlbS5zZXRWaXNpYmxlKHZhbHVlICE9PSBudWxsKTtcblx0XHR9LFxuXG5cdFx0J3N0b3AtY29sb3InOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uc2V0Q29sb3IpXG5cdFx0XHRcdGl0ZW0uc2V0Q29sb3IodmFsdWUpO1xuXHRcdH0sXG5cblx0XHQnc3RvcC1vcGFjaXR5JzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLl9jb2xvcilcblx0XHRcdFx0aXRlbS5fY29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHRcdH0sXG5cblx0XHRvZmZzZXQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgcGVyY2VudGFnZSA9IHZhbHVlLm1hdGNoKC8oLiopJSQvKTtcblx0XHRcdGl0ZW0uc2V0UmFtcFBvaW50KHBlcmNlbnRhZ2Vcblx0XHRcdFx0XHQ/IHBlcmNlbnRhZ2VbMV0gLyAxMDBcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0dmlld0JveDogZnVuY3Rpb24oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcykge1xuXHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgJ2FycmF5JykpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0JywgdHJ1ZSk7XG5cdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRcdHZhciBzY2FsZSA9IHNpemUgPyByZWN0LmdldFNpemUoKS5kaXZpZGUoc2l6ZSkgOiAxLFxuXHRcdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUocmVjdC5nZXRQb2ludCgpKS5zY2FsZShzY2FsZSk7XG5cdFx0XHRcdGl0ZW0udHJhbnNmb3JtKG1hdHJpeC5pbnZlcnRlZCgpKTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuXHRcdFx0XHRpZiAoc2l6ZSlcblx0XHRcdFx0XHRyZWN0LnNldFNpemUoc2l6ZSk7XG5cdFx0XHRcdHZhciBjbGlwID0gZ2V0QXR0cmlidXRlKG5vZGUsICdvdmVyZmxvdycsIHN0eWxlcykgIT0gJ3Zpc2libGUnLFxuXHRcdFx0XHRcdGdyb3VwID0gaXRlbS5fZGVmaW5pdGlvbjtcblx0XHRcdFx0aWYgKGNsaXAgJiYgIXJlY3QuY29udGFpbnMoZ3JvdXAuZ2V0Qm91bmRzKCkpKSB7XG5cdFx0XHRcdFx0Y2xpcCA9IG5ldyBTaGFwZS5SZWN0YW5nbGUocmVjdCkudHJhbnNmb3JtKGdyb3VwLl9tYXRyaXgpO1xuXHRcdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdFx0Z3JvdXAuYWRkQ2hpbGQoY2xpcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpIHtcblx0XHR2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gYXR0ciAmJiBhdHRyLnZhbHVlO1xuXHRcdGlmICghdmFsdWUpIHtcblx0XHRcdHZhciBzdHlsZSA9IEJhc2UuY2FtZWxpemUobmFtZSk7XG5cdFx0XHR2YWx1ZSA9IG5vZGUuc3R5bGVbc3R5bGVdO1xuXHRcdFx0aWYgKCF2YWx1ZSAmJiBzdHlsZXMubm9kZVtzdHlsZV0gIT09IHN0eWxlcy5wYXJlbnRbc3R5bGVdKVxuXHRcdFx0XHR2YWx1ZSA9IHN0eWxlcy5ub2RlW3N0eWxlXTtcblx0XHR9XG5cdFx0cmV0dXJuICF2YWx1ZVxuXHRcdFx0XHQ/IHVuZGVmaW5lZFxuXHRcdFx0XHQ6IHZhbHVlID09PSAnbm9uZSdcblx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBzdHlsZXMgPSB7XG5cdFx0XHRub2RlOiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlKSB8fCB7fSxcblx0XHRcdHBhcmVudDogIWlzUm9vdCAmJiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlLnBhcmVudE5vZGUpIHx8IHt9XG5cdFx0fTtcblx0XHRCYXNlLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXBwbHksIG5hbWUpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpO1xuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdGl0ZW0gPSBCYXNlLnBpY2soYXBwbHkoaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcyksIGl0ZW0pO1xuXHRcdH0pO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zID0ge307XG5cdGZ1bmN0aW9uIGdldERlZmluaXRpb24odmFsdWUpIHtcblx0XHR2YXIgbWF0Y2ggPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXFwoKD86I3wpKFteKSddKykvKTtcblx0XHRyZXR1cm4gbWF0Y2ggJiYgZGVmaW5pdGlvbnNbbWF0Y2hbMV1dO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0U1ZHKHNvdXJjZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0aWYgKCFzb3VyY2UpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRpZiAoIW9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvcHRpb25zID0geyBvbkxvYWQ6IG9wdGlvbnMgfTtcblx0XHR9XG5cblx0XHR2YXIgbm9kZSA9IHNvdXJjZSxcblx0XHRcdHNjb3BlID0gcGFwZXI7XG5cblx0XHRmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayhzdmcpIHtcblx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHR2YXIgaXRlbSA9IGltcG9ydFNWRyhzdmcsIG9wdGlvbnMsIGlzUm9vdCksXG5cdFx0XHRcdG9uTG9hZCA9IG9wdGlvbnMub25Mb2FkLFxuXHRcdFx0XHR2aWV3ID0gc2NvcGUucHJvamVjdCAmJiBzY29wZS5nZXRWaWV3KCk7XG5cdFx0XHRpZiAob25Mb2FkKVxuXHRcdFx0XHRvbkxvYWQuY2FsbCh0aGlzLCBpdGVtKTtcblx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmICEvXi4qPC8udGVzdChzb3VyY2UpKSB7XG5cdFx0XHRcdG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzb3VyY2UpO1xuXHRcdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRcdHNvdXJjZSA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEh0dHAucmVxdWVzdCgnZ2V0Jywgc291cmNlLCBvbkxvYWRDYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSBpbnN0YW5jZW9mIEZpbGUpIHtcblx0XHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRvbkxvYWRDYWxsYmFjayhyZWFkZXIucmVzdWx0KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNUZXh0KHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKVxuXHRcdFx0bm9kZSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc291cmNlLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuXHRcdGlmICghbm9kZS5ub2RlTmFtZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgU1ZHIHNvdXJjZTogJyArIHNvdXJjZSk7XG5cdFx0dmFyIHR5cGUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRpbXBvcnRlciA9IGltcG9ydGVyc1t0eXBlXSxcblx0XHRcdGl0ZW0sXG5cdFx0XHRkYXRhID0gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScpLFxuXHRcdFx0c2V0dGluZ3MgPSBzY29wZS5zZXR0aW5ncyxcblx0XHRcdHByZXZBcHBseU1hdHJpeCA9IHNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG5cdFx0aXRlbSA9IGltcG9ydGVyICYmIGltcG9ydGVyKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkgfHwgbnVsbDtcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IHByZXZBcHBseU1hdHJpeDtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKHR5cGUgIT09ICcjZG9jdW1lbnQnICYmICEoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0dmFyIG9uSW1wb3J0ID0gb3B0aW9ucy5vbkltcG9ydDtcblx0XHRcdGlmIChvbkltcG9ydClcblx0XHRcdFx0aXRlbSA9IG9uSW1wb3J0KG5vZGUsIGl0ZW0sIG9wdGlvbnMpIHx8IGl0ZW07XG5cdFx0XHRpZiAob3B0aW9ucy5leHBhbmRTaGFwZXMgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtLnRvUGF0aCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRhdGEpXG5cdFx0XHRcdGl0ZW0uX2RhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdH1cblx0XHRpZiAoaXNSb290KVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7fTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdEl0ZW0uaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZENoaWxkKGltcG9ydFNWRyhub2RlLCBvcHRpb25zLCB0cnVlKSk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcm9qZWN0LmluamVjdCh7XG5cdFx0aW1wb3J0U1ZHOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0XHRyZXR1cm4gaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRydWUpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5wYXBlciA9IG5ldyAoUGFwZXJTY29wZS5pbmplY3QoQmFzZS5leHBvcnRzLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdEJhc2U6IEJhc2UsXG5cdE51bWVyaWNhbDogTnVtZXJpY2FsLFxuXHRLZXk6IEtleVxufSkpKCk7XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0ZGVmaW5lKCdwYXBlcicsIHBhcGVyKTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcGFwZXI7XG59XG5cbnJldHVybiBwYXBlcjtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsInZhciBwYXBlciA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWNvcmUuanMnKTtcblxuZnVuY3Rpb24gQ29udG91ciggYXJncyApIHtcblx0cGFwZXIuUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCggdGhpcywgYXJncyApO1xuXG5cdHRoaXMubm9kZXMgPSB0aGlzLnNlZ21lbnRzO1xufVxuXG5Db250b3VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFwZXIuUGF0aC5wcm90b3R5cGUpO1xuQ29udG91ci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250b3VyO1xuXG5Db250b3VyLnByb3RvdHlwZS5hZGROb2RlcyA9IHBhcGVyLlBhdGgucHJvdG90eXBlLmFkZFNlZ21lbnRzO1xuXG5Db250b3VyLnByb3RvdHlwZS5wcmVwYXJlT1QgPSBmdW5jdGlvbiggcGF0aCApIHtcblx0cGF0aC5jb21tYW5kcy5wdXNoKHtcblx0XHR0eXBlOiAnTScsXG5cdFx0eDogTWF0aC5yb3VuZCggdGhpcy5maXJzdFNlZ21lbnQucG9pbnQueCApIHx8IDAsXG5cdFx0eTogTWF0aC5yb3VuZCggdGhpcy5maXJzdFNlZ21lbnQucG9pbnQueSApIHx8IDBcblx0fSk7XG5cblx0dGhpcy5jdXJ2ZXMuZm9yRWFjaChmdW5jdGlvbiggY3VydmUgKSB7XG5cdFx0aWYgKCBjdXJ2ZS5pc0xpbmVhcigpICkge1xuXHRcdFx0cGF0aC5jb21tYW5kcy5wdXNoKHtcblx0XHRcdFx0dHlwZTogJ0wnLFxuXHRcdFx0XHR4OiBNYXRoLnJvdW5kKCBjdXJ2ZS5wb2ludDIueCApIHx8IDAsXG5cdFx0XHRcdHk6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50Mi55ICkgfHwgMFxuXHRcdFx0fSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5jb21tYW5kcy5wdXNoKHtcblx0XHRcdFx0dHlwZTogJ0MnLFxuXHRcdFx0XHR4MTogTWF0aC5yb3VuZCggY3VydmUucG9pbnQxLnggKyBjdXJ2ZS5oYW5kbGUxLnggKSB8fCAwLFxuXHRcdFx0XHR5MTogTWF0aC5yb3VuZCggY3VydmUucG9pbnQxLnkgKyBjdXJ2ZS5oYW5kbGUxLnkgKSB8fCAwLFxuXHRcdFx0XHR4MjogTWF0aC5yb3VuZCggY3VydmUucG9pbnQyLnggKyBjdXJ2ZS5oYW5kbGUyLnggKSB8fCAwLFxuXHRcdFx0XHR5MjogTWF0aC5yb3VuZCggY3VydmUucG9pbnQyLnkgKyBjdXJ2ZS5oYW5kbGUyLnkgKSB8fCAwLFxuXHRcdFx0XHR4OiBNYXRoLnJvdW5kKCBjdXJ2ZS5wb2ludDIueCApIHx8IDAsXG5cdFx0XHRcdHk6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50Mi55ICkgfHwgMFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcGF0aDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udG91cjsiLCJ2YXIgb3BlbnR5cGUgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzJyksXG5cdEdseXBoID0gcmVxdWlyZSgnLi9HbHlwaC5qcycpO1xuXG5mdW5jdGlvbiBGb250KCBhcmdzICkge1xuXHRpZiAoICFhcmdzICkge1xuXHRcdGFyZ3MgPSB7fTtcblx0fVxuXG5cdGlmICggIWFyZ3Muc3R5bGVOYW1lICkge1xuXHRcdGFyZ3Muc3R5bGVOYW1lID0gJ1JlZ3VsYXInO1xuXHR9XG5cblx0aWYgKCAhYXJncy51bml0c1BlckVtICkge1xuXHRcdGFyZ3MudW5pdHNQZXJFbSA9IDEwMjQ7XG5cdH1cblxuXHR0aGlzLm90ID0gbmV3IG9wZW50eXBlLkZvbnQoIGFyZ3MgKTtcblxuXHR0aGlzLmdseXBocyA9IFtdO1xuXHR0aGlzLmdseXBoTWFwID0ge307XG5cdHRoaXMuY2hhck1hcCA9IHt9O1xuXHR0aGlzLmFsdE1hcCA9IHt9O1xuXHR0aGlzLl9zdWJzZXQgPSBmYWxzZTtcblxuXHR0aGlzLmFkZEdseXBoKG5ldyBHbHlwaCh7XG5cdFx0bmFtZTogJy5ub3RkZWYnLFxuXHRcdHVuaWNvZGU6IDBcblx0fSkpO1xufVxuXG5Gb250LnByb3RvdHlwZS5hZGRHbHlwaCA9IGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0dGhpcy5nbHlwaHMucHVzaCggZ2x5cGggKTtcblx0dGhpcy5nbHlwaE1hcFtnbHlwaC5uYW1lXSA9IGdseXBoO1xuXG5cdC8vIGJ1aWxkIHRoZSBkZWZhdWx0IGNtYXBcblx0Ly8gaWYgbXVsdGlwbGUgZ2x5cGhzIHNoYXJlIHRoZSBzYW1lIHVuaWNvZGUsIHVzZSB0aGUgZ2x5cGggd2hlcmUgdW5pY29kZSBhbmQgbmFtZSBhcmUgZXF1YWxcblx0aWYgKCAhdGhpcy5jaGFyTWFwW2dseXBoLnVuaWNvZGVdIHx8XG5cdFx0XHQoIGdseXBoLm5hbWUubGVuZ3RoID09PSAxICYmIGdseXBoLm5hbWUuY2hhckNvZGVBdCgwKSA9PT0gZ2x5cGgudW5pY29kZSApICkge1xuXG5cdFx0dGhpcy5jaGFyTWFwW2dseXBoLnVuaWNvZGVdID0gZ2x5cGg7XG5cdH1cblxuXHQvLyBidWlsZCB0aGUgYWx0ZXJuYXRlcyBtYXBcblx0aWYgKCAhdGhpcy5hbHRNYXBbZ2x5cGgudW5pY29kZV0gKSB7XG5cdFx0dGhpcy5hbHRNYXBbZ2x5cGgudW5pY29kZV0gPSBbXTtcblx0fVxuXHR0aGlzLmFsdE1hcFtnbHlwaC51bmljb2RlXS5wdXNoKCBnbHlwaCApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuRm9udC5wcm90b3R5cGUuYWRkR2x5cGhzID0gZnVuY3Rpb24oIGdseXBocyApIHtcblx0Z2x5cGhzLmZvckVhY2goZnVuY3Rpb24oIGdseXBoICkge1xuXHRcdHRoaXMuYWRkR2x5cGgoZ2x5cGgpO1xuXG5cdH0sIHRoaXMpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KCBGb250LnByb3RvdHlwZSwgJ3N1YnNldCcsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3Vic2V0O1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBzZXQgKSB7XG5cdFx0aWYgKCBzZXQgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuICggdGhpcy5fc3Vic2V0ID0gZmFsc2UgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKCB0aGlzLl9zdWJzZXQgPSAodHlwZW9mIHNldCA9PT0gJ3N0cmluZycgPyBzZXQuc3BsaXQoJycpIDogc2V0KVxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbihlLCBpLCBhcnIpIHtcblx0XHRcdFx0cmV0dXJuIGFyci5sYXN0SW5kZXhPZihlKSA9PT0gaTtcblx0XHRcdH0pXG5cdFx0XHQubWFwKGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0cmV0dXJuIGUuY2hhckNvZGVBdCgwKTtcblx0XHRcdH0pXG5cdFx0XHQuc29ydCgpXG5cdFx0KTtcblx0fVxufSk7XG5cbkZvbnQucHJvdG90eXBlLmdldEdseXBoU3Vic2V0ID0gZnVuY3Rpb24oIHNldCApIHtcblx0aWYgKCBzZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzLnN1YnNldCA9IHNldDtcblx0fVxuXG5cdC8vIHJldXNlIGxhc3Qgc3Vic2V0IGlmIHBvc3NpYmxlXG5cdGlmICggdGhpcy5fbGFzdFN1YnNldCAmJiB0aGlzLl9sYXN0U3Vic2V0WzBdID09PSAoIHRoaXMuX3N1YnNldCB8fCBbXSApLmpvaW4oKSApIHtcblx0XHRyZXR1cm4gdGhpcy5fbGFzdFN1YnNldFsxXTtcblx0fVxuXG5cdC8vIG1lbW9pemUgbGFzdCBzdWJzZXRcblx0dGhpcy5fbGFzdFN1YnNldCA9IFtcblx0XHQoIHRoaXMuX3N1YnNldCB8fCBbXSApLmpvaW4oKSxcblx0XHR0aGlzLmdseXBocy5maWx0ZXIoZnVuY3Rpb24oIGdseXBoICkge1xuXHRcdFx0aWYgKCB0aGlzLl9zdWJzZXQgPT09IGZhbHNlICYmICggZ2x5cGgudW5pY29kZSAhPT0gZmFsc2UgfHwgZ2x5cGgudW5pY29kZXMubGVuZ3RoICkgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuX3N1YnNldC5pbmRleE9mKCBnbHlwaC51bmljb2RlICkgIT09IC0xICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogaGFuZGxlIG11bHRpcGxlIHVuaWNvZGVzXG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LCB0aGlzKVxuXHRdO1xuXG5cdHJldHVybiB0aGlzLl9sYXN0U3Vic2V0WzFdO1xufTtcblxuRm9udC5wcm90b3R5cGUucHJlcGFyZU9UID0gZnVuY3Rpb24oIHNldCApIHtcblx0dGhpcy5vdC5nbHlwaHMgPSB0aGlzLmdldEdseXBoU3Vic2V0KCBzZXQgKS5tYXAoZnVuY3Rpb24oIGdseXBoICkge1xuXHRcdHJldHVybiBnbHlwaC5wcmVwYXJlT1QoKTtcblx0fSk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5pZiAoIHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5kb2N1bWVudCApIHtcblxuXHR2YXIgX1VSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCxcblx0XHRydWxlSW5kZXg7XG5cdEZvbnQucHJvdG90eXBlLmFkZFRvRm9udHMgPSBkb2N1bWVudC5mb250cyA/XG5cdFx0Ly8gQ1NTIGZvbnQgbG9hZGluZywgbGlnaHRuaW5nIGZhc3Rcblx0XHRmdW5jdGlvbiggYnVmZmVyICkge1xuXHRcdFx0dmFyIGZvbnRmYWNlID0gbmV3IEZvbnRGYWNlKFxuXHRcdFx0XHR0aGlzLm90LmZhbWlseU5hbWUsXG5cdFx0XHRcdGJ1ZmZlciB8fCB0aGlzLm90LnRvQnVmZmVyKClcblx0XHRcdCk7XG5cblx0XHRcdGRvY3VtZW50LmZvbnRzLmFkZCggZm9udGZhY2UgKTtcblxuXHRcdFx0aWYgKCB0aGlzLmxhc3RGb250RmFjZSApIHtcblx0XHRcdFx0ZG9jdW1lbnQuZm9udHMuZGVsZXRlKCB0aGlzLmxhc3RGb250RmFjZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmxhc3RGb250RmFjZSA9IGZvbnRmYWNlO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9OlxuXHRcdGZ1bmN0aW9uKCBidWZmZXIgKSB7XG5cdFx0XHR2YXIgdXJsID0gX1VSTC5jcmVhdGVPYmplY3RVUkwoXG5cdFx0XHRcdG5ldyBCbG9iKFxuXHRcdFx0XHRcdFsgbmV3IERhdGFWaWV3KCBidWZmZXIgfHzCoHRoaXMub3QudG9CdWZmZXIoKSApIF0sXG5cdFx0XHRcdFx0e3R5cGU6ICdmb250L29wZW50eXBlJ31cblx0XHRcdFx0KVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCBydWxlSW5kZXggKSB7XG5cdFx0XHRcdGRvY3VtZW50LnN0eWxlU2hlZXRzWzBdLmRlbGV0ZVJ1bGUoIHJ1bGVJbmRleCApO1xuXHRcdFx0fVxuXG5cdFx0XHRydWxlSW5kZXggPSBkb2N1bWVudC5zdHlsZVNoZWV0c1swXS5pbnNlcnRSdWxlKFxuXHRcdFx0XHQnQGZvbnQtZmFjZSB7IGZvbnQtZmFtaWx5OiBcIicgKyB0aGlzLm90LmZhbWlseU5hbWUgKyAnXCI7IHNyYzogdXJsKCcgKyB1cmwgKyAnKTsgfScsXG5cdFx0XHRcdHJ1bGVJbmRleCB8fMKgZG9jdW1lbnQuc3R5bGVTaGVldHNbMF0uY3NzUnVsZXMubGVuZ3RoXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdEZvbnQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24oIGJ1ZmZlciApIHtcblx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuXHRcdHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5sb2NhdGlvbiA9IHJlYWRlci5yZXN1bHQ7XG5cdFx0fTtcblxuXHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKG5ldyBCbG9iKFxuXHRcdFx0WyBuZXcgRGF0YVZpZXcoIGJ1ZmZlciB8fCB0aGlzLm90LnRvQnVmZmVyKCkgKSBdLFxuXHRcdFx0e3R5cGU6ICdmb250L29wZW50eXBlJ31cblx0XHQpKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRm9udDsiLCJ2YXIgb3BlbnR5cGUgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzJyksXG5cdHBhcGVyID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItY29yZS5qcycpO1xuXG5mdW5jdGlvbiBHbHlwaCggYXJncyApIHtcblx0cGFwZXIuR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KCB0aGlzICk7XG5cblx0aWYgKCBhcmdzLnVuaWNvZGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRhcmdzLnVuaWNvZGUgPSBhcmdzLm5hbWUuY2hhckNvZGVBdCgwKTtcblx0fVxuXG5cdGlmICggdHlwZW9mIGFyZ3MudW5pY29kZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0YXJncy51bmljb2RlID0gYXJncy51bmljb2RlLmNoYXJDb2RlQXQoMCk7XG5cdH1cblxuXHR0aGlzLm5hbWUgPSBhcmdzLm5hbWU7XG5cdHRoaXMudW5pY29kZSA9IGFyZ3MudW5pY29kZTtcblxuXHR0aGlzLm90ID0gbmV3IG9wZW50eXBlLkdseXBoKCBhcmdzICk7XG5cdHRoaXMub3QucGF0aCA9IG5ldyBvcGVudHlwZS5QYXRoKCk7XG5cblx0dGhpcy5jb250b3VycyA9IFtdO1xuXHR0aGlzLmFuY2hvcnMgPSBbXTtcblx0dGhpcy5jb21wb25lbnRzID0gW107XG5cdHRoaXMucGFyZW50QW5jaG9ycyA9IFtdO1xufVxuXG5HbHlwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcGVyLkdyb3VwLnByb3RvdHlwZSk7XG5HbHlwaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHbHlwaDtcblxuR2x5cGgucHJvdG90eXBlLmFkZENvbnRvdXIgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0dGhpcy5hZGRDaGlsZCggaXRlbSApO1xuXHR0aGlzLmNvbnRvdXJzLnB1c2goIGl0ZW0gKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5HbHlwaC5wcm90b3R5cGUuYWRkQ29tcG9uZW50ID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdHRoaXMuYWRkQ2hpbGQoIGl0ZW0gKTtcblx0dGhpcy5jb21wb25lbnRzLnB1c2goIGl0ZW0gKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5HbHlwaC5wcm90b3R5cGUuYWRkQW5jaG9yID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdHRoaXMuYW5jaG9ycy5wdXNoKCBpdGVtICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuR2x5cGgucHJvdG90eXBlLmFkZFBhcmVudEFuY2hvciA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHR0aGlzLnBhcmVudEFuY2hvcnMucHVzaCggaXRlbSApO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkdseXBoLnByb3RvdHlwZS5wcmVwYXJlT1QgPSBmdW5jdGlvbiggcGF0aCApIHtcblx0aWYgKCAhcGF0aCApIHtcblx0XHR0aGlzLm90LnBhdGguY29tbWFuZHMgPSBbXTtcblx0XHRwYXRoID0gdGhpcy5vdC5wYXRoO1xuXHR9XG5cblx0dGhpcy5jb250b3Vycy5mb3JFYWNoKGZ1bmN0aW9uKCBjb250b3VyICkge1xuXHRcdGNvbnRvdXIucHJlcGFyZU9UKCB0aGlzLm90LnBhdGggKTtcblx0fSwgdGhpcyk7XG5cblx0cmV0dXJuIHRoaXMub3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBoOyIsInZhciBwYXBlciA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWNvcmUuanMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KCBwYXBlci5TZWdtZW50LnByb3RvdHlwZSwgJ3gnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucG9pbnQueDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5wb2ludC54ID0gdmFsdWU7XG5cdH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoIHBhcGVyLlNlZ21lbnQucHJvdG90eXBlLCAneScsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludC55O1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLnBvaW50LnkgPSB2YWx1ZTtcblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFwZXIuU2VnbWVudDsiLCJ2YXIgb3BlbnR5cGUgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzJyksXG5cdHBhcGVyID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItY29yZS5qcycpLFxuXHRGb250ID0gcmVxdWlyZSgnLi9Gb250LmpzJyksXG5cdEdseXBoID0gcmVxdWlyZSgnLi9HbHlwaC5qcycpLFxuXHRDb250b3VyID0gcmVxdWlyZSgnLi9Db250b3VyLmpzJyksXG5cdE5vZGUgPSByZXF1aXJlKCcuL05vZGUuanMnKTtcblxuZnVuY3Rpb24gcGx1bWluKCkge31cblxucGx1bWluLm9wZW50eXBlID0gb3BlbnR5cGU7XG5wbHVtaW4ucGFwZXIgPSBwYXBlcjtcbnBsdW1pbi5Gb250ID0gRm9udDtcbnBsdW1pbi5HbHlwaCA9IEdseXBoO1xucGx1bWluLkNvbnRvdXIgPSBDb250b3VyO1xucGx1bWluLk5vZGUgPSBOb2RlO1xucGx1bWluLlBvaW50ID0gcGFwZXIuUG9pbnQ7XG5wbHVtaW4uTWF0cml4ID0gcGFwZXIuTWF0cml4O1xucGx1bWluLnNldHVwID0gcGFwZXIuc2V0dXAuYmluZChwYXBlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gcGx1bWluOyJdfQ==
